;;
;; Parameter typing
;;

rule Param_ok/param-default:
  p C |- id dir type expr : (id dir typ_p val) tid_fresh*
  -- Type_ok: p C |- type : typ_p tid_fresh*
  -- if tidset = $union_set<tid>($bound_tids(p, C), `{ tid_fresh* })
  -- Type_wf: tidset |- typ_p
  ----
  -- Expr_ok: p C |- expr : exprIL_e
  -- if `(typ_e; LCTK) = $annot(exprIL_e)
  ----
  -- Sub_impl: typ_e << typ_p
  -- Eval_static: p C |- exprIL_e ~> val

rule Param_ok/param-nodefault:
  p C |- id dir type eps : (id dir typ_p eps) tid_fresh*
  -- Type_ok: p C |- type : typ_p tid_fresh*
  -- if tidset = $union_set<tid>($bound_tids(p, C), `{ tid_fresh* })
  -- Type_wf: tidset |- typ_p

;;
;; Constructor parameter typing
;;

rule CParam_ok/cparam-default:
  p C |- id dir type expr : (id dir typ_p val) tid_fresh*
  -- Type_ok: p C |- type : typ_p tid_fresh*
  -- if tidset = $union_set<tid>($bound_tids(p, C), `{ tid_fresh* })
  -- Type_wf: tidset |- typ_p
  ----
  -- Expr_ok: p C |- expr : exprIL_e
  -- if `(typ_e; LCTK) = $annot(exprIL_e)
  ----
  -- Sub_impl: typ_e << typ_p
  -- Eval_static: p C |- exprIL_e ~> val

rule CParam_ok/cparam-nodefault:
  p C |- id dir type eps : (id dir typ_p eps) tid_fresh*
  -- Type_ok: p C |- type : typ_p tid_fresh*
  -- if tidset = $union_set<tid>($bound_tids(p, C), `{ tid_fresh* })
  -- Type_wf: tidset |- typ_p

;;
;; Constant declaration
;;

rule Decl_ok/constd:
  p C |- ConstD id type expr : C' (ConstD id typ_c val)
  -- Type_ok: p C |- type : typ_c eps
  -- Type_wf: $bound_tids(p, C) |- typ_c
  ----
  -- Expr_ok: p C |- expr : exprIL
  -- if `(_; LCTK) = $annot(exprIL)
  -- if exprIL' = $coerce_assign(exprIL, typ_c)
  ----
  -- Eval_static: p C |- exprIL' ~> val
  ----
  -- if C' = $add_styp(p, C, id, typ_c NO LCTK val)

;;
;; Variable declaration
;;

rule Decl_ok/vard-none:
  p C |- VarD id type eps : C' (VarD id typ eps)
  -- Type_ok: p C |- type : typ eps
  -- Type_wf: $bound_tids(p, C) |- typ
  -- if $is_assignable(typ)
  -- if C' = $add_styp(p, C, id, typ INOUT DYN eps)

rule Decl_ok/vard-some:
  p C |- VarD id type expr : C' (VarD id typ exprIL')
  -- Type_ok: p C |- type : typ eps
  -- Type_wf: $bound_tids(p, C) |- typ
  -- if $is_assignable(typ)
  ----
  -- Expr_ok: p C |- expr : exprIL
  -- if exprIL' = $coerce_assign(exprIL, typ)
  ----
  -- if C' = $add_styp(p, C, id, typ INOUT DYN eps)

;;
;; Instantiation declaration
;;

relation Inst_init_decl_ok:
  cursor context frame fdenv |- decl : frame fdenv declIL
  hint(input %0 %1 %2 %3 %4)

rule Inst_init_decl_ok/instd:
  p C frame fdenv |- (InstD id' name targ* arg* decl*) : frame' fdenv declIL
  -- Decl_ok: p C |- (InstD id' name targ* arg* decl*) : C' declIL
  ----
  -- if styp' = $find_styp(p, C', CURRENT id')
  -- if frame' = $update_map<id, styp>(frame, id', styp')

rule Inst_init_decl_ok/funcd:
  p C_0 frame fdenv |- (FuncD id type_r tparam* param* block)
                       : frame fdenv' (FuncD id typ_r tparam* tparam_hidden* paramIL* blockIL)
  -- if fid = $to_fid(id, param*)
  -- if C_1 = $set_blockkind(C_0, EXTERN)
  -- if C_2 = C_1[ .BLOCK.FRAME = frame ]
  ----
  -- if C_3 = $add_tparams(LOCAL, C_2, tparam*)
  ----
  -- Type_ok: LOCAL C_3 |- type_r : typ_r eps
  ----
  -- if C_4 = $set_localkind(C_3, EXTERNABSTRACTMETHOD typ_r)
  ----
  -- (Param_ok: LOCAL C_4 |- param : paramIL tid_fresh_p*)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_p**)
  ----
  -- if C_5 = $add_params(LOCAL, C_4, paramIL*)
  -- if C_6 = $add_tparams(LOCAL, C_5, tparam_hidden*)
  ----
  -- Block_ok: LOCAL C_6 CONT INIT |- block : C_7 f blockIL
  -- if f = RET \/ typ_r = VoidT
  ----
  -- if fd = PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT paramIL* typ_r)
  ----
  -- FuncDef_wf: $bound_tids(p, C_0) |- fd
  ----
  -- if fdenv' = $update_map<fid, funcdef>(fdenv, fid, fd)


relation Inst_init_decls_ok:
  context frame fdenv |- decl* : frame fdenv declIL*
  hint(input %0 %1 %2 %3)

rule Inst_init_decls_ok/nil:
  C frame fdenv |- eps : frame fdenv eps

rule Inst_init_decls_ok/cons:
  C frame fdenv |- decl_h :: decl_t* : frame'' fdenv'' (declIL_h :: declIL_t*)
  -- Inst_init_decl_ok: GLOBAL C frame fdenv |- decl_h : frame' fdenv' declIL_h
  -- Inst_init_decls_ok: C frame' fdenv' |- decl_t* : frame'' fdenv'' declIL_t*


dec $update_fdenv_extern(fdenv, theta, fid*, funcdef*) : map<fid, funcdef>
    hint(show UPDATE_FDENV_EXTERN%latex("(")#%1#%latex(", ")#%2#%latex(", ")#%3#%latex(", ")#%4#%latex(")"))

def $update_fdenv_extern(fdenv_ext, theta, eps, eps) = fdenv_ext
def $update_fdenv_extern(fdenv_ext, theta, fid_h :: fid_t*, fd_h :: fd_t*) = $update_fdenv_extern(fdenv_ext', theta, fid_t*, fd_t*)
  -- if PolyFD (tparam*, tparam_hidden*) -> (ExternAbstractMethodT pt* typ_r) = $find_map<fid, funcdef>(fdenv_ext, fid_h)
  -- if fd_ext = PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT pt* typ_r)
  -- if fd_ext' = $subst_funcdef(theta, fd_ext)
  -- FuncDef_alpha: fd_ext' ~~ fd_h
  -- if fdenv_ext' = $update_map<fid, funcdef>(fdenv_ext, fid_h, fd_ext')

rule Decl_ok/instd-some:
  p C |- InstD id name_inst targ* arg* decl* : C'' (InstD id typ name_inst targIL'* argIL'* declIL*)
  -- if |decl*| > 0
  ----
  -- (Type_ok: p C |- targ : targIL tid_fresh_a*)*
  -- if tid_fresh* = $concat_<tid>(tid_fresh_a**)
  ----
  -- ConsType_ok: p C |- name_inst targIL* arg* : ct tid_fresh_inserted* id_deft*
  ----
  -- Inst_ok: p C (tid_fresh* ++ tid_fresh_inserted*) |- ct targIL* arg* id_deft* : typ targIL'* argIL'*
  ----
  -- if typ = SpecT (PolyD (tparam*, tparam_hidden*) -> (ExternT id_ext fdenv_ext)) typ_a*
  -- if C' = $add_styp(LOCAL, C, "this", typ NO CTK eps)
  ----
  -- Inst_init_decls_ok: C' $empty_frame $empty_fdenv |- decl* : frame_abs fdenv_abs declIL*
  -- if `{ (fid_abs -> fd_abs)* } = fdenv_abs
  ----
  -- if tparam'* = tparam* ++ tparam_hidden*
  -- if theta = `{ (tparam' -> typ_a)* }
  -- if fdenv_ext' = $update_fdenv_extern(fdenv_ext, theta, fid_abs*, fd_abs*)
  -- if `{ (fid_ext -> fd_ext)* } = fdenv_ext'
  ----
  -- if (PolyFD _ -> ft)* = fd_ext*
  -- (if ~$is_externabstractmethodt(ft))*
  ----
  -- if typ' = SpecT (PolyD (tparam*, tparam_hidden*) -> (ExternT id_ext fdenv_ext')) typ_a*
  -- if C'' = $add_styp(p, C, id, typ' NO CTK eps)

rule Decl_ok/instd-none:
  p C |- InstD id name_inst targ* arg* eps : C' (InstD id typ name_inst targIL'* argIL'* eps)
  -- (Type_ok: p C |- targ : targIL tid_fresh_a*)*
  -- if tid_fresh* = $concat_<tid>(tid_fresh_a**)
  ----
  -- ConsType_ok: p C |- name_inst targIL* arg* : ct tid_fresh_inserted* id_deft*
  ----
  -- Inst_ok: p C (tid_fresh* ++ tid_fresh_inserted*) |- ct targIL* arg* id_deft* : typ targIL'* argIL'*
  ----
  -- if C' = $add_styp(p, C, id, typ NO CTK eps)

;;
;; Error declaration
;;

rule Decl_ok/errd:
  GLOBAL C |- ErrD member* : C' (ErrD member*)
  -- if $distinct_<member>(member*)
  ----
  -- if (id_e = $concat_text([ "error.", member ]))*
  -- if (val_e = ErrV member)*
  -- if (styp_e = ErrT NO LCTK val_e)*
  ----
  -- if C' = $add_styps(GLOBAL, C, id_e*, styp_e*)

;;
;; Match kind declaration
;;

rule Decl_ok/matchkindd:
  GLOBAL C |- MatchKindD member* : C' (MatchKindD member*)
  -- if $distinct_<member>(member*)
  ----
  -- if (id_m = member)*
  -- if (val_m = MatchKindV member)*
  -- if (styp_m = MatchKindT NO LCTK val_m)*
  ----
  -- if C' = $add_styps(GLOBAL, C, id_m*, styp_m*)

;;
;; Struct declaration
;;

rule Decl_ok/structd:
  GLOBAL C |- StructD id tparam* (member_f, type_f)* : C'' (StructD id tparam* tparam_hidden* (member_f, typ_f)*)
  -- if C' = $add_tparams(BLOCK, C, tparam*)
  -- (Type_ok: BLOCK C' |- type_f : typ_f tid_fresh_f*)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_f**)
  ----
  -- if typ_s = StructT id (member_f, typ_f)*
  -- if td = PolyD (tparam*, tparam_hidden*) -> typ_s
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  ----
  -- if C'' = $add_typdef(GLOBAL, C, id, td)

;;
;; Header declaration
;;

rule Decl_ok/headerd:
  GLOBAL C |- HeaderD id tparam* (member_f, type_f)* : C'' (HeaderD id tparam* tparam_hidden* (member_f, typ_f)*)
  -- if C' = $add_tparams(BLOCK, C, tparam*)
  -- (Type_ok: BLOCK C' |- type_f : typ_f tid_fresh_f*)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_f**)
  ----
  -- if typ_s = HeaderT id (member_f, typ_f)*
  -- if td = PolyD (tparam*, tparam_hidden*) -> typ_s
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  ----
  -- if C'' = $add_typdef(GLOBAL, C, id, td)

;;
;; Header union declaration
;;

rule Decl_ok/uniond:
  GLOBAL C |- UnionD id tparam* (member_f, type_f)* : C'' (UnionD id tparam* tparam_hidden* (member_f, typ_f)*)
  -- if C' = $add_tparams(BLOCK, C, tparam*)
  -- (Type_ok: BLOCK C' |- type_f : typ_f tid_fresh_f*)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_f**)
  ----
  -- if typ_s = UnionT id (member_f, typ_f)*
  -- if td = PolyD (tparam*, tparam_hidden*) -> typ_s
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  ----
  -- if C'' = $add_typdef(GLOBAL, C, id, td)

;;
;; Enum declaration
;;

rule Decl_ok/enumd:
  GLOBAL C |- EnumD id member* : C'' (EnumD id member*)
  -- if $distinct_<member>(member*)
  ----
  -- if (id_e = $concat_text([ id, ".", member ]))*
  -- if (val_e = EnumFieldV id member)*
  -- if typ_e = EnumT id member*
  -- if (styp_e = typ_e NO LCTK val_e)*
  ----
  -- if C' = $add_styps(GLOBAL, C, id_e*, styp_e*)
  ----
  -- if td = MonoD typ_e
  -- if tidset = $bound_tids(GLOBAL, C)
  -- TypeDef_wf: tidset |- td
  -- if C'' = $add_typdef(GLOBAL, C', id, td)

;;
;; Serializable enum declaration
;;

relation SEnum_field_ok:
  context id typ (member, val)* |- member expr : context (member, val)*
  hint(input %0 %1 %2 %3 %4 %5)

rule SEnum_field_ok:
  C id_s typ_s (member_s, val_s)* |- member expr : C' (member_s', val_s')*
  -- Expr_ok: BLOCK C |- expr : exprIL
  -- if `(_; LCTK) = $annot(exprIL)
  -- if exprIL' = $coerce_assign(exprIL, typ_s)
  -- Eval_static: BLOCK C |- exprIL' ~> val_e
  ----
  -- if val = SEnumFieldV id_s member val_e
  ----
  -- if member_s'* = member_s* ++ [ member ]
  -- if val_s'* = val_s* ++ [ val ]
  -- if typ_f = SEnumT id_s typ_s (member_s', val_s')*
  ----
  -- if C' = $add_styp(BLOCK, C, member, typ_f NO LCTK val)


relation SEnum_fields_ok:
  context id typ (member, val)* |- (member, expr)* : context (member, val)*
  hint(input %0 %1 %2 %3 %4)

rule SEnum_fields_ok/nil:
  C id typ (member, val)* |- eps : C (member, val)*

rule SEnum_fields_ok/cons:
  C id typ (member, val)* |- (member_h, expr_h) :: (member_t, expr_t)* : C'' (member'', val'')*
  -- SEnum_field_ok: C id typ (member, val)* |- member_h expr_h : C' (member', val')*
  ----
  -- SEnum_fields_ok: C' id typ (member', val')* |- (member_t, expr_t)* : C'' (member'', val'')*


rule Decl_ok/senumd:
  GLOBAL C_0 |- SEnumD id type (member, expr)* : C_3 (SEnumD id typ (member, val_s)*)
  -- if $distinct_<member>(member*)
  ----
  -- Type_ok: GLOBAL C_0 |- type : typ eps
  -- Type_wf: $bound_tids(GLOBAL, C_0) |- typ
  ----
  -- SEnum_fields_ok: C_0 id typ eps |- (member, expr)* : C_1 (member, val_s)*
  ----
  -- if (id_s = $concat_text([ id, ".", member ]))*
  -- if typ_s = SEnumT id typ (member, val_s)*
  -- if (styp_s = typ_s NO LCTK val_s)*
  ----
  -- if C_2 = $add_styps(GLOBAL, C_1, id_s*, styp_s*)
  ----
  -- if td = MonoD typ_s
  -- TypeDef_wf: $bound_tids(GLOBAL, C_0) |- td
  -- if C_3 = $add_typdef(GLOBAL, C_2, id, td)

;;
;; New type declaration
;;

rule Decl_ok/newtyped-type:
  GLOBAL C |- NewTypeD id (TypeD type) : C' (NewTypeD id (TypeD typ))
  -- Type_ok: GLOBAL C |- type : typ eps
  -- Type_wf: $bound_tids(GLOBAL, C) |- typ
  -- if typ_n = NewT id typ
  ----
  -- if td = MonoD typ_n
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  -- if C' = $add_typdef(GLOBAL, C, id, td)

rule Decl_ok/newtyped-decl-mono:
  GLOBAL C |- NewTypeD id (DeclD decl) : C'' (NewTypeD id (DeclD declIL))
  -- Decl_ok: GLOBAL C |- decl : C' declIL
  -- if `{ tid_n } = $diff_set<tid>(
                      $dom_map<tid, typdef>(C'.GLOBAL.TDENV),
                      $dom_map<tid, typdef>(C.GLOBAL.TDENV))
  -- if MonoD typ_n = $find_typdef(GLOBAL, C', CURRENT tid_n)
  ----
  -- if td = MonoD (NewT id typ_n)
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  -- if C'' = $add_typdef(GLOBAL, C, id, td)

rule Decl_ok/newtyped-decl-poly:
  GLOBAL C |- NewTypeD id (DeclD decl) : C'' (NewTypeD id (DeclD declIL))
  -- Decl_ok: GLOBAL C |- decl : C' declIL
  -- if `{ tid_n } = $diff_set<tid>(
                      $dom_map<tid, typdef>(C'.GLOBAL.TDENV),
                      $dom_map<tid, typdef>(C.GLOBAL.TDENV))
  -- if ptd = $find_typdef(GLOBAL, C', CURRENT tid_n)
  ----
  -- if td = MonoD (NewT id (SpecT ptd eps))
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  -- if C'' = $add_typdef(GLOBAL, C, id, td)

;;
;; Typedef declaration
;;

rule Decl_ok/typedefd:
  GLOBAL C |- TypeDefD id (TypeD type) : C' (TypeDefD id (TypeD typ))
  -- Type_ok: GLOBAL C |- type : typ eps
  -- Type_wf: $bound_tids(GLOBAL, C) |- typ
  -- if typ_d = DefT typ
  ----
  -- if td = MonoD typ_d
  -- if tidset = $bound_tids(GLOBAL, C)
  -- TypeDef_wf: tidset |- td
  -- if C' = $add_typdef(GLOBAL, C, id, td)

rule Decl_ok/typedefd-decl-mono:
  GLOBAL C |- TypeDefD id (DeclD decl) : C'' (TypeDefD id (DeclD declIL))
  -- Decl_ok: GLOBAL C |- decl : C' declIL
  -- if `{ tid_d } = $diff_set<tid>(
                      $dom_map<tid, typdef>(C'.GLOBAL.TDENV),
                      $dom_map<tid, typdef>(C.GLOBAL.TDENV))
  -- if MonoD typ_d = $find_typdef(GLOBAL, C', CURRENT tid_d)
  ----
  -- if td = MonoD (DefT typ_d)
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  -- if C'' = $add_typdef(GLOBAL, C, id, td)

rule Decl_ok/newtyped-decl-poly:
  GLOBAL C |- TypeDefD id (DeclD decl) : C'' (TypeDefD id (DeclD declIL))
  -- Decl_ok: GLOBAL C |- decl : C' declIL
  -- if `{ tid_d } = $diff_set<tid>(
                      $dom_map<tid, typdef>(C'.GLOBAL.TDENV),
                      $dom_map<tid, typdef>(C.GLOBAL.TDENV))
  -- if ptd = $find_typdef(GLOBAL, C', CURRENT tid_d)
  ----
  -- if td = MonoD (DefT (SpecT ptd eps))
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  -- if C'' = $add_typdef(GLOBAL, C, id, td)

;;
;; Action declaration
;;

rule Decl_ok/actiond:
  p C_0 |- ActionD id param* block : C_4 (ActionD id paramIL* blockIL)
  -- if p = GLOBAL \/ (p = BLOCK /\ C_0.BLOCK.KIND = CONTROL)
  ----
  -- if fid = $to_fid(id, param*)
  ----
  -- if C_1 = $set_localkind(C_0, ACTION)
  ----
  -- (Param_ok: LOCAL C_1 |- param : paramIL eps)*
  ----
  -- if C_2 = $add_params(LOCAL, C_1, paramIL*)
  ----
  -- Block_ok: LOCAL C_2 CONT INIT |- block : _ _ blockIL
  ----
  -- if fd = MonoFD (ActionT paramIL*)
  ----
  -- FuncDef_wf: $bound_tids(p, C_0) |- fd
  ----
  -- if C_4 = $add_funcdef_non_overload(p, C_0, fid, fd)

;;
;; Function declaration
;;

rule Decl_ok/funcd:
  GLOBAL C_0 |- FuncD id type_r tparam* param* block : C_5 (FuncD id typ_r tparam* tparam_hidden* paramIL* blockIL)
  -- if fid = $to_fid(id, param*)
  ----
  -- if C_1 = $add_typdefs(LOCAL, C_0, tparam*, (MonoD (VarT tparam))*)
  -- Type_ok: LOCAL C_1 |- type_r : typ_r eps
  ----
  -- if C_2 = $set_localkind(C_1, FUNC typ_r)
  ----
  -- (Param_ok: LOCAL C_2 |- param : paramIL tid_fresh_p*)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_p**)
  ----
  -- if C_3 = $add_params(LOCAL, C_2, paramIL*)
  ----
  -- Block_ok: LOCAL C_3 CONT INIT |- block : C_4 f blockIL
  -- if f = RET \/ (f = CONT /\ typ_r = VoidT)
  ----
  -- if fd = PolyFD (tparam*, tparam_hidden*) -> (FuncT paramIL* typ_r)
  ----
  -- FuncDef_wf: $bound_tids(GLOBAL, C_0) |- fd
  ----
  -- if C_5 = $add_funcdef(GLOBAL, C_0, fid, fd)

;;
;; Extern function declaration
;;

rule Decl_ok/externfuncd:
  GLOBAL C_0 |- ExternFuncD id type_r tparam* param* : C_4 (ExternFuncD id typ_r tparam* tparam_hidden* paramIL*)
  -- if fid = $to_fid(id, param*)
  ----
  -- if C_1 = $add_typdefs(LOCAL, C_0, tparam*, (MonoD (VarT tparam))*)
  -- Type_ok: LOCAL C_1 |- type_r : typ_r eps
  ----
  -- if C_2 = $set_localkind(C_1, EXTERNFUNC)
  ----
  -- (Param_ok: LOCAL C_2 |- param : paramIL tid_fresh_p*)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_p**)
  ----
  -- if C_3 = $add_params(LOCAL, C_2, paramIL*)
  ----
  -- if fd = PolyFD (tparam*, tparam_hidden*) -> (ExternFuncT paramIL* typ_r)
  ----
  -- FuncDef_wf: $bound_tids(GLOBAL, C_0) |- fd
  ----
  -- if C_4 = $add_funcdef(GLOBAL, C_0, fid, fd)

;;
;; Extern object declaration
;;

dec $split_methods(method*) : (method*, method*)

def $split_methods(eps) = (eps, eps)
def $split_methods(method_h :: method_t*) = (method_h :: method_c*, method_m*)
  -- if method_h = ExternConsM _ _
  -- if (method_c*, method_m*) = $split_methods(method_t*)
def $split_methods(method_h :: method_t*) = (method_c*, method_h :: method_m*)
  -- if method_h = ExternM _ _ _ _
  -- if (method_c*, method_m*) = $split_methods(method_t*)
def $split_methods(method_h :: method_t*) = (method_c*, method_h :: method_m*)
  -- if method_h = ExternAbstractM _ _ _ _
  -- if (method_c*, method_m*) = $split_methods(method_t*)


relation Method_ok:
  context id |- method : context methodIL
  hint(input %0 %1 %2)

rule Method_ok/externconsm:
  C id_e |- ExternConsM id_e cparam* : C' (ExternConsM id_e tparam_hidden* cparamIL*)
  -- if cid = $to_fid(id_e, cparam*)
  ----
  -- (CParam_ok: BLOCK C |- cparam : cparamIL tid_fresh_c*)*
  -- if (id_c dir_c typ_c val_c? = cparamIL)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_c**)
  ----
  -- if PolyD (tparam_e*, eps) -> typ_e = $find_typdef(GLOBAL, C, CURRENT id_e)
  -- if typ = SpecT (PolyD (tparam_e*, eps) -> typ_e) (VarT tparam_e)*
  -- if cd = ConsD (tparam_e*, tparam_hidden*) -> (ConsT (id_c dir_c typ_c val_c?)* typ)
  ----
  -- ConsDef_wf: $bound_tids(BLOCK, C) |- cd
  ----
  -- if C' = $add_consdef(GLOBAL, C, cid, cd)

rule Method_ok/externabstractm:
  C_0 id_e |- ExternAbstractM id type_r tparam* param* : C_4 (ExternAbstractM id typ_r tparam* tparam_hidden* paramIL*)
  -- if id_e =/= id
  -- if fid = $to_fid(id, param*)
  ----
  -- if C_1 = $add_typdefs(LOCAL, C_0, tparam*, (MonoD (VarT tparam))*)
  ----
  -- Type_ok: LOCAL C_1 |- type_r : typ_r eps
  ----
  -- if C_2 = $set_localkind(C_1, EXTERNABSTRACTMETHOD typ_r)
  ----
  -- (Param_ok: LOCAL C_2 |- param : paramIL tid_fresh_p*)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_p**)
  ----
  -- if C_3 = $add_params(LOCAL, C_2, paramIL*)
  ----
  -- if fd = PolyFD (tparam*, tparam_hidden*) -> (ExternAbstractMethodT paramIL* typ_r)
  ----
  -- FuncDef_wf: $bound_tids(BLOCK, C_0) |- fd
  ----
  -- if C_4 = $add_funcdef(BLOCK, C_0, fid, fd)

rule Method_ok/externm:
  C_0 id_e |- ExternM id type_r tparam* param* : C_4 (ExternM id typ_r tparam* tparam_hidden* paramIL*)
  -- if id_e =/= id
  -- if fid = $to_fid(id, param*)
  ----
  -- if C_1 = $add_typdefs(LOCAL, C_0, tparam*, (MonoD (VarT tparam))*)
  ----
  -- Type_ok: LOCAL C_1 |- type_r : typ_r eps
  ----
  -- if C_2 = $set_localkind(C_1, EXTERNMETHOD)
  ----
  -- (Param_ok: LOCAL C_2 |- param : paramIL tid_fresh_p*)*
  -- if (id_p dir_p typ_p val_p? = paramIL)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_p**)
  ----
  -- if C_3 = $add_params(LOCAL, C_2, paramIL*)
  ----
  -- if fd = PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT paramIL* typ_r)
  ----
  -- FuncDef_wf: $bound_tids(BLOCK, C_0) |- fd
  ----
  -- if C_4 = $add_funcdef(BLOCK, C_0, fid, fd)


relation Methods_ok:
  context id |- method* : context methodIL*
  hint(input %0 %1 %2)

rule Methods_ok/nil:
  C id_e |- eps : C eps

rule Methods_ok/cons:
  C id_e |- method_h :: method_t* : C'' (methodIL_h :: methodIL_t*)
  -- Method_ok: C id_e |- method_h : C' methodIL_h
  -- Methods_ok: C' id_e |- method_t* : C'' methodIL_t*


rule Decl_ok/externobjectd:
  GLOBAL C_0 |- ExternObjectD id tparam* method* : C_8 (ExternObjectD id tparam* (methodIL_c* ++ methodIL_m*))
  ----
  -- if (method_c*, method_m*) = $split_methods(method*)
  ----
  -- if C_1 = $set_blockkind(C_0, EXTERN)
  -- if C_2 = $add_typdefs(BLOCK, C_1, tparam*, (MonoD (VarT tparam))*)
  ----
  -- Methods_ok: C_2 id |- method_m* : C_3 methodIL_m*
  ----
  -- if td = PolyD (tparam*, eps) -> (ExternT id C_3.BLOCK.FDENV)
  -- if C_4 = $add_typdef(GLOBAL, C_0, id, td)
  ----
  -- if C_5 = $set_blockkind(C_4, EXTERN)
  -- if C_6 = $add_typdefs(BLOCK, C_5, tparam*, (MonoD (VarT tparam))*)
  ----
  -- Methods_ok: C_6 id |- method_c* : C_7 methodIL_c*
  ----
  -- if C_8 = C_4[.GLOBAL.CDENV = C_7.GLOBAL.CDENV]

;;
;; Value set declaration
;;

rule Decl_ok/valuesetd:
  p C |- ValueSetD id type expr : C' (ValueSetD id typ exprIL)
  -- if p = GLOBAL \/ (p = BLOCK /\ C.BLOCK.KIND = PARSER)
  ----
  -- Type_ok: p C |- type : typ_s eps
  -- Type_wf: $bound_tids(p, C) |- SetT typ_s
  ----
  -- Expr_ok: p C |- expr : exprIL
  -- if `(typ; ctk) = $annot(exprIL)
  -- if ctk = CTK \/ ctk = LCTK
  ----
  -- if C' = $add_styp(p, C, id, (SetT typ_s) NO CTK eps)

;;
;; Parser type declaration
;;

rule Decl_ok/parsertyped:
  GLOBAL C_0 |- ParserTypeD id tparam* param* : C_3 (ParserTypeD id tparam* tparam_hidden* paramIL*)
  -- if C_1 = $set_blockkind(C_0, PARSER)
  ----
  -- if C_2 = $add_typdefs(BLOCK, C_1, tparam*, (MonoD (VarT tparam))*)
  ----
  -- (Param_ok: LOCAL C_2 |- param : paramIL tid_fresh_p*)*
  -- if (id_p dir_p typ_p val_p? = paramIL)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_p**)
  ----
  -- if td = PolyD (tparam*, tparam_hidden*) -> (ParserT (id_p dir_p typ_p val_p?)*)
  -- TypeDef_wf: $bound_tids(GLOBAL, C_0) |- td
  -- if C_3 = $add_typdef(GLOBAL, C_0, id, td)

;;
;; Parser declaration
;;

relation ParserState_ok:
  context |- parserstate : parserstateIL
  hint(input %0 %1)

rule ParserState_ok:
  C |- statelabel block : statelabel blockIL
  -- Block_ok: LOCAL C CONT INIT |- block : C' CONT blockIL


rule Decl_ok/parserd:
  GLOBAL C_0 |- ParserD id param* cparam* decl* parserstate* : C_8 (ParserD id paramIL* cparamIL* declIL* parserstateIL*)
  -- if cid = $to_fid(id, cparam*)
  ----
  -- if C_1 = $set_blockkind(C_0, PARSER)
  ----
  -- (Param_ok: LOCAL C_1 |- cparam : cparamIL eps)*
  ----
  -- if C_2 = $add_params(BLOCK, C_1, cparamIL*)
  ----
  -- (Param_ok: LOCAL C_2 |- param : paramIL eps)*
  ----
  ----
  -- if funcdef_apply = MonoFD (ParserApplyMethodT paramIL*)
  -- FuncDef_wf: $bound_tids(GLOBAL, C_0) |- funcdef_apply
  ----
  -- if C_3 = $add_params(BLOCK, C_2, paramIL*)
  ----
  -- Decls_ok: BLOCK C_3 |- decl* : C_4 declIL*
  ----
  -- if (statelabel block = parserstate)*
  ----
  -- if $distinct_<statelabel>(statelabel*)
  -- if "start" <- statelabel*
  -- if ~("accept" <- statelabel*)
  -- if ~("reject " <- statelabel*)
  -- if statelabel'* = "accept" :: "reject" :: statelabel*
  ----
  -- if C_5 = $set_localkind(C_4, PARSERSTATE)
  ----
  ;; (TODO) ^n iterator would be better
  -- if styp* = $repeat_<styp>(StateT NO DYN eps, |statelabel'*|)
  -- if C_6 = $add_styps(BLOCK, C_5, statelabel'*, styp*)
  ----
  -- (ParserState_ok: C_6 |- parserstate : parserstateIL)*
  ----
  -- if ptd = PolyD (eps, eps) -> (ParserT paramIL*)
  -- if typ = SpecT ptd eps
  -- if cd = ConsD (eps, eps) -> (ConsT cparamIL* typ)
  ----
  -- ConsDef_wf: $bound_tids(GLOBAL, C_0) |- cd
  ----
  -- if C_8 = $add_consdef(GLOBAL, C_0, cid, cd)

;;
;; Table declaration
;;

;;
;; Table key check
;;

relation Table_key_ok:
  cursor context tblctx |- tblkey : tblctx tblkeyIL
  hint(input %0 %1 %2 %3)

dec $check_table_key(matchkind, typ) : bool
    ;;hint(show CHECK_TABLE_KEY(%1, %2))

def $check_table_key(matchkind, typ) = true
  -- if matchkind = "exact" \/ matchkind = "optional"
  -- if typ' = $canon_typ(typ)
  -- if $is_errt(typ') \/ $is_boolt(typ')
      \/ $is_intt(typ') \/ $is_fintt(typ')
      \/ $is_fbitt(typ') \/ $is_vbitt(typ')
      \/ $is_enumt(typ')

def $check_table_key(matchkind, typ) = $check_table_key(matchkind, typ')
  -- if matchkind = "exact" \/ matchkind = "optional"
  -- if SEnumT _ typ' _ = $canon_typ(typ)

def $check_table_key(matchkind, typ) = $check_table_key(matchkind, typ')
  -- if matchkind = "exact" \/ matchkind = "optional"
  -- if NewT _ typ' = $canon_typ(typ)

def $check_table_key(matchkind, typ) = true
  -- if matchkind = "lpm" \/ matchkind = "ternary" \/ matchkind = "range"
  -- if typ' = $canon_typ(typ)
  -- if $is_intt(typ') \/ $is_fintt(typ') \/ $is_fbitt(typ')

def $check_table_key(matchkind, typ) = $check_table_key(matchkind, typ')
  -- if matchkind = "lpm" \/ matchkind = "ternary" \/ matchkind = "range"
  -- if SEnumT _ typ' _ = $canon_typ(typ)

def $check_table_key(matchkind, typ) = $check_table_key(matchkind, typ')
  -- if matchkind = "lpm" \/ matchkind = "ternary" \/ matchkind = "range"
  -- if NewT _ typ' = $canon_typ(typ)

def $check_table_key(matchkind, typ) = false
  -- otherwise

rule Table_key_ok:
  p C tblctx |- (expr matchkind) : tblctx'' (exprIL matchkind)
  -- Expr_ok: p C |- expr : exprIL
  -- if `(typ; _) = $annot(exprIL)
  ----
  -- Type_wf: $bound_tids(p, C) |- SetT typ
  ----
  -- if (MatchKindV matchkind) = $find_val(p, C, CURRENT matchkind)
  ----
  -- if $check_table_key(matchkind, typ)
  -- if tblctx' = $update_mode(matchkind, typ, tblctx)
  ----
  -- if tblctx'' = $add_key((typ, matchkind), tblctx')


relation Table_keys_ok:
  cursor context tblctx |- tblkeyprop : tblctx tblkeypropIL
  hint(input %0 %1 %2 %3)

rule Table_keys_ok/nil:
  p C tblctx |- eps : tblctx eps

rule Table_keys_ok/cons:
  p C tblctx |- (tblkey_h :: tblkey_t*) : tblctx'' (tblkeyIL_h :: tblkeyIL_t*)
  -- Table_key_ok: p C tblctx |- tblkey_h : tblctx' tblkeyIL_h
  -- Table_keys_ok: p C tblctx' |- tblkey_t* : tblctx'' tblkeyIL_t*

;;
;; Table action check
;;

relation Call_action_partial_ok:
  cursor context |- paramtyp* (argIL, typ)* : paramIL* paramIL* argIL*
  hint(input %0 %1 %2 %3)

dec $split_directionless_params(paramIL*) : (paramIL*, paramIL*)
    hint(show SPLIT_DIRECTIONLESS_PARAMS(%1))

def $split_directionless_params(eps) = (eps, eps)
def $split_directionless_params(paramIL_h :: paramIL_t*) = (paramIL_d*, paramIL_h :: paramIL_c*)
  -- if _ NO _ _ = paramIL_h
  -- if (paramIL_d*, paramIL_c*) = $split_directionless_params(paramIL_t*)
def $split_directionless_params(paramIL_h :: paramIL_t*) = (paramIL_h :: paramIL_d*, paramIL_c*)
  -- if _ dir _ _ = paramIL_h
  -- if dir =/= NO
  -- if (paramIL_d*, paramIL_c*) = $split_directionless_params(paramIL_t*)

rule Call_action_partial_ok:
  p C |- pt* (argIL, typ_a)* : paramIL_d* paramIL_c* argIL'*
  -- if (paramIL_d*, paramIL_c*) = $split_directionless_params(pt*)
  ----
  -- if |paramIL_d*| = |argIL*|
  -- (Call_convention_arg_ok: p C ACT |- paramIL_d ~~ (argIL, typ_a) : argIL')*


relation Table_action_ok:
  cursor context tblctx |- tblaction : tblctx tblactionIL
  hint(input %0 %1 %2 %3)

rule Table_action_ok:
  p C tblctx |- (name arg*) : tblctx' (name argIL'* paramIL_d* paramIL_c*)
  -- (Arg_ok: p C |- arg : argIL typ_a)*
  ----
  -- if MonoFD (ActionT pt*) = $find_funcdef_by_name(p, C, name)
  ----
  -- Call_action_partial_ok: p C |- pt* (argIL, typ_a)* : paramIL_d* paramIL_c* argIL'*
  -- if tblctx' = $add_action((name, pt*, argIL*), tblctx)


relation Table_actions_ok:
  cursor context tblctx |- tblactionprop : tblctx tblactionpropIL
  hint(input %0 %1 %2 %3)

rule Table_actions_ok/nil:
  p C tblctx |- eps : tblctx eps

rule Table_actions_ok/cons:
  p C tblctx |- (tblaction_h :: tblaction_t*) : tblctx'' (tblactionIL_h :: tblactionIL_t*)
  -- Table_action_ok: p C tblctx |- tblaction_h : tblctx' tblactionIL_h
  -- Table_actions_ok: p C tblctx' |- tblaction_t* : tblctx'' tblactionIL_t*
  ----
  -- if tblactionIL* = tblactionIL_h :: tblactionIL_t*
  -- if (name argIL* paramIL_d* paramIL_c* = tblactionIL)*
  -- if $distinct_<name>(name*)

;;
;; Table entry check
;;

relation Table_entry_keyset_ok:
  cursor context tblctx |- key keyset : tblstate keysetIL
  hint(input %0 %1 %2 %3 %4)

rule Table_entry_keyset_ok/exprk-lpm-maske:
  p C tblctx |- (typ_k, "lpm") (ExprK (MaskE expr_b expr_m)) : tblstate_e (ExprK exprIL)
  -- Expr_ok: p C |- (MaskE expr_b expr_m) : exprIL
  -- if `(SetT typ; _) = $annot(exprIL)
  -- if exprIL = MaskE exprIL_b exprIL_m _
  ----
  -- if tblctx.MODE = NOPRILPM n_w
  ----
  -- Eval_static: p C |- exprIL_m ~> val_m
  -- if i_m = $get_num(val_m)
  ----
  -- if tblstate_e = $get_lpm_prefix(FBitV n_w $to_bitstr(n_w, i_m))
  -- Sub_impl: typ << typ_k

rule Table_entry_keyset_ok/exprk-lpm-else:
  p C tblctx |- (typ_k, "lpm") (ExprK expr) : (LPM n_w) (ExprK exprIL')
  -- if ~($is_maske(expr) \/ $is_rangee(expr))
  ----
  -- Expr_ok: p C |- expr : exprIL
  -- if `(typ; ctk) = $annot(exprIL)
  ----
  -- if tblctx.MODE = NOPRILPM n_w
  ----
  -- Sub_impl: typ << typ_k
  ----
  -- if exprIL' = CastE (SetT typ_k) exprIL `(SetT typ_k; ctk)

rule Table_entry_keyset_ok/exprk-ternary-maske:
  p C tblctx |- (typ_k, "ternary") (ExprK (MaskE expr_b expr_m)) : NOLPM (ExprK exprIL)
  -- Expr_ok: p C |- (MaskE expr_b expr_m) : exprIL
  -- if `(SetT typ; _) = $annot(exprIL)
  -- Sub_impl: typ << typ_k

rule Table_entry_keyset_ok/exprk-ternary-else:
  p C tblctx |- (typ_k, "ternary") (ExprK expr) : NOLPM (ExprK exprIL')
  -- if ~($is_maske(expr) \/ $is_rangee(expr))
  ----
  -- Expr_ok: p C |- expr : exprIL
  -- if `(typ; ctk) = $annot(exprIL)
  ----
  -- Sub_impl: typ << typ_k
  ----
  -- if exprIL' = CastE (SetT typ_k) exprIL `(SetT typ_k; ctk)

rule Table_entry_keyset_ok/exprk-range-rangee:
  p C tblctx |- (typ_k, "range") (ExprK (RangeE expr_l expr_r)) : NOLPM (ExprK exprIL)
  -- Expr_ok: p C |- (RangeE expr_l expr_r) : exprIL
  -- if `(SetT typ; _) = $annot(exprIL)
  -- Sub_impl: typ << typ_k

rule Table_entry_keyset_ok/exprk-range-else:
  p C tblctx |- (typ_k, "range") (ExprK expr) : NOLPM (ExprK exprIL')
  -- if ~($is_maske(expr) \/ $is_rangee(expr))
  ----
  -- Expr_ok: p C |- expr : exprIL
  -- if `(typ; ctk) = $annot(exprIL)
  ----
  -- Sub_impl: typ << typ_k
  ----
  -- if exprIL' = CastE (SetT typ_k) exprIL `(SetT typ_k; ctk)

rule Table_entry_keyset_ok/exprk-else:
  p C tblctx |- (typ_k, matchkind) (ExprK expr) : NOLPM (ExprK exprIL')
  -- if matchkind =/= "lpm" /\ matchkind =/= "ternary" /\ matchkind =/= "range"
  -- if ~($is_maske(expr) \/ $is_rangee(expr))
  ----
  -- Expr_ok: p C |- expr : exprIL
  -- if `(typ; ctk) = $annot(exprIL)
  ----
  -- Sub_impl: typ << typ_k
  ----
  -- if exprIL' = CastE (SetT typ_k) exprIL `(SetT typ_k; ctk)

rule Table_entry_keyset_ok/defaultk-lpm:
  p C tblctx |- (typ_k, "lpm") DefaultK : (LPM n_w) DefaultK
  -- if tblctx.MODE = NOPRILPM n_w

rule Table_entry_keyset_ok/defaultk-else:
  p C tblctx |- (typ_k, matchkind) DefaultK : NOLPM DefaultK
  -- if matchkind =/= "exact"

rule Table_entry_keyset_ok/anyk-lpm:
  p C tblctx |- (typ_k, "lpm") AnyK : (LPM 0) AnyK
  -- if tblctx.MODE = NOPRILPM _ 

rule Table_entry_keyset_ok/defaultk-else:
  p C tblctx |- (typ_k, matchkind) AnyK : NOLPM AnyK
  -- if matchkind =/= "exact"


relation Table_entry_keysets_state_ok:
  cursor context tblctx tblstate |- key* keyset* : tblstate keysetIL*
  hint(input %0 %1 %2 %3 %4 %5)

rule Table_entry_keysets_state_ok/nil:
  p C tblctx tblstate |- eps eps : tblstate eps

rule Table_entry_keysets_state_ok/cons:
  p C tblctx tblstate_0 |- (key_h :: key_t*) (keyset_h :: keyset_t*) : tblstate_3 (keysetIL_h :: keysetIL_t*)
  -- Table_entry_keyset_ok: p C tblctx |- key_h keyset_h : tblstate_1 keysetIL_h
  -- if tblstate_2 = $update_state(tblstate_0, tblstate_1)
  -- Table_entry_keysets_state_ok: p C tblctx tblstate_2 |- key_t* keyset_t* : tblstate_3 keysetIL_t*


relation Table_entry_keysets_ok:
  cursor context tblctx |- keyset* : tblstate keysetIL*
  hint(input %0 %1 %2 %3)

rule Table_entry_keysets_ok/noprilpm-defaultk:
  p C tblctx |- DefaultK : (LPM nat) DefaultK
  -- if tblctx.MODE = NOPRILPM nat

rule Table_entry_keysets_ok/else-defaultk:
  p C tblctx |- DefaultK : NOLPM DefaultK
  -- if tblctx.MODE = NOPRI \/ tblctx.MODE = PRI \/ tblctx.MODE = PRILPM

rule Table_entry_keysets_ok/noprilpm-anyk:
  p C tblctx |- AnyK : (LPM 0) AnyK
  -- if tblctx.MODE = NOPRILPM nat

rule Table_entry_keysets_ok/else-anyk:
  p C tblctx |- AnyK : NOLPM AnyK
  -- if tblctx.MODE = NOPRI \/ tblctx.MODE = PRI \/ tblctx.MODE = PRILPM

rule Table_entry_keysets_ok/others:
  p C tblctx |- keyset* : tblstate keysetIL*
  -- if |tblctx.KEYS| = |keyset*|
  -- Table_entry_keysets_state_ok: p C tblctx NOLPM |- tblctx.KEYS keyset* : tblstate keysetIL*


relation Call_default_action_ok:
  cursor context |- paramtyp* (argIL, typ)* argIL* : argIL*
  hint(input %0 %1 %2 %3 %4)

dec $filter_directionless_args(paramtyp*, argIL*) : argIL*
    ;;hint(show FILTER_DIRECTIONLESS_ARGS(%1, %2))

def $filter_directionless_args(eps, eps) = eps
def $filter_directionless_args(pt_h :: pt_t*, argIL_h :: argIL_t*) = $filter_directionless_args(pt_t*, argIL_t*)
  -- if id NO typ val? = pt_h
def $filter_directionless_args(pt_h :: pt_t*, argIL_h :: argIL_t*) = argIL_h :: $filter_directionless_args(pt_t*, argIL_t*)
  -- otherwise

rule Call_default_action_ok:
  p C |- pt* (argIL, typ)* argIL_a* : argIL'*
  -- if |pt*| = |argIL*|
  -- if argIL_d* = $filter_directionless_args(pt*, argIL*)
  ----
  -- if (argIL_a = argIL_d)*
  -- (Call_convention_arg_ok: p C ACT |- pt ~~ (argIL, typ) : argIL')*


relation Table_entry_action_ok:
  cursor context tblctx |- tblaction : tblactionIL
  hint(input %0 %1 %2 %3)

rule Table_entry_action_ok:
  p C tblctx |- (name arg*) : tblactionIL
  -- if (pt*, argIL_a*) = $find_action(tblctx, name)
  ----
  -- (Arg_ok: p C |- arg : argIL typ_arg)*
  ----
  -- Call_default_action_ok: p C |- pt* (argIL, typ_arg)* argIL_a* : argIL'*
  ----
  -- if tblactionIL = name argIL'* pt* eps


relation Table_entry_priority_ok:
  cursor context tblctx tblstate |- expr? : tblctx val?
  hint(input %0 %1 %2 %3 %4)

rule Table_entry_priority_ok/nopri:
  LOCAL C tblctx tblstate |- eps : tblctx eps
  -- if tblctx.MODE = NOPRI

rule Table_entry_priority_ok/noprilpm:
  LOCAL C tblctx (LPM nat_prefix) |- eps : tblctx eps
  -- if tblctx.MODE = NOPRILPM nat

rule Table_entry_priority_ok/priority-values-nil-somep:
  LOCAL C tblctx tblstate |- expr : tblctx'' (IntV i)
  -- if tblctx.MODE = PRI \/ tblctx.MODE = PRILPM
  -- if ~tblctx.ENTRIES.CONST
  -- if tblctx.PRIORITIES.VALUES = eps
  ----
  -- Expr_ok: LOCAL C |- expr : exprIL
  -- Eval_static: LOCAL C |- exprIL ~> val
  ----
  -- if i = $get_num(val)
  -- if $(i >= 0)
  ----
  -- if tblctx' = tblctx[ .PRIORITIES.INIT = true ]
  -- if tblctx'' = $add_priority(i, tblctx')

rule Table_entry_priority_ok/priority-values-nil-none-lw:
  LOCAL C tblctx tblstate |- eps : tblctx' (IntV i)
  -- if tblctx.MODE = PRI \/ tblctx.MODE = PRILPM
  -- if tblctx.PRIORITIES.VALUES = eps
  -- if tblctx.PRIORITIES.LARGEST_WINS
  ----
  -- if i_size = tblctx.ENTRIES.SIZE
  -- if i_delta = tblctx.PRIORITIES.DELTA
  ----
  -- if i = $((i_size - 1) * i_delta + 1)
  -- if $(i >= 0)
  ----
  -- if tblctx' = $add_priority(i, tblctx)

rule Table_entry_priority_ok/priority-values-nil-none-no-lw:
  LOCAL C tblctx tblstate |- eps : tblctx' (IntV 1)
  -- if tblctx.MODE = PRI \/ tblctx.MODE = PRILPM
  -- if tblctx.PRIORITIES.VALUES = eps
  -- if ~tblctx.PRIORITIES.LARGEST_WINS
  ----
  -- if tblctx' = $add_priority(1, tblctx)

rule Table_entry_priority_ok/else-somep:
  LOCAL C tblctx tblstate |- expr : tblctx' (IntV i)
  -- if tblctx.MODE = PRI \/ tblctx.MODE = PRILPM
  -- if ~tblctx.ENTRIES.CONST
  -- if tblctx.PRIORITIES.VALUES =/= eps
  -- if tblctx.PRIORITIES.INIT
  ----
  -- Expr_ok: LOCAL C |- expr : exprIL
  -- Eval_static: LOCAL C |- exprIL ~> val
  ----
  -- if i = $get_num(val)
  -- if $(i >= 0)
  ----
  -- if tblctx' = $add_priority(i, tblctx)

rule Table_entry_priority_ok/else-none-lw:
  LOCAL C tblctx tblstate |- eps : tblctx' (IntV i')
  -- if tblctx.MODE = PRI \/ tblctx.MODE = PRILPM
  -- if tblctx.PRIORITIES.VALUES =/= eps
  ----
  -- if i_delta = tblctx.PRIORITIES.DELTA
  -- if i = $find_last_priority(tblctx)
  ----
  -- if tblctx.PRIORITIES.LARGEST_WINS
  -- if i' = $(i - i_delta)
  ----
  -- if $(i' >= 0)
  -- if tblctx' = $add_priority(i', tblctx)

rule Table_entry_priority_ok/else-none-no-lw:
  LOCAL C tblctx tblstate |- eps : tblctx' (IntV i')
  -- if tblctx.MODE = PRI \/ tblctx.MODE = PRILPM
  -- if tblctx.PRIORITIES.VALUES =/= eps
  ----
  -- if i_delta = tblctx.PRIORITIES.DELTA
  -- if i = $find_last_priority(tblctx)
  ----
  -- if ~tblctx.PRIORITIES.LARGEST_WINS
  -- if i' = $(i + i_delta)
  ----
  -- if $(i' >= 0)
  -- if tblctx' = $add_priority(i', tblctx)


relation Table_entry_ok:
  cursor context tblctx |- tblentry : tblctx tblentryIL
  hint(input %0 %1 %2 %3)

rule Table_entry_ok:
  p C tblctx |- (bool keyset* tblaction expr?) : tblctx' (bool keysetIL* tblactionIL val?)
  -- Table_entry_keysets_ok: p C tblctx |- keyset* : tblstate keysetIL*
  ----
  -- Table_entry_action_ok: p C tblctx |- tblaction : tblactionIL
  ----
  -- Table_entry_priority_ok: p C tblctx tblstate |- expr? : tblctx' val?


relation Table_entries_fold_ok:
  cursor context tblctx |- tblentry* : tblctx tblentryIL*
  hint(input %0 %1 %2 %3)

rule Table_entries_fold_ok/nil:
  p C tblctx |- eps : tblctx eps

rule Table_entries_fold_ok/cons:
  p C tblctx |- tblentry_h :: tblentry_t* : tblctx'' (tblentryIL_h :: tblentryIL_t*)
  -- Table_entry_ok: p C tblctx |- tblentry_h : tblctx' tblentryIL_h
  -- Table_entries_fold_ok: p C tblctx' |- tblentry_t* : tblctx'' tblentryIL_t*


relation Table_entries_ok:
  cursor context tblctx |- tblentryprop : tblctx tblentrypropIL
  hint(input %0 %1 %2 %3)

rule Table_entries_ok:
  p C tblctx_0 |- (b tblentry*) : tblctx_3 (b tblentryIL*)
  -- if (|tblctx_0.KEYS| = 0) => (|tblentry*| = 0)
  -- if tblctx_1 = tblctx_0[ .ENTRIES.SIZE = |tblentry*| ]
  ----
  -- if tblctx_2 = tblctx_1[ .ENTRIES.CONST = b ]
  ----
  -- Table_entries_fold_ok: p C tblctx_2 |- tblentry* : tblctx_3 tblentryIL*

;;
;; Table default action check
;;

relation Table_default_ok:
  cursor context tblctx |- tbldefaultprop : tbldefaultpropIL
  hint(input %0 %1 %2 %3)

rule Table_default_ok:
  p C tblctx |- bool (name arg*) : bool tblactionIL
  -- if (pt*, argIL_a*) = $find_action(tblctx, name)
  ----
  -- (Arg_ok: p C |- arg : argIL typ_a)*
  ----
  -- Call_default_action_ok: p C |- pt* (argIL, typ_a)* argIL_a* : argIL'*
  ----
  -- if tblactionIL = name argIL'* pt* eps

;;
;; Table custom property check
;;

relation Table_custom_ok:
  cursor context tblctx |- tblcustomprop : tblctx tblcustompropIL
  hint(input %0 %1 %2 %3)

rule Table_custom_ok/size:
  p C tblctx |- (b "size" expr) : tblctx (b "size" exprIL)
  -- Expr_ok: p C |- expr : exprIL
  -- if `(typ; _) = $annot(exprIL)
  -- if $is_intt(typ) \/ $is_fintt(typ) \/ $is_fbitt(typ)

rule Table_custom_ok/largest_priority_wins:
  p C tblctx |- (b "largest_priority_wins" expr) : tblctx' (b "largest_priority_wins" exprIL)
  -- Expr_ok: p C |- expr : exprIL
  -- if `(BoolT; _) = $annot(exprIL)
  ----
  -- Eval_static: p C |- exprIL ~> (BoolV b_lw)
  -- if tblctx' = tblctx[ .PRIORITIES.LARGEST_WINS = b_lw ]

rule Table_custom_ok/priority_delta:
  p C tblctx |- (b "priority_delta" expr) : tblctx' (b "priority_delta" exprIL)
  -- Expr_ok: p C |- expr : exprIL
  -- if `(typ; _) = $annot(exprIL)
  -- if $is_intt(typ) \/ $is_fintt(typ) \/ $is_fbitt(typ)
  ----
  -- Eval_static: p C |- exprIL ~> val
  ----
  -- if i_delta = $get_num(val)
  -- if $(i_delta > 0)
  -- if tblctx' = tblctx[ .PRIORITIES.DELTA = i_delta ]

rule Table_custom_ok/unknown:
  p C tblctx |- (b member expr) : tblctx (b member exprIL)
  -- if member =/= "size" /\ member =/= "largest_priority_wins" /\ member =/= "priority_delta"
  ----
  -- Expr_ok: p C |- expr : exprIL


relation Table_prop_ok:
  cursor context tblctx |- tblprop : tblctx tblpropIL
  hint(input %0 %1 %2 %3)

rule Table_prop_ok/keyp:
  p C tblctx |- (KeyP tblkeyprop) : tblctx' (KeyP tblkeypropIL)
  -- Table_keys_ok: p C tblctx |- tblkeyprop : tblctx' tblkeypropIL

rule Table_prop_ok/actionp:
  p C tblctx |- (ActionP tblactionprop) : tblctx' (ActionP tblactionpropIL)
  -- Table_actions_ok: p C tblctx |- tblactionprop : tblctx' tblactionpropIL

rule Table_prop_ok/entryp:
  p C tblctx |- (EntryP tblentryprop) : tblctx' (EntryP tblentrypropIL)
  -- Table_entries_ok: p C tblctx |- tblentryprop : tblctx' tblentrypropIL

rule Table_prop_ok/defaultp:
  p C tblctx |- (DefaultP tbldefaultprop) : tblctx (DefaultP tbldefaultpropIL)
  -- Table_default_ok: p C tblctx |- tbldefaultprop : tbldefaultpropIL

rule Table_prop_ok/customp:
  p C tblctx |- (CustomP tblcustomprop) : tblctx' (CustomP tblcustompropIL)
  -- Table_custom_ok: p C tblctx |- tblcustomprop : tblctx' tblcustompropIL


relation Table_props_ok:
  cursor context tblctx |- tbl : tblctx tblIL
  hint(input %0 %1 %2 %3)

rule Table_props_ok/nil:
  p C tblctx |- eps : tblctx eps

rule Table_props_ok/cons:
  p C tblctx |- (tblprop_h :: tblprop_t*) : tblctx'' (tblpropIL_h :: tblpropIL_t*)
  -- Table_prop_ok: p C tblctx |- tblprop_h : tblctx' tblpropIL_h
  -- Table_props_ok: p C tblctx' |- tblprop_t* : tblctx'' tblpropIL_t*

;;
;; Table synthesized type check
;;

relation Table_type_decl_ok:
  cursor context tblctx |- id : context typ
  hint(input %0 %1 %2 %3)

rule Table_type_decl_ok:
  BLOCK C tblctx |- id : C' typ_s
  -- if id_e = $concat_text([ "action_list(", id, ")" ])
  -- if (name, pt*, argIL*)* = tblctx.ACTIONS
  ----
  -- if (member = $string_of_name(name))*
  -- if typ_e = TableEnumT id_e member*
  ----
  -- if (val_e = TableEnumFieldV id_e member)*
  -- if (id_f = $concat_text([ id_e, ".", member ]))*
  ----
  -- if C' = $add_styps(BLOCK, C, id_f*, (typ_e NO LCTK val_e)*)
  ----
  -- if id_s = $concat_text([ "apply_result(", id, ")" ])
  ----
  -- if typ_s = TableStructT id_s ([ ("hit", BoolT), ("miss", BoolT), ("action_run", typ_e) ])


rule Decl_ok/tabled:
  BLOCK C_0 |- TableD id tbl : C_3 (TableD id typ tblIL)
  -- if C_0.BLOCK.KIND = CONTROL
  ----
  -- if |$keys_of_table(tbl)| <= 1
  -- if |$actions_of_table(tbl)| = 1
  ----
  -- if C_1 = $set_localkind(C_0, TABLEAPPLYMETHOD)
  -- Table_props_ok: LOCAL C_1 $empty_tblctx() |- tbl : tblctx' tblIL
  ----
  -- Table_type_decl_ok: BLOCK C_1 tblctx' |- id : C_2 typ_tbl
  -- if typ = TableT id typ_tbl
  ----
  -- Type_wf: $bound_tids(BLOCK, C_2) |- typ
  ----
  -- if C_3 = $add_styp(BLOCK, C_2, id, typ NO DYN eps)

;;
;; Control type declaration
;;

rule Decl_ok/controltyped:
  GLOBAL C |- ControlTypeD id tparam* param* : C''' (ControlTypeD id tparam* tparam_hidden* paramIL*)
  -- if C' = $add_typdefs(BLOCK, C, tparam*, (MonoD (VarT tparam))*)
  ----
  -- if C'' = $set_blockkind(C, CONTROL)
  ----
  -- (Param_ok: LOCAL C' |- param : paramIL tid_fresh_p*)*
  -- if (id_p dir_p typ_p val_p? = paramIL)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_p**)
  ----
  -- if td = PolyD (tparam*, tparam_hidden*) -> (ControlT (id_p dir_p typ_p val_p?)*)
  -- TypeDef_wf: $bound_tids(GLOBAL, C) |- td
  -- if C''' = $add_typdef(GLOBAL, C, id, td)

;;
;; Control declaration
;;

rule Decl_ok/controld:
  GLOBAL C_0 |- ControlD id param* cparam* decl* block : C_7 (ControlD id paramIL* cparamIL* declIL* blockIL)
  -- if cid = $to_fid(id, cparam*)
  ----
  -- if C_1 = $set_blockkind(C_0, CONTROL)
  ----
  -- (Param_ok: LOCAL C_1 |- cparam : cparamIL eps)*
  ----
  -- if C_2 = $add_params(BLOCK, C_1, cparamIL*)
  ----
  -- (Param_ok: LOCAL C_2 |- param : paramIL eps)*
  ----
  -- if funcdef_apply = MonoFD (ControlApplyMethodT paramIL*)
  -- FuncDef_wf: $bound_tids(GLOBAL, C_0) |- funcdef_apply
  ----
  -- if C_3 = $add_params(BLOCK, C_2, paramIL*)
  ----
  -- Decls_ok: BLOCK C_3 |- decl* : C_4 declIL*
  ----
  -- if C_5 = $set_localkind(C_4, CONTROLAPPLYMETHOD)
  ----
  -- Block_ok: LOCAL C_5 CONT INIT |- block : C_6 f blockIL
  ----
  -- if ptd = PolyD (eps, eps) -> (ControlT paramIL*)
  -- if typ = SpecT ptd eps
  -- if cd = ConsD (eps, eps) -> (ConsT cparamIL* typ)
  ----
  -- ConsDef_wf: $bound_tids(GLOBAL, C_0) |- cd
  ----
  -- if C_7 = $add_consdef(GLOBAL, C_0, cid, cd)

;;
;; Package declaration
;;

rule Decl_ok/packagetyped:
  GLOBAL C_0 |- PackageTypeD id tparam* cparam* : C_4 (PackageTypeD id tparam* tparam_hidden* cparamIL*)
  -- if cid = $to_fid(id, cparam*)
  ----
  -- if C_1 = $add_typdefs(BLOCK, C_0, tparam*, (MonoD (VarT tparam))*)
  ----
  -- if C_2 = $set_blockkind(C_1, PACKAGE)
  ----
  -- (CParam_ok: BLOCK C_2 |- cparam : cparamIL tid_fresh_c*)*
  -- if tparam_hidden* = $concat_<tid>(tid_fresh_c**)
  ----
  -- if (_ _ typ_c _ = cparamIL)*
  -- if ptd = PolyD (tparam*, tparam_hidden*) -> (PackageT typ_c*)
  -- TypeDef_wf: $bound_tids(BLOCK, C_2) |- ptd
  ----
  -- if tparam'* = tparam* ++ tparam_hidden*
  -- if typ = SpecT ptd (VarT tparam')*
  -- if cd = ConsD (tparam*, tparam_hidden*) -> (ConsT cparamIL* typ)
  ----
  -- ConsDef_wf: $bound_tids(BLOCK, C_2) |- cd
  ----
  -- if C_3 = $add_typdef(GLOBAL, C_0, id, ptd)
  ----
  -- if C_4 = $add_consdef(GLOBAL, C_3, cid, cd)

;;
;; Declaration sequence
;;

rule Decls_ok/nil:
  p C |- eps : C eps

rule Decls_ok/cons:
  p C |- decl_h :: decl_t* : C'' (declIL_h :: declIL_t*)
  -- Decl_ok: p C |- decl_h : C' declIL_h
  -- Decls_ok: p C' |- decl_t* : C'' declIL_t*

;;
;; Program
;;

rule Prog_ok:
  |- decl* : C' declIL*
  -- if C = $empty_context()
  -- Decls_ok: GLOBAL C |- decl* : C' declIL*
