;;
;; Misc
;;

syntax trailingCommaOpt =
  | ""
  | ","

;;
;; Numbers
;;

syntax number =
  | "" int        hint(print %)
  | nat "w" int    hint(print %#W#%)
  | nat "s" int    hint(print %#S#%)

;;
;; Strings
;;

syntax stringLiteral = `" text `"    hint(print `"#%#`")

;;
;; Names
;;

;;; The grammar is actually ambiguous,
;;; so the lexer and the parser must collaborate for parsing the language.
;;; In particular, the lexer must be able to distinguish two kinds of identifiers:
;;;
;;; * Type names previously introduced (TYPE_IDENTIFIER tokens)
;;; * Regular identifiers (IDENTIFIER token)

syntax identifier = ID text
syntax typeIdentifier = TID text

;;
;;;; Non-type names
;;

syntax nonTypeName =
  | identifier
  | "apply" | "key" | ACTIONS | STATE
  | ENTRIES | TYPE | PRIORITY

syntax prefixedNonTypeName =
  | nonTypeName
  | `ID "." nonTypeName

;;
;;;; Type names
;;

syntax typeName = typeIdentifier

syntax prefixedTypeName =
  | typeName 
  | `TID "." typeName

;;
;;;; Table custom property names
;;

syntax tableCustomName =
  | identifier
  | typeIdentifier
  | APPLY | STATE | TYPE | PRIORITY

;;
;;;; Names
;;

syntax name =
  | nonTypeName
  | typeName
  | LIST

syntax nameList =
  | name
  | nameList "," name

dec $flatten_nameList(nameList) : name*
def $flatten_nameList(name) = name
def $flatten_nameList(nameList "," name) =
  $flatten_nameList(nameList) ++ [ name ]

syntax member = name

;;
;; Directions
;;

syntax direction = "" | IN | OUT | INOUT

;;
;; Types
;;

;;
;;;; Base types
;;

syntax expression

syntax baseType =
  | BOOL
  | ERROR
  | MATCH_KIND
  | STRING
  | INT
  | INT "<" int ">"
  | INT "<" `( expression ) ">"
  | BIT
  | BIT `< int >
  | BIT `< `( expression ) >
  | VARBIT `< int >
  | VARBIT `< `( expression ) >

;;
;;;; Named types
;;

syntax typeArgumentList

syntax specializedType = prefixedTypeName `< typeArgumentList >

syntax namedType =
  | prefixedTypeName
  | specializedType

;;
;;;; Header stack types
;;

syntax headerStackType = namedType "[" expression "]"

;;
;;;; List types
;;

syntax typeArgument

syntax listType = "list" "<" typeArgument ">"

;;
;;;; Tuple types
;;

syntax tupleType = TUPLE `< typeArgumentList >

;;
;;;; Types
;;

syntax type =
  | baseType
  | namedType
  | headerStackType
  | listType
  | tupleType

syntax typeOrVoid =
  | type
  | "void" 
  | identifier

;;
;; Type parameters
;;

syntax typeParameter = name

syntax typeParameterList =
  | typeParameter
  | typeParameterList "," typeParameter

dec $flatten_typeParameterList(typeParameterList) : typeParameter*
def $flatten_typeParameterList(typeParameter) = typeParameter
def $flatten_typeParameterList(typeParameterList "," typeParameter) =
  $flatten_typeParameterList(typeParameterList) ++ [ typeParameter ]

syntax typeParameterListOpt =
  | ""
  | `< typeParameterList >

dec $flatten_typeParameterListOpt(typeParameterListOpt) : typeParameter*
def $flatten_typeParameterListOpt("") = eps
def $flatten_typeParameterListOpt(`< typeParameterList >)
  = $flatten_typeParameterList(typeParameterList)

;;
;; Parameters
;;

syntax annotationList, initializerOpt

syntax parameter =
  annotationList direction type name initializerOpt

syntax nonEmptyParameterList =
  | parameter
  | nonEmptyParameterList "," parameter

syntax parameterList =
  | ""
  | nonEmptyParameterList

dec $flatten_parameterList(parameterList) : parameter*
def $flatten_parameterList("") = eps
def $flatten_parameterList(parameter) = parameter
def $flatten_parameterList(nonEmptyParameterList "," parameter)
  = $flatten_parameterList(nonEmptyParameterList) ++ [ parameter ]

;;
;; Constructor parameters
;;

syntax constructorParameter = parameter

syntax constructorParameterList = parameterList

syntax constructorParameterListOpt =
  | ""
  | `( parameterList )

dec $flatten_constructorParameterListOpt(constructorParameterListOpt)
  : constructorParameter*

def $flatten_constructorParameterListOpt("") = eps
def $flatten_constructorParameterListOpt(`( parameterList ))
  = $flatten_parameterList(parameterList)

;;
;; Expression key-value pairs
;;

syntax namedExpression = name "=" expression

syntax namedExpressionList =
  | namedExpression
  | namedExpressionList "," namedExpression

dec $flatten_namedExpressionList(namedExpressionList) : namedExpression*
def $flatten_namedExpressionList(namedExpression) = namedExpression
def $flatten_namedExpressionList(namedExpressionList "," namedExpression) =
  $flatten_namedExpressionList(namedExpressionList) ++ [ namedExpression ]

;;
;; Expressions
;;

;;
;;;; Literal expressions
;;

syntax literalExpression =
  | TRUE | FALSE
  | number
  | stringLiteral

;;
;;;; Reference expressions
;;

syntax referenceExpression =
  | prefixedNonTypeName
  | THIS

;;
;;;; Default expressions
;;

syntax defaultExpression = "..."

;;
;;;; Unary, binary, and ternary expressions
;;

syntax expressionNonBrace

syntax unop = "!" | "~" | "-" | "+"

syntax unaryExpression = unop expression

syntax binop =
  | "*" | "/" | "%" | "+" | "-" | "|+|" | "|-|" | "<<" | ">>"
  | "<=" | ">=" | "<" | ">" | "!=" | "=="
  | "&" | "^" | "|" | "++" | "&&" | "||"

syntax binaryExpression = expression binop expression

syntax binaryExpressionNonBrace =
  expressionNonBrace binop expression

syntax ternaryExpression =
  expression "?" expression ":" expression

syntax ternaryExpressionNonBrace =
  expressionNonBrace "?" expression ":" expression

;;
;;;; Cast expressions
;;

syntax castExpression = `( type ) expression

;;
;;;; Data (aggregate) expressions
;;

syntax dataElementExpression

syntax dataExpression =
  | `{#}
  | `{ dataElementExpression trailingCommaOpt }

;;
;;;; Member and index access expressions
;;

syntax memberAccessBase, memberAccessBaseNonBrace

syntax errorAccessExpression =
  ERROR "." member

syntax memberAccessExpression =
  memberAccessBase "." member

syntax indexAccessExpression =
  | expression `[ expression ]
  | expression `[ expression ":" expression ]

syntax accessExpression =
  | errorAccessExpression
  | memberAccessExpression
  | indexAccessExpression

syntax memberAccessExpressionNonBrace =
  memberAccessBaseNonBrace "." member

syntax indexAccessExpressionNonBrace =
  | expressionNonBrace `[ expression ]
  | expressionNonBrace `[ expression ":" expression ]

syntax accessExpressionNonBrace =
  | errorAccessExpression
  | memberAccessExpressionNonBrace
  | indexAccessExpressionNonBrace

;;
;;;; Call expressions
;;

syntax callTarget
syntax routineTarget
syntax realTypeArgumentList
syntax argumentList
syntax callTargetNonBrace
syntax routineTargetNonBrace

syntax callExpression =
  | callTarget "(" argumentList ")"
  | routineTarget "<" realTypeArgumentList ">" "(" argumentList ")"

syntax callExpressionNonBrace =
  | callTargetNonBrace "(" argumentList ")"
  | routineTargetNonBrace "<" realTypeArgumentList ">" "(" argumentList ")"

;;
;;;; Parenthesized expressions
;;

syntax parenthesizedExpression = `( expression )

;;
;;;; Expressions
;;

syntax expression =
  | literalExpression
  | referenceExpression
  | defaultExpression
  | unaryExpression
  | binaryExpression
  | ternaryExpression
  | castExpression
  | dataExpression
  | accessExpression
  | callExpression
  | parenthesizedExpression

;;; (TODO) Why allow (EMPTY "," expression)?
syntax expressionList =
  | ""
  | expression
  | expressionList "," expression

dec $flatten_expressionList(expressionList) : expression*
def $flatten_expressionList("") = eps
def $flatten_expressionList(expression) = expression
def $flatten_expressionList(expressionList "," expression) =
  $flatten_expressionList(expressionList) ++ [ expression ]

syntax memberAccessBase =
  | prefixedTypeName
  | expression

syntax sequenceElementExpression = expressionList

syntax recordElementExpression =
  | name "=" expression
  | name "=" expression "," "..."
  | name "=" expression "," namedExpressionList
  | name "=" expression "," namedExpressionList `, "..."

syntax dataElementExpression =
  | sequenceElementExpression
  | recordElementExpression

syntax routineTarget = expression
syntax constructorTarget = namedType

syntax callTarget =
  | routineTarget
  | constructorTarget

;;
;;;; Non-brace expressions
;;

syntax expressionNonBrace =
  | literalExpression
  | referenceExpression
  | unaryExpression
  | binaryExpressionNonBrace
  | ternaryExpressionNonBrace
  | castExpression
  | accessExpressionNonBrace
  | callExpressionNonBrace
  | parenthesizedExpression

syntax memberAccessBaseNonBrace =
  | prefixedTypeName
  | expressionNonBrace

syntax routineTargetNonBrace = expressionNonBrace

syntax callTargetNonBrace =
  | routineTargetNonBrace
  | constructorTarget

dec $expressionNonBrace(expressionNonBrace) : expression
def $expressionNonBrace(literalExpression) = literalExpression
def $expressionNonBrace(referenceExpression) = referenceExpression
def $expressionNonBrace(unaryExpression) = unaryExpression
def $expressionNonBrace(
    expressionNonBrace_l binop expression_r
  )
  = expression_l binop expression_r
  -- if expression_l = $expressionNonBrace(expressionNonBrace_l)
def $expressionNonBrace(
    expressionNonBrace_cond "?" expression_true ":" expression_false
  )
  = expression_cond "?" expression_true ":" expression_false
  -- if expression_cond = $expressionNonBrace(expressionNonBrace_cond)
def $expressionNonBrace(castExpression) = castExpression
def $expressionNonBrace(errorAccessExpression) = errorAccessExpression
def $expressionNonBrace(prefixedTypeName "." member)
  = prefixedTypeName "." member
def $expressionNonBrace(expressionNonBrace_base "." member)
  = expression_base "." member
  -- if expression_base = $expressionNonBrace(expressionNonBrace_base)
def $expressionNonBrace(
    expressionNonBrace_base `[ expression_index ]
  )
  = expression_base `[ expression_index ]
  -- if expression_base = $expressionNonBrace(expressionNonBrace_base)
def $expressionNonBrace(
    expressionNonBrace_base `[ expression_hi ":" expression_lo ]
  )
  = expression_base `[ expression_hi ":" expression_lo ]
  -- if expression_base = $expressionNonBrace(expressionNonBrace_base)
def $expressionNonBrace(
    expressionNonBrace "(" argumentList ")"
  )
  = expression "(" argumentList ")"
  -- if expression = $expressionNonBrace(expressionNonBrace)
def $expressionNonBrace(
    constructorTarget "(" argumentList ")"
  )
  = constructorTarget "(" argumentList ")"
def $expressionNonBrace(
    expressionNonBrace "<" realTypeArgumentList ">" "(" argumentList ")"
  )
  = expression "<" realTypeArgumentList ">" "(" argumentList ")"
  -- if expression = $expressionNonBrace(expressionNonBrace)
def $expressionNonBrace(parenthesizedExpression) = parenthesizedExpression

;;
;; Keyset expressions
;;

syntax simpleKeysetExpression =
  | expression
  | expression "&&&" expression
  | expression ".." expression
  | "default"
  | "_"

syntax simpleKeysetExpressionList = 
  | simpleKeysetExpression
  | simpleKeysetExpressionList "," simpleKeysetExpression

dec $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList)
  : simpleKeysetExpression*
def $flatten_simpleKeysetExpressionList(simpleKeysetExpression)
  = simpleKeysetExpression
def $flatten_simpleKeysetExpressionList(
    simpleKeysetExpressionList "," simpleKeysetExpression
  )
  = $flatten_simpleKeysetExpressionList(simpleKeysetExpressionList)
    ++ [ simpleKeysetExpression ]

syntax tupleKeysetExpression =
  | "(" expression "&&&" expression ")"
  | "(" expression ".." expression ")"
  | "(" "default" ")"
  | "(" "_" ")"
  | `( simpleKeysetExpression "," simpleKeysetExpressionList )

syntax keysetExpression =
  | simpleKeysetExpression
  | tupleKeysetExpression

;;
;; Type arguments
;;

syntax realTypeArgument =
  | type
  | "void"
  | "_"

syntax realTypeArgumentList =
  | realTypeArgument
  | realTypeArgumentList "," realTypeArgument

dec $flatten_realTypeArgumentList(realTypeArgumentList) : realTypeArgument*
def $flatten_realTypeArgumentList(realTypeArgument) = realTypeArgument
def $flatten_realTypeArgumentList(realTypeArgumentList "," realTypeArgument) =
  $flatten_realTypeArgumentList(realTypeArgumentList) ++ [ realTypeArgument ]

syntax typeArgument =
  | realTypeArgument
  | nonTypeName

;;; (TODO) Why allow (EMPTY "," argument)?
syntax typeArgumentList =
  | ""
  | typeArgument
  | typeArgumentList "," typeArgument

dec $flatten_typeArgumentList(typeArgumentList) : typeArgument*
def $flatten_typeArgumentList("") = eps
def $flatten_typeArgumentList(typeArgument) = typeArgument
def $flatten_typeArgumentList(typeArgumentList "," typeArgument) =
  $flatten_typeArgumentList(typeArgumentList) ++ [ typeArgument ]

;;
;; Arguments
;;

syntax argument =
  | expression
  | name "=" expression
  | name "=" "_"
  | "_"

syntax argumentListNonEmpty =
  | argument
  | argumentListNonEmpty "," argument

syntax argumentList =
  | ""
  | argumentListNonEmpty

dec $flatten_argumentList(argumentList) : argument*
def $flatten_argumentList("") = eps
def $flatten_argumentList(argument) = argument
def $flatten_argumentList(argumentListNonEmpty "," argument) =
  $flatten_argumentList(argumentListNonEmpty) ++ [ argument ]

;;
;; L-values
;;

syntax lvalue =
  | referenceExpression
  | lvalue "." member
  | lvalue "[" expression "]"
  | lvalue "[" expression ":" expression "]"
  | "(" lvalue ")"

;;
;; Statements
;;

;;
;;;; Empty statements
;;

syntax emptyStatement = ";"

;;
;;;; Assignment statements
;;

syntax assignop =
  | "="
  | "+=" | "-=" | "|+|=" | "|-|=" | "*=" | "/=" | "%="
  | "<<=" | ">>=" | "&=" | "^=" | "|="

syntax assignmentStatement = lvalue assignop expression ";"

;;
;;;; Call statements
;;

syntax callStatement =
  | lvalue "(" argumentList ")" ";"
  | lvalue `< typeArgumentList > `( argumentList ) ";"

;;
;;;; Direct application statements
;;

syntax directApplicationStatement = namedType "." APPLY `( argumentList ) ";"

;;
;;;; Return statements
;;

syntax returnStatement =
  | RETURN ";"
  | RETURN expression ";"

;;
;;;; Exit statements
;;

syntax exitStatement = EXIT ";"

;;
;;;; Block statements
;;

syntax blockElementStatementList

syntax blockStatement = annotationList `{ blockElementStatementList }

;;
;;;; Conditional statements
;;

syntax statement

syntax conditionalStatement =
  | IF `( expression ) statement
  | IF `( expression ) statement ELSE statement

;;
;;;; For statements
;;

syntax annotationListNonEmpty

syntax forInitStatement =
  | annotationList type name initializerOpt
  | lvalue `( argumentList )
  | lvalue `< typeArgumentList > `( argumentList )
  | lvalue assignop expression

syntax forInitStatementListNonEmpty =
  | forInitStatement
  | forInitStatementListNonEmpty "," forInitStatement

syntax forInitStatementList =
  | ""
  | forInitStatementListNonEmpty

syntax forUpdateStatement = forInitStatement

syntax forUpdateStatementListNonEmpty =
  | forUpdateStatement
  | forUpdateStatementListNonEmpty "," forUpdateStatement

syntax forUpdateStatementList =
  | ""
  | forUpdateStatementListNonEmpty

syntax forCollectionExpression =
  | expression
  | expression ".". expression

syntax forStatement =
  | annotationList FOR
      `( forInitStatementList ";" expression `; forUpdateStatementList ) statement
  | annotationList FOR
      `( type name IN forCollectionExpression ) statement
  | annotationList FOR
      `( annotationListNonEmpty type name IN forCollectionExpression ) statement

;;
;;;; Switch statements
;;

syntax switchLabel =
  | DEFAULT
  | expressionNonBrace

syntax switchCase =
  | switchLabel ":" blockStatement
  | switchLabel ":" 

syntax switchCaseList =
  | ""
  | switchCaseList switchCase

dec $flatten_switchCaseList(switchCaseList) : switchCase*
def $flatten_switchCaseList("") = eps
def $flatten_switchCaseList(switchCaseList switchCase)
  = $flatten_switchCaseList(switchCaseList) ++ [ switchCase ]

syntax switchStatement = SWITCH `( expression ) `{ switchCaseList }

;;
;;;; Break and continue statements
;;

syntax breakStatement = BREAK ";"

syntax continueStatement = CONTINUE ";"

;;
;;;; Statements
;;

syntax statement =
  | emptyStatement
  | assignmentStatement
  | callStatement
  | directApplicationStatement
  | returnStatement
  | exitStatement
  | blockStatement
  | conditionalStatement
  | forStatement
  | breakStatement
  | continueStatement
  | switchStatement

;;
;; Declarations
;;

;;
;;;; Constant and variable declarations
;;

syntax initializer = "=" expression

syntax constantDeclaration =
  annotationList CONST type name initializer ";"

syntax initializerOpt =
  | ""
  | initializer

syntax variableDeclaration =
  annotationList type name initializerOpt ";"

syntax blockElementStatement =
  | constantDeclaration
  | variableDeclaration
  | statement

syntax blockElementStatementList =
  | ""
  | blockElementStatementList blockElementStatement

dec $flatten_blockElementStatementList(blockElementStatementList)
  : blockElementStatement*
def $flatten_blockElementStatementList("") = eps
def $flatten_blockElementStatementList(
    blockElementStatementList blockElementStatement
  )
  = $flatten_blockElementStatementList(blockElementStatementList) ++
    [ blockElementStatement ]

;;
;;;; Function declarations
;;

syntax functionPrototype =
  typeOrVoid name typeParameterListOpt `( parameterList )

syntax functionDeclaration =
  annotationList functionPrototype blockStatement

;;
;;;; Action declarations
;;

syntax actionDeclaration =
  annotationList ACTION name `( parameterList ) blockStatement

;;
;;;; Instantiations
;;

syntax objectDeclarationList

syntax objectInitializer = "=" `{ objectDeclarationList }

;; (TODO) can we refine type as namedType?
syntax instantiation =
  | annotationList type `( argumentList ) name ";"
  | annotationList type `( argumentList ) name objectInitializer ";"

syntax objectDeclaration =
  | functionDeclaration
  | instantiation

syntax objectDeclarationList =
  | ""
  | objectDeclarationList objectDeclaration

dec $flatten_objectDeclarationList(objectDeclarationList) : objectDeclaration*
def $flatten_objectDeclarationList("") = eps
def $flatten_objectDeclarationList(
    objectDeclarationList objectDeclaration
  )
  = $flatten_objectDeclarationList(objectDeclarationList)
    ++ [ objectDeclaration ]

;;
;;;; Error declarations
;;

syntax errorDeclaration = ERROR `{ nameList }

;;
;;;; Match kind declarations
;;

syntax matchKindDeclaration = MATCH_KIND `{ nameList trailingCommaOpt }

;;
;;;; Derived type declarations
;;

;;
;;;;;; Enum type declarations
;;

syntax enumTypeDeclaration =
  | annotationList ENUM name `{ nameList trailingCommaOpt }
  | annotationList ENUM type name `{ namedExpressionList trailingCommaOpt }

;;
;;;;;; Struct, header, and union type declarations
;;

syntax typeField = annotationList type name ";"

syntax typeFieldList =
  | ""
  | typeFieldList typeField

dec $flatten_typeFieldList(typeFieldList) : typeField*
def $flatten_typeFieldList("") = eps
def $flatten_typeFieldList(typeFieldList typeField)
  = $flatten_typeFieldList(typeFieldList) ++ [ typeField ]

syntax structTypeDeclaration =
  annotationList STRUCT name typeParameterListOpt `{ typeFieldList }

syntax headerTypeDeclaration =
  annotationList HEADER name typeParameterListOpt `{ typeFieldList }

syntax headerUnionTypeDeclaration =
  annotationList HEADER_UNION name typeParameterListOpt `{ typeFieldList }

syntax derivedTypeDeclaration =
  | enumTypeDeclaration
  | structTypeDeclaration
  | headerTypeDeclaration
  | headerUnionTypeDeclaration

;;
;;;; Typedef and newtype declarations
;;

syntax typedefType =
  | type
  | derivedTypeDeclaration

syntax typedefDeclaration =
  | annotationList TYPEDEF typedefType name ";"
  | annotationList TYPE type name ";"

;;
;;;; Extern declarations
;;

syntax externFunctionDeclaration =
  annotationList EXTERN functionPrototype ";"

syntax methodPrototype =
  | annotationList typeIdentifier `( parameterList ) ";"
  | annotationList functionPrototype ";"
  | annotationList ABSTRACT functionPrototype ";"

syntax methodPrototypeList =
  | ""
  | methodPrototypeList methodPrototype

dec $flatten_methodPrototypeList(methodPrototypeList) : methodPrototype*
def $flatten_methodPrototypeList("") = eps
def $flatten_methodPrototypeList(
    methodPrototypeList methodPrototype
  )
  = $flatten_methodPrototypeList(methodPrototypeList) ++ [ methodPrototype ]

syntax externObjectDeclaration =
  annotationList EXTERN nonTypeName typeParameterListOpt `{ methodPrototypeList }

syntax externDeclaration =
  | externFunctionDeclaration
  | externObjectDeclaration

;;
;;;; Parser statements and declarations
;;

;;
;;;;;; Select expressions
;;

syntax selectCase = keysetExpression ":" name ";"

syntax selectCaseList =
  | ""
  | selectCaseList selectCase

dec $flatten_selectCaseList(selectCaseList) : selectCase*
def $flatten_selectCaseList("") = eps
def $flatten_selectCaseList(selectCaseList selectCase)
  = $flatten_selectCaseList(selectCaseList) ++ [ selectCase ]

syntax selectExpression = SELECT `( expressionList ) `{ selectCaseList }

;;
;;;;;; Transition statements
;;

syntax stateExpression =
  | name ";"
  | selectExpression

syntax transitionStatement =
  | ""
  | TRANSITION stateExpression

;;
;;;;;; Value set declarations
;;

syntax valueSetType =
  | baseType
  | tupleType
  | prefixedTypeName

syntax valueSetDeclaration =
  annotationList VALUE_SET `< valueSetType > `( expression ) name ";"

;;
;;;;;; Parser type declarations
;;

syntax parserTypeDeclaration =
  annotationList PARSER name typeParameterListOpt `( parameterList ) ";"

;;
;;;;;; Parser declarations
;;

syntax parserStatementList

syntax parserBlockStatement = annotationList `{ parserStatementList }

syntax parserStatement =
  | constantDeclaration
  | variableDeclaration
  | emptyStatement
  | assignmentStatement
  | callStatement
  | directApplicationStatement
  | parserBlockStatement
  | conditionalStatement

syntax parserStatementList =
  | ""
  | parserStatementList parserStatement

dec $flatten_parserStatementList(parserStatementList) : parserStatement*
def $flatten_parserStatementList("") = eps
def $flatten_parserStatementList(parserStatementList parserStatement)
  = $flatten_parserStatementList(parserStatementList) ++ [ parserStatement ]

syntax parserState =
  annotationList STATE name `{ parserStatementList transitionStatement }

syntax parserStateList =
  | parserState
  | parserStateList parserState

dec $flatten_parserStateList(parserStateList) : parserState*
def $flatten_parserStateList(parserState) = parserState
def $flatten_parserStateList(parserStateList parserState)
  = $flatten_parserStateList(parserStateList) ++ [ parserState ]

syntax parserLocalDeclaration =
  | constantDeclaration
  | instantiation
  | variableDeclaration
  | valueSetDeclaration

syntax parserLocalDeclarationList =
  | ""
  | parserLocalDeclarationList parserLocalDeclaration

dec $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
  : parserLocalDeclaration*
def $flatten_parserLocalDeclarationList("") = eps
def $flatten_parserLocalDeclarationList(
    parserLocalDeclarationList parserLocalDeclaration
  )
  = $flatten_parserLocalDeclarationList(parserLocalDeclarationList)
    ++ [ parserLocalDeclaration ]

syntax parserDeclaration =
  annotationList PARSER name typeParameterListOpt
    `( parameterList ) constructorParameterListOpt
    `{ parserLocalDeclarationList parserStateList }

;;
;;;; Control statements and declarations
;;

;;
;;;;;; Table declarations
;;

syntax const = CONST

syntax constOpt =
  | ""
  | const

dec $flatten_constOpt(constOpt) : const?
def $flatten_constOpt("") = eps
def $flatten_constOpt(const) = const

;;
;;;;;;;; Table key property 
;;

syntax tableKey = expression ":" name annotationList ";"

syntax tableKeyList =
  | ""
  | tableKeyList tableKey

dec $flatten_tableKeyList(tableKeyList) : tableKey*
def $flatten_tableKeyList("") = eps
def $flatten_tableKeyList(tableKeyList tableKey)
  = $flatten_tableKeyList(tableKeyList) ++ [ tableKey ]

;;
;;;;;;;; Table actions property
;;

syntax tableActionReference =
  | prefixedNonTypeName
  | prefixedNonTypeName `( argumentList )

syntax tableAction = annotationList tableActionReference ";"

syntax tableActionList =
  | ""
  | tableActionList tableAction

dec $flatten_tableActionList(tableActionList) : tableAction*
def $flatten_tableActionList("") = eps
def $flatten_tableActionList(tableActionList tableAction) =
  $flatten_tableActionList(tableActionList) ++ [ tableAction ]

;;
;;;;;;;; Table entry property
;;

syntax tableEntryPriority =
  | PRIORITY "=" number ":"
  | PRIORITY "=" `( expression ) ":"

syntax tableEntry =
  | constOpt tableEntryPriority keysetExpression ":" tableActionReference annotationList ";" 
  | constOpt keysetExpression ":" tableActionReference annotationList ";" 

syntax tableEntryList =
  | ""
  | tableEntryList tableEntry

dec $flatten_tableEntryList(tableEntryList) : tableEntry*
def $flatten_tableEntryList("") = eps
def $flatten_tableEntryList(tableEntryList tableEntry)
  = $flatten_tableEntryList(tableEntryList) ++ [ tableEntry ]

;;
;;;;;;;; Table properties
;;

syntax tableProperty =
  | KEY "=" `{ tableKeyList }
  | ACTIONS "=" `{ tableActionList }
  | annotationList constOpt ENTRIES "=" `{ tableEntryList }
  | annotationList constOpt tableCustomName initializer ";"

syntax tablePropertyList =
  | ""
  | tablePropertyList tableProperty

dec $flatten_tablePropertyList(tablePropertyList) : tableProperty*
def $flatten_tablePropertyList("") = eps
def $flatten_tablePropertyList(tablePropertyList tableProperty) =
  $flatten_tablePropertyList(tablePropertyList) ++ [ tableProperty ]

syntax tableDeclaration =
  annotationList TABLE name `{ tablePropertyList }

;;
;;;;;; Control type declarations
;;

syntax controlTypeDeclaration =
  annotationList CONTROL name typeParameterListOpt `( parameterList ) ";"

;;
;;;;;; Control declarations
;;

syntax controlBody = blockStatement

syntax controlLocalDeclaration =
  | constantDeclaration
  | instantiation
  | variableDeclaration
  | actionDeclaration
  | tableDeclaration

syntax controlLocalDeclarationList =
  | ""
  | controlLocalDeclarationList controlLocalDeclaration

dec $flatten_controlLocalDeclarationList(controlLocalDeclarationList)
  : controlLocalDeclaration*

def $flatten_controlLocalDeclarationList("") = eps
def $flatten_controlLocalDeclarationList(
    controlLocalDeclarationList controlLocalDeclaration
  )
  = $flatten_controlLocalDeclarationList(controlLocalDeclarationList) ++
    [ controlLocalDeclaration ]

syntax controlDeclaration =
  annotationList CONTROL name typeParameterListOpt
    `( parameterList ) constructorParameterListOpt
    `{ controlLocalDeclarationList APPLY controlBody }

;;
;;;; Package type declarations
;;

syntax packageTypeDeclaration =
  annotationList PACKAGE name typeParameterListOpt `( parameterList ) ";"

;;
;;;; Type declarations
;;

syntax typeDeclaration =
  | derivedTypeDeclaration
  | typedefDeclaration
  | parserTypeDeclaration
  | controlTypeDeclaration
  | packageTypeDeclaration

;;
;;;; Declaration
;;

syntax declaration =
  | constantDeclaration
  | instantiation
  | functionDeclaration
  | actionDeclaration
  | errorDeclaration
  | matchKindDeclaration
  | externDeclaration
  | parserDeclaration
  | controlDeclaration 
  | typeDeclaration

;;
;; Annotations
;;

syntax annotationToken =
  | UNEXPECTED_TOKEN | ABSTRACT | ACTION | ACTIONS | APPLY
  | BOOL | BIT | BREAK | CONST | CONTINUE
  | CONTROL | DEFAULT | ELSE | ENTRIES | ENUM
  | ERROR | EXIT | EXTERN | FALSE | FOR
  | HEADER | HEADER_UNION | IF | IN | INOUT
  | INT | KEY | MATCH_KIND | TYPE | OUT
  | PARSER | PACKAGE | PRAGMA | RETURN | SELECT
  | STATE | STRING | STRUCT | SWITCH | TABLE
  | THIS | TRANSITION | TRUE | TUPLE | TYPEDEF
  | VARBIT | VALUE_SET | LIST | VOID | "_"
  | identifier | typeIdentifier | stringLiteral | number
  | "&&&" | ".." | "<<" | "&&" | "||" 
  | "==" | "!=" | ">=" | "<="  | "++"
  | "+" | "|+|" | "-" | "|-|" | "*"
  | "/" | "%" | "|" | "&" | "^"
  | "~" | "[" | "]" | "{" | "}"
  | "<" | ">" | "!" | ":" | ","
  | "?" | "." | "=" | ";" | "@"

syntax annotationBody =
  | ""
  | annotationBody `( annotationBody )
  | annotationBody annotationToken

syntax structuredAnnotationBody =
  dataElementExpression trailingCommaOpt

syntax annotation =
  | "@" name
  | "@" name `( annotationBody )
  | "@" name `[ structuredAnnotationBody ]

syntax annotationListNonEmpty =
  | annotation
  | annotationListNonEmpty annotation

syntax annotationList =
  | ""
  | annotationListNonEmpty

;;
;; P4 program
;;

syntax p4program =
  | ""
  | p4program declaration
  | p4program ";"

dec $flatten_p4program(p4program) : declaration*
def $flatten_p4program("") = eps
def $flatten_p4program(p4program declaration)
  = $flatten_p4program(p4program) ++ [ declaration ]
def $flatten_p4program(p4program ";")
  = $flatten_p4program(p4program)
