;; ../../../../spec/0-aux.watsup:18.1-18.21
def $sum



;; ../../../../spec/0-aux.watsup:19.1-19.21
def $max



;; ../../../../spec/0-aux.watsup:20.1-20.21
def $min



;; ../../../../spec/0-aux.watsup:26.1-27.17
def $int_to_text



;; ../../../../spec/0-aux.watsup:29.1-30.17
def $concat_text(text*)

1. If (text* matches pattern []), then

  1. Return ""

1. Else If (text* matches pattern _ :: _), then

  1. Let t :: t'* be text*

  2. Return t ++ $concat_text(t'*)

;; ../../../../spec/0-aux.watsup:35.1-35.37
def $strip_prefix



;; ../../../../spec/0-aux.watsup:36.1-36.37
def $strip_suffix



;; ../../../../spec/0-aux.watsup:42.1-42.23
def $init_(nat')

1. If (nat' = 0), then

  1. Return []

2. Otherwise

  1. Return (nat' - 1) :: $init_((nat' - 1))

;; ../../../../spec/0-aux.watsup:47.1-47.29
def $repeat_<X>(X, nat')

1. If (nat' = 0), then

  1. Return []

2. Otherwise

  1. Return [X] ++ $repeat_<X>(X, (nat' - 1))

;; ../../../../spec/0-aux.watsup:53.1-54.26
def $rev_<X>



;; ../../../../spec/0-aux.watsup:56.1-57.23
def $concat_<X>



;; ../../../../spec/0-aux.watsup:59.1-59.39
def $partition_<X>



;; ../../../../spec/0-aux.watsup:61.1-62.23
def $assoc_<X, Y>



;; ../../../../spec/0-aux.watsup:64.1-65.28
def $distinct_<K>



;; ../../../../spec/0-aux.watsup:71.17-71.24
syntax set<K> = 
   | `{%}`(K*)

;; ../../../../spec/0-aux.watsup:73.1-74.43
def $empty_set<K>

1. Return ({ [] })

;; ../../../../spec/0-aux.watsup:77.1-78.36
def $in_set<K>(K, ({ K'* }))

1. Return K is in K'*

;; ../../../../spec/0-aux.watsup:81.1-82.37
def $intersect_set<K>



;; ../../../../spec/0-aux.watsup:84.1-85.37
def $union_set<K>



;; ../../../../spec/0-aux.watsup:87.1-88.37
def $unions_set<K>



;; ../../../../spec/0-aux.watsup:90.1-91.42
def $diff_set<K>



;; ../../../../spec/0-aux.watsup:93.1-94.40
def $sub_set<K>



;; ../../../../spec/0-aux.watsup:96.1-97.33
def $eq_set<K>



;; ../../../../spec/0-aux.watsup:103.21-103.27
syntax pair<K, V> = 
   | `%->%`(K, V)

;; ../../../../spec/0-aux.watsup:106.20-106.37
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec/0-aux.watsup:108.1-109.43
def $empty_map<K, V>

1. Return ({ [] })

;; ../../../../spec/0-aux.watsup:113.1-114.55
def $dom_map<K, V>(({ (K -> V)* }))

1. Return ({ K* })

;; ../../../../spec/0-aux.watsup:118.1-119.25
def $find_map<K, V>



;; ../../../../spec/0-aux.watsup:121.1-122.25
def $find_maps<K, V>



;; ../../../../spec/0-aux.watsup:124.1-125.71
def $add_map<K, V>



;; ../../../../spec/0-aux.watsup:127.1-128.71
def $adds_map<K, V>



;; ../../../../spec/0-aux.watsup:130.1-131.71
def $update_map<K, V>



;; ../../../../spec/1a-syntax-el.watsup:5.15-5.18
syntax bits = int

;; ../../../../spec/1a-syntax-el.watsup:6.16-6.19
syntax width = nat

;; ../../../../spec/1a-syntax-el.watsup:9.1-11.39
syntax num = 
   | `INT%`(int)
   | `FINT%%`(width, bits)
   | `FBIT%%`(width, bits)

;; ../../../../spec/1a-syntax-el.watsup:21.13-21.17
syntax id = text

;; ../../../../spec/1a-syntax-el.watsup:28.1-29.29
syntax name = 
   | `TOP%`(id)
   | `CURRENT%`(id)

;; ../../../../spec/1a-syntax-el.watsup:35.17-35.19
syntax member = id

;; ../../../../spec/1a-syntax-el.watsup:41.20-41.22
syntax matchkind = id

;; ../../../../spec/1a-syntax-el.watsup:47.21-47.23
syntax statelabel = id

;; ../../../../spec/1a-syntax-el.watsup:54.1-57.35
syntax unop = 
   | `BNOT`()
   | `LNOT`()
   | `UPLUS`()
   | `UMINUS`()

;; ../../../../spec/1a-syntax-el.watsup:64.1-84.36
syntax binop = 
   | `PLUS`()
   | `SPLUS`()
   | `MINUS`()
   | `SMINUS`()
   | `MUL`()
   | `DIV`()
   | `MOD`()
   | `SHL`()
   | `SHR`()
   | `LE`()
   | `GE`()
   | `LT`()
   | `GT`()
   | `EQ`()
   | `NE`()
   | `BAND`()
   | `BXOR`()
   | `BOR`()
   | `CONCAT`()
   | `LAND`()
   | `LOR`()

;; ../../../../spec/1a-syntax-el.watsup:90.14-90.37
syntax dir = 
   | `NO`()
   | `IN`()
   | `OUT`()
   | `INOUT`()

;; ../../../../spec/1a-syntax-el.watsup:103.1-117.36
syntax type = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(expr)
   | `FBitT%`(expr)
   | `VBitT%`(expr)
   | `StackT%%`(type, expr)
   | `ListT%`(type)
   | `TupleT%`(type*)
   | `NameT%`(name)
   | `SpecT%%`(name, type*)
   | `AnyT`()

;; ../../../../spec/1a-syntax-el.watsup:123.17-123.19
syntax tparam = id

;; ../../../../spec/1a-syntax-el.watsup:129.16-129.33
syntax param = 
   | `%%%%`(id, dir, type, expr?)

;; ../../../../spec/1a-syntax-el.watsup:135.17-135.22
syntax cparam = param

;; ../../../../spec/1a-syntax-el.watsup:141.15-141.19
syntax targ = type

;; ../../../../spec/1a-syntax-el.watsup:148.1-150.33
syntax arg = 
   | `ExprA%`(expr)
   | `NameA%%`(id, expr?)
   | `AnyA`()

;; ../../../../spec/1a-syntax-el.watsup:157.1-159.29
syntax keyset = 
   | `ExprK%`(expr)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec/1a-syntax-el.watsup:165.21-165.39
syntax selectcase = 
   | `%%`(keyset*, statelabel)

;; ../../../../spec/1a-syntax-el.watsup:173.1-198.108
syntax expr = 
   | `BoolE%`(bool)
   | `StrE%`(text)
   | `NumE%`(num)
   | `NameE%`(name)
   | `SeqE%`(expr*)
   | `SeqDefaultE%`(expr*)
   | `RecordE%`((member, expr)*)
   | `RecordDefaultE%`((member, expr)*)
   | `DefaultE`()
   | `InvalidE`()
   | `UnE%%`(unop, expr)
   | `BinE%%%`(binop, expr, expr)
   | `TernE%%%`(expr, expr, expr)
   | `CastE%%`(type, expr)
   | `MaskE%%`(expr, expr)
   | `RangeE%%`(expr, expr)
   | `SelectE%%`(expr*, selectcase*)
   | `ArrAccE%%`(expr, expr)
   | `BitAccE%%%`(expr, expr, expr)
   | `ErrAccE%`(member)
   | `TypeAccE%%`(name, member)
   | `ExprAccE%%`(expr, member)
   | `CallFuncE%%%`(name, targ*, arg*)
   | `CallMethodE%%%%`(expr, member, targ*, arg*)
   | `CallTypeE%%%%`(name, member, targ*, arg*)
   | `InstE%%%`(name, targ*, arg*)

;; ../../../../spec/1a-syntax-el.watsup:204.16-204.71
syntax block = 
   | `BlockB%`(stmt*)

;; ../../../../spec/1a-syntax-el.watsup:211.1-222.55
syntax stmt = 
   | `EmptyS`()
   | `AssignS%%`(expr, expr)
   | `SwitchS%%`(expr, switchcase*)
   | `IfS%%%`(expr, stmt, stmt)
   | `BlockS%`(block)
   | `ExitS`()
   | `RetS%`(expr?)
   | `CallFuncS%%%`(name, targ*, arg*)
   | `CallMethodS%%%%`(expr, member, targ*, arg*)
   | `CallInstS%%%`(name, targ*, arg*)
   | `TransS%`(expr)
   | `DeclS%`(decl)

;; ../../../../spec/1a-syntax-el.watsup:229.1-230.35
syntax switchlabel = 
   | `ExprL%`(expr)
   | `DefaultL`()

;; ../../../../spec/1a-syntax-el.watsup:233.1-234.48
syntax switchcase = 
   | `MatchC%%`(switchlabel, block)
   | `FallC%`(switchlabel)

;; ../../../../spec/1a-syntax-el.watsup:240.22-240.38
syntax parserstate = 
   | `%%`(statelabel, block)

;; ../../../../spec/1a-syntax-el.watsup:246.14-246.22
syntax tbl = tblprop*

;; ../../../../spec/1a-syntax-el.watsup:252.17-252.31
syntax tblkey = 
   | `%%`(expr, matchkind)

;; ../../../../spec/1a-syntax-el.watsup:253.21-253.28
syntax tblkeyprop = tblkey*

;; ../../../../spec/1a-syntax-el.watsup:259.20-259.29
syntax tblaction = 
   | `%%`(name, arg*)

;; ../../../../spec/1a-syntax-el.watsup:260.24-260.34
syntax tblactionprop = tblaction*

;; ../../../../spec/1a-syntax-el.watsup:266.19-266.47
syntax tblentry = 
   | `%%%%`(bool, keyset*, tblaction, expr?)

;; ../../../../spec/1a-syntax-el.watsup:267.23-267.37
syntax tblentryprop = 
   | `%%`(bool, tblentry*)

;; ../../../../spec/1a-syntax-el.watsup:273.25-273.39
syntax tbldefaultprop = 
   | `%%`(bool, tblaction)

;; ../../../../spec/1a-syntax-el.watsup:279.24-279.40
syntax tblcustomprop = 
   | `%%%`(bool, member, expr)

;; ../../../../spec/1a-syntax-el.watsup:286.1-290.78
syntax tblprop = 
   | `KeyP%`(tblkeyprop)
   | `ActionP%`(tblactionprop)
   | `EntryP%`(tblentryprop)
   | `DefaultP%`(tbldefaultprop)
   | `CustomP%`(tblcustomprop)

;; ../../../../spec/1a-syntax-el.watsup:297.1-299.120
syntax method = 
   | `ExternConsM%%`(id, cparam*)
   | `ExternAbstractM%%%%`(id, type, tparam*, param*)
   | `ExternM%%%%`(id, type, tparam*, param*)

;; ../../../../spec/1a-syntax-el.watsup:308.1-330.136
syntax decl = 
   | `ConstD%%%`(id, type, expr)
   | `VarD%%%`(id, type, expr?)
   | `ErrD%`(member*)
   | `MatchKindD%`(member*)
   | `InstD%%%%%`(id, name, targ*, arg*, decl*)
   | `StructD%%%`(id, tparam*, (member, type)*)
   | `HeaderD%%%`(id, tparam*, (member, type)*)
   | `UnionD%%%`(id, tparam*, (member, type)*)
   | `EnumD%%`(id, member*)
   | `SEnumD%%%`(id, type, (member, expr)*)
   | `NewTypeD%%`(id, typedef)
   | `TypeDefD%%`(id, typedef)
   | `ValueSetD%%%`(id, type, expr)
   | `ParserTypeD%%%`(id, tparam*, param*)
   | `ParserD%%%%%`(id, param*, cparam*, decl*, parserstate*)
   | `TableD%%`(id, tbl)
   | `ControlTypeD%%%`(id, tparam*, param*)
   | `ControlD%%%%%`(id, param*, cparam*, decl*, block)
   | `ActionD%%%`(id, param*, block)
   | `FuncD%%%%%`(id, type, tparam*, param*, block)
   | `ExternFuncD%%%%`(id, type, tparam*, param*)
   | `ExternObjectD%%%`(id, tparam*, method*)
   | `PackageTypeD%%%`(id, tparam*, cparam*)

;; ../../../../spec/1a-syntax-el.watsup:333.1-334.15
syntax typedef = 
   | `TypeD%`(type)
   | `DeclD%`(decl)

;; ../../../../spec/1a-syntax-el.watsup:340.18-340.23
syntax program = decl*

;; ../../../../spec/1b-syntax-el-aux.watsup:5.1-6.27
def $is_boole(expr')

1. If (expr' matches pattern `BoolE%`), then

  1. Let (BoolE _bool) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:11.1-12.26
def $is_stre(expr')

1. If (expr' matches pattern `StrE%`), then

  1. Let (StrE _text) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:17.1-18.26
def $is_nume(expr')

1. If (expr' matches pattern `NumE%`), then

  1. Let (NumE _num) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:23.1-24.27
def $is_namee(expr')

1. If (expr' matches pattern `NameE%`), then

  1. Let (NameE _name) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:29.1-30.26
def $is_seqe(expr')

1. If (expr' matches pattern `SeqE%`), then

  1. Let (SeqE _expr*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:35.1-36.34
def $is_seq_defaulte(expr')

1. If (expr' matches pattern `SeqDefaultE%`), then

  1. Let (SeqDefaultE _expr*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:41.1-42.29
def $is_recorde(expr')

1. If (expr' matches pattern `RecordE%`), then

  1. Let (RecordE _(member, expr)*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:47.1-48.37
def $is_record_defaulte(expr')

1. If (expr' matches pattern `RecordDefaultE%`), then

  1. Let (RecordDefaultE _(member, expr)*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:53.1-54.30
def $is_defaulte(expr')

1. If (expr' matches pattern `DefaultE`), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:59.1-60.30
def $is_invalide(expr')

1. If (expr' matches pattern `InvalidE`), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:65.1-66.25
def $is_une(expr')

1. If (expr' matches pattern `UnE%%`), then

  1. Let (UnE _unop _expr) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:71.1-72.26
def $is_bine(expr')

1. If (expr' matches pattern `BinE%%%`), then

  1. Let (BinE _binop _expr _expr') be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:77.1-78.27
def $is_terne(expr')

1. If (expr' matches pattern `TernE%%%`), then

  1. Let (TernE _expr _expr' _expr'') be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:83.1-84.27
def $is_caste(expr')

1. If (expr' matches pattern `CastE%%`), then

  1. Let (CastE _type _expr) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:89.1-90.27
def $is_maske(expr')

1. If (expr' matches pattern `MaskE%%`), then

  1. Let (MaskE _expr _expr') be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:95.1-96.28
def $is_rangee(expr')

1. If (expr' matches pattern `RangeE%%`), then

  1. Let (RangeE _expr _expr') be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:101.1-102.29
def $is_selecte(expr')

1. If (expr' matches pattern `SelectE%%`), then

  1. Let (SelectE _expr* _selectcase*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:107.1-108.29
def $is_arracce(expr')

1. If (expr' matches pattern `ArrAccE%%`), then

  1. Let (ArrAccE _expr _expr') be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:113.1-114.29
def $is_bitacce(expr')

1. If (expr' matches pattern `BitAccE%%%`), then

  1. Let (BitAccE _expr _expr' _expr'') be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:119.1-120.29
def $is_erracce(expr')

1. If (expr' matches pattern `ErrAccE%`), then

  1. Let (ErrAccE _member) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:125.1-126.30
def $is_typacce(expr')

1. If (expr' matches pattern `TypeAccE%%`), then

  1. Let (TypeAccE _name _member) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:131.1-132.30
def $is_expracce(expr')

1. If (expr' matches pattern `ExprAccE%%`), then

  1. Let (ExprAccE _expr _member) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:137.1-138.31
def $is_callfunce(expr')

1. If (expr' matches pattern `CallFuncE%%%`), then

  1. Let (CallFuncE _name _targ* _arg*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:143.1-144.33
def $is_callmethode(expr')

1. If (expr' matches pattern `CallMethodE%%%%`), then

  1. Let (CallMethodE _expr _member _targ* _arg*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:149.1-150.31
def $is_calltype(expr')

1. If (expr' matches pattern `CallTypeE%%%%`), then

  1. Let (CallTypeE _name _member _targ* _arg*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:155.1-156.27
def $is_inste(expr')

1. If (expr' matches pattern `InstE%%%`), then

  1. Let (InstE _name _targ* _arg*) be expr'

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/1b-syntax-el-aux.watsup:165.1-166.17
def $string_of_name(name)

1. If (name matches pattern `TOP%`), then

  1. Let (TOP id) be name

  2. Return $concat_text("." :: [id])

1. Else If (name matches pattern `CURRENT%`), then

  1. Let (CURRENT id) be name

  2. Return id

;; ../../../../spec/1b-syntax-el-aux.watsup:175.1-176.17
def $id_of_name(name)

1. If (name matches pattern `TOP%`), then

  1. Let (TOP id) be name

  2. Return id

1. Else If (name matches pattern `CURRENT%`), then

  1. Let (CURRENT id) be name

  2. Return id

;; ../../../../spec/2a-runtime-domain.watsup:10.14-10.16
syntax tid = id

;; ../../../../spec/2a-runtime-domain.watsup:11.51-11.59
syntax tidset = set<tid>

;; ../../../../spec/2a-runtime-domain.watsup:13.1-14.27
def $fresh_tid



;; ../../../../spec/2a-runtime-domain.watsup:16.1-17.28
def $fresh_tids(nat')

1. If (nat' = 0), then

  1. Return []

2. Otherwise

  1. Return $fresh_tid :: $fresh_tids((nat' - 1))

;; ../../../../spec/2a-runtime-domain.watsup:29.14-29.28
syntax fid = 
   | `%%`(id, (id, bool)*)

;; ../../../../spec/2a-runtime-domain.watsup:30.14-30.17
syntax cid = fid

;; ../../../../spec/2a-runtime-domain.watsup:34.1-34.30
def $to_fid(id, param*)

1. Return (id $to_fid'(param*))

;; ../../../../spec/2a-runtime-domain.watsup:35.1-35.35
def $to_fid'(param*)

1. If (param* matches pattern []), then

  1. Return []

1. Else If (param* matches pattern _ :: _), then

  1. Let param_h :: param_t* be param*

  2. Let (id dir type expr?) be param_h

  3. If (expr? matches pattern (_)), then

    1. Let ?(expr) be expr?

    2. Return (id, true) :: $to_fid'(param_t*)

  3. Else If (expr? matches pattern ()), then

    1. Return (id, false) :: $to_fid'(param_t*)

;; ../../../../spec/2a-runtime-domain.watsup:46.1-46.30
def $to_cid(id, param*)

1. Return $to_fid(id, param*)

;; ../../../../spec/2a-runtime-domain.watsup:54.14-54.17
syntax oid = id*

;; ../../../../spec/2b1-runtime-bitstr.watsup:5.17-5.20
syntax bitstr = int

;; ../../../../spec/2b1-runtime-bitstr.watsup:10.1-10.31
def $to_int



;; ../../../../spec/2b1-runtime-bitstr.watsup:14.1-14.34
def $to_bitstr



;; ../../../../spec/2b2-runtime-value.watsup:9.1-37.57
syntax val = 
   | `ErrV%`(member)
   | `MatchKindV%`(member)
   | `StrV%`(text)
   | `BoolV%`(bool)
   | `IntV%`(int)
   | `FIntV%%`(width, bitstr)
   | `FBitV%%`(width, bitstr)
   | `VBitV%%%`(width, width, bitstr)
   | `EnumFieldV%%`(id, member)
   | `SEnumFieldV%%%`(id, member, val)
   | `ListV%`(val*)
   | `TupleV%`(val*)
   | `StackV%%%`(val*, int, int)
   | `StructV%%`(id, (member, val)*)
   | `HeaderV%%`(id, (member, val)*)
   | `UnionV%%`(id, (member, val)*)
   | `RefV%`(oid)
   | `TableEnumFieldV%%`(id, member)
   | `TableStructV%%`(id, (member, val)*)
   | `SeqV%`(val*)
   | `SeqDefaultV%`(val*)
   | `RecordV%`((member, val)*)
   | `RecordDefaultV%`((member, val)*)
   | `DefaultV`()
   | `InvalidV`()
   | `SetV%`(setval)

;; ../../../../spec/2b2-runtime-value.watsup:40.1-42.83
syntax setval = 
   | `SingletonSet%`(val)
   | `MaskSet%%`(val, val)
   | `RangeSet%%`(val, val)

;; ../../../../spec/2b3-runtime-value-aux.watsup:3.1-3.24
def $get_num(val)

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i) be val

  2. Return i

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs) be val

  2. Return $to_int((w as int), bs)

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV _width bs) be val

  2. Return bs

1. Else If (val matches pattern `VBitV%%%`), then

  1. Let (VBitV _width _width' bs) be val

  2. Return bs

1. Else

  1. Phantom#0

;; ../../../../spec/2c1-runtime-type.watsup:12.3-12.18
syntax paramtyp = 
   | `%%%%`(id, dir, typ, val?)

;; ../../../../spec/2c1-runtime-type.watsup:25.1-29.38
syntax primtyp = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()

;; ../../../../spec/2c1-runtime-type.watsup:32.1-35.78
syntax numtyp = 
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)

;; ../../../../spec/2c1-runtime-type.watsup:38.1-38.21
syntax basetyp = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)

;; ../../../../spec/2c1-runtime-type.watsup:45.1-46.98
syntax abstyp = 
   | `VarT%`(id)
   | `SpecT%%`(polytypdef, typ*)

;; ../../../../spec/2c1-runtime-type.watsup:53.1-53.57
syntax aliastyp = 
   | `DefT%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:56.1-64.89
syntax datatyp = 
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)

;; ../../../../spec/2c1-runtime-type.watsup:67.1-71.59
syntax objtyp = 
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:74.1-74.32
syntax deftyp = 
   | `DefT%`(typ)
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)

;; ../../../../spec/2c1-runtime-type.watsup:81.1-91.55
syntax synthtyp = 
   | `DefaultT`()
   | `SeqT%`(typ*)
   | `SeqDefaultT%`(typ*)
   | `RecordT%`((member, typ)*)
   | `RecordDefaultT%`((member, typ)*)
   | `InvalidT`()
   | `SetT%`(typ)
   | `StateT`()
   | `TableEnumT%%`(id, member*)
   | `TableStructT%%`(id, (member, typ)*)
   | `AnyT`()

;; ../../../../spec/2c1-runtime-type.watsup:94.1-94.41
syntax typ = 
   | `VoidT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `BoolT`()
   | `IntT`()
   | `FIntT%`(width)
   | `FBitT%`(width)
   | `VBitT%`(width)
   | `VarT%`(id)
   | `SpecT%%`(polytypdef, typ*)
   | `DefT%`(typ)
   | `NewT%%`(id, typ)
   | `EnumT%%`(id, member*)
   | `SEnumT%%%`(id, typ, (member, val)*)
   | `ListT%`(typ)
   | `TupleT%`(typ*)
   | `StackT%%`(typ, int)
   | `StructT%%`(id, (member, typ)*)
   | `HeaderT%%`(id, (member, typ)*)
   | `UnionT%%`(id, (member, typ)*)
   | `ExternT%%`(id, map<fid, funcdef>)
   | `ParserT%`(paramtyp*)
   | `ControlT%`(paramtyp*)
   | `PackageT%`(typ*)
   | `TableT%%`(id, typ)
   | `DefaultT`()
   | `SeqT%`(typ*)
   | `SeqDefaultT%`(typ*)
   | `RecordT%`((member, typ)*)
   | `RecordDefaultT%`((member, typ)*)
   | `InvalidT`()
   | `SetT%`(typ)
   | `StateT`()
   | `TableEnumT%%`(id, member*)
   | `TableStructT%%`(id, (member, typ)*)
   | `AnyT`()

;; ../../../../spec/2c1-runtime-type.watsup:101.3-101.12
syntax monotypdef = 
   | `MonoD%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:103.3-103.34
syntax polytypdef = 
   | `PolyD%->%`((tparam*, tparam*), typ)

;; ../../../../spec/2c1-runtime-type.watsup:106.1-107.15
syntax typdef = 
   | `MonoD%`(typ)
   | `PolyD%->%`((tparam*, tparam*), typ)

;; ../../../../spec/2c1-runtime-type.watsup:118.1-126.82
syntax functyp = 
   | `ActionT%`(paramtyp*)
   | `ExternFuncT%%`(paramtyp*, typ)
   | `FuncT%%`(paramtyp*, typ)
   | `BuiltinMethodT%%`(paramtyp*, typ)
   | `ExternMethodT%%`(paramtyp*, typ)
   | `ExternAbstractMethodT%%`(paramtyp*, typ)
   | `ParserApplyMethodT%`(paramtyp*)
   | `ControlApplyMethodT%`(paramtyp*)
   | `TableApplyMethodT%`(typ)

;; ../../../../spec/2c1-runtime-type.watsup:135.3-135.65
syntax monofuncdef = 
   | `MonoFD%`(functyp)

;; ../../../../spec/2c1-runtime-type.watsup:138.3-138.69
syntax polyfuncdef = 
   | `PolyFD%->%`((tparam*, tparam*), functyp)

;; ../../../../spec/2c1-runtime-type.watsup:141.1-142.16
syntax funcdef = 
   | `MonoFD%`(functyp)
   | `PolyFD%->%`((tparam*, tparam*), functyp)

;; ../../../../spec/2c1-runtime-type.watsup:155.3-155.52
syntax constyp = 
   | `ConsT%%`(paramtyp*, typ)

;; ../../../../spec/2c1-runtime-type.watsup:164.3-164.38
syntax consdef = 
   | `ConsD%->%`((tparam*, tparam*), constyp)

;; ../../../../spec/2c2-runtime-type-aux.watsup:7.1-8.30
def $is_base(typ)

1. If (typ has type basetyp), then

  1. Let basetyp be (typ as basetyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:13.1-14.35
def $is_prim(typ)

1. If (typ has type primtyp), then

  1. Let primtyp be (typ as primtyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:19.1-20.27
def $is_voidt(typ)

1. If (typ = ((VoidT) as typ)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:25.1-26.26
def $is_errt(typ)

1. If (typ = ((ErrT) as typ)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:31.1-32.33
def $is_matchkindt(typ)

1. If (typ = ((MatchKindT) as typ)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:37.1-38.26
def $is_strt(typ)

1. If (typ = ((StrT) as typ)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:43.1-44.27
def $is_boolt(typ)

1. If (typ = ((BoolT) as typ)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:49.1-50.33
def $is_num(typ)

1. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:55.1-56.24
def $is_intt(typ)

1. If (typ = ((IntT) as typ)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:61.1-62.25
def $is_fintt(typ)

1. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:67.1-68.27
def $is_fbitt(typ)

1. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:73.1-74.27
def $is_vbitt(typ)

1. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `VBitT%`), then

    1. Let (VBitT _width) be numtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:79.1-80.34
def $is_abstract(typ)

1. If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:85.1-86.26
def $is_vart(typ)

1. If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:91.1-92.27
def $is_spect(typ)

1. If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `SpecT%%`), then

    1. Let (SpecT _polytypdef _typ*) be abstyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:97.1-98.33
def $is_def(typ)

1. If (typ has type deftyp), then

  1. Let deftyp be (typ as deftyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:103.1-104.31
def $is_alias(typ)

1. If (typ has type aliastyp), then

  1. Let aliastyp be (typ as aliastyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:109.1-110.26
def $is_deft(typ)

1. If (typ has type aliastyp), then

  1. Let (DefT _typ) be (typ as aliastyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:115.1-116.30
def $is_data(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:121.1-122.26
def $is_newt(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:127.1-128.27
def $is_enumt(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id _member*) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:133.1-134.28
def $is_senumt(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id _typ _(member, val)*) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:139.1-140.27
def $is_listt(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `ListT%`), then

    1. Let (ListT _typ) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:145.1-146.28
def $is_tuplet(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT _typ*) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:151.1-152.28
def $is_stackt(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT _typ _int) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:157.1-158.29
def $is_structt(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id _(member, typ)*) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:163.1-164.29
def $is_headert(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id _(member, typ)*) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:169.1-170.28
def $is_uniont(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id _(member, typ)*) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:175.1-176.32
def $is_obj(typ)

1. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:181.1-182.29
def $is_externt(typ)

1. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT _id _map<fid, funcdef>) be objtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:187.1-188.29
def $is_parsert(typ)

1. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `ParserT%`), then

    1. Let (ParserT _paramtyp*) be objtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:193.1-194.30
def $is_controlt(typ)

1. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `ControlT%`), then

    1. Let (ControlT _paramtyp*) be objtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:199.1-200.30
def $is_packaget(typ)

1. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `PackageT%`), then

    1. Let (PackageT _typ*) be objtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:205.1-206.28
def $is_tablet(typ)

1. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `TableT%%`), then

    1. Let (TableT _id _typ) be objtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:211.1-212.37
def $is_synth(typ)

1. If (typ has type synthtyp), then

  1. Let synthtyp be (typ as synthtyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:217.1-218.26
def $is_seqt(typ)

1. If (typ has type synthtyp), then

  1. Let synthtyp be (typ as synthtyp)

  2. If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT _typ*) be synthtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:223.1-224.29
def $is_recordt(typ)

1. If (typ has type synthtyp), then

  1. Let synthtyp be (typ as synthtyp)

  2. If (synthtyp matches pattern `RecordT%`), then

    1. Let (RecordT _(member, typ)*) be synthtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:229.1-230.26
def $is_sett(typ)

1. If (typ has type synthtyp), then

  1. Let synthtyp be (typ as synthtyp)

  2. If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT _typ) be synthtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:235.1-236.35
def $is_table_structt(typ)

1. If (typ has type synthtyp), then

  1. Let synthtyp be (typ as synthtyp)

  2. If (synthtyp matches pattern `TableStructT%%`), then

    1. Let (TableStructT _id _(member, typ)*) be synthtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:247.1-248.29
def $is_actiont(functyp)

1. If (functyp matches pattern `ActionT%`), then

  1. Let (ActionT _paramtyp*) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:253.1-254.34
def $is_externfunct(functyp)

1. If (functyp matches pattern `ExternFuncT%%`), then

  1. Let (ExternFuncT _paramtyp* _typ) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:259.1-260.27
def $is_funct(functyp)

1. If (functyp matches pattern `FuncT%%`), then

  1. Let (FuncT _paramtyp* _typ) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:265.1-266.37
def $is_builtinmethodt(functyp)

1. If (functyp matches pattern `BuiltinMethodT%%`), then

  1. Let (BuiltinMethodT _paramtyp* _typ) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:271.1-272.36
def $is_externmethodt(functyp)

1. If (functyp matches pattern `ExternMethodT%%`), then

  1. Let (ExternMethodT _paramtyp* _typ) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:277.1-278.45
def $is_externabstractmethodt(functyp)

1. If (functyp matches pattern `ExternAbstractMethodT%%`), then

  1. Let (ExternAbstractMethodT _paramtyp* _typ) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:283.1-284.42
def $is_parserapplymethodt(functyp)

1. If (functyp matches pattern `ParserApplyMethodT%`), then

  1. Let (ParserApplyMethodT _paramtyp*) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:289.1-290.43
def $is_controlapplymethodt(functyp)

1. If (functyp matches pattern `ControlApplyMethodT%`), then

  1. Let (ControlApplyMethodT _paramtyp*) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:295.1-296.41
def $is_tableapplymethodt(functyp)

1. If (functyp matches pattern `TableApplyMethodT%`), then

  1. Let (TableApplyMethodT _typ) be functyp

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c2-runtime-type-aux.watsup:303.1-304.38
def $get_params_functyp(functyp)

1. If (functyp matches pattern `ActionT%`), then

  1. Let (ActionT pt*) be functyp

  2. Return pt*

1. Else If (functyp matches pattern `ExternFuncT%%`), then

  1. Let (ExternFuncT pt* _typ) be functyp

  2. Return pt*

1. Else If (functyp matches pattern `FuncT%%`), then

  1. Let (FuncT pt* _typ) be functyp

  2. Return pt*

1. Else If (functyp matches pattern `ExternMethodT%%`), then

  1. Let (ExternMethodT pt* _typ) be functyp

  2. Return pt*

1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

  1. Let (ExternAbstractMethodT pt* _typ) be functyp

  2. Return pt*

1. Else If (functyp matches pattern `ParserApplyMethodT%`), then

  1. Let (ParserApplyMethodT pt*) be functyp

  2. Return pt*

1. Else If (functyp matches pattern `ControlApplyMethodT%`), then

  1. Let (ControlApplyMethodT pt*) be functyp

  2. Return pt*

1. Else If (functyp matches pattern `BuiltinMethodT%%`), then

  1. Let (BuiltinMethodT pt* _typ) be functyp

  2. Return pt*

1. Else If (functyp matches pattern `TableApplyMethodT%`), then

  1. Let (TableApplyMethodT _typ) be functyp

  2. Return []

;; ../../../../spec/2c2-runtime-type-aux.watsup:315.1-316.39
def $get_typ_ret_functyp(functyp)

1. If (functyp matches pattern `ActionT%`), then

  1. Let (ActionT _paramtyp*) be functyp

  2. Return ((VoidT) as typ)

1. Else If (functyp matches pattern `ExternFuncT%%`), then

  1. Let (ExternFuncT _paramtyp* typ_r) be functyp

  2. Return typ_r

1. Else If (functyp matches pattern `FuncT%%`), then

  1. Let (FuncT _paramtyp* typ_r) be functyp

  2. Return typ_r

1. Else If (functyp matches pattern `ExternMethodT%%`), then

  1. Let (ExternMethodT _paramtyp* typ_r) be functyp

  2. Return typ_r

1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

  1. Let (ExternAbstractMethodT _paramtyp* typ_r) be functyp

  2. Return typ_r

1. Else If (functyp matches pattern `ParserApplyMethodT%`), then

  1. Let (ParserApplyMethodT _paramtyp*) be functyp

  2. Return ((VoidT) as typ)

1. Else If (functyp matches pattern `ControlApplyMethodT%`), then

  1. Let (ControlApplyMethodT _paramtyp*) be functyp

  2. Return ((VoidT) as typ)

1. Else If (functyp matches pattern `BuiltinMethodT%%`), then

  1. Let (BuiltinMethodT _paramtyp* typ_r) be functyp

  2. Return typ_r

1. Else If (functyp matches pattern `TableApplyMethodT%`), then

  1. Let (TableApplyMethodT typ_r) be functyp

  2. Return typ_r

;; ../../../../spec/2c2-runtime-type-aux.watsup:333.1-334.38
def $get_params_funcdef(funcdef)

1. If (funcdef has type monofuncdef), then

  1. Let (MonoFD ft) be (funcdef as monofuncdef)

  2. Return $get_params_functyp(ft)

1. Else If (funcdef has type polyfuncdef), then

  1. Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef)

  2. Return $get_params_functyp(ft)

;; ../../../../spec/2c2-runtime-type-aux.watsup:338.1-339.39
def $get_typ_ret_funcdef(funcdef)

1. If (funcdef has type monofuncdef), then

  1. Let (MonoFD ft) be (funcdef as monofuncdef)

  2. Return $get_typ_ret_functyp(ft)

1. Else If (funcdef has type polyfuncdef), then

  1. Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef)

  2. Return $get_typ_ret_functyp(ft)

;; ../../../../spec/2c3-runtime-type-subst.watsup:5.45-5.57
syntax theta = map<id, typ>

;; ../../../../spec/2c3-runtime-type-subst.watsup:7.1-8.44
def $free_typ(typ'')

1. If (typ'' has type basetyp), then

  1. Let basetyp be (typ'' as basetyp)

  2. Return ({ [] })

1. Else If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT id) be abstyp

    2. Return ({ [id] })

  2. Else If (abstyp matches pattern `SpecT%%`), then

    1. Let (SpecT ptd typ''*) be abstyp

    2. Let tidset_ptd be $free_typdef_poly(ptd)

    3. Let tidset_typs be $unions_set<tid>($free_typ(typ'')*)

    4. Return $union_set<tid>(tidset_ptd, tidset_typs)

1. Else If (typ'' has type aliastyp), then

  1. Let (DefT typ'') be (typ'' as aliastyp)

  2. Return $free_typ(typ'')

1. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $free_typ(typ'')

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id _member*) be datatyp

    2. Return ({ [] })

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id typ'' _(member, val)*) be datatyp

    2. Return $free_typ(typ'')

  2. Else If (datatyp matches pattern `ListT%`), then

    1. Let (ListT typ'') be datatyp

    2. Return $free_typ(typ'')

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ'' _int) be datatyp

    2. Return $free_typ(typ'')

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id (_member, typ'')*) be datatyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id (_member, typ'')*) be datatyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id (_member, typ'')*) be datatyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

1. Else If (typ'' has type objtyp), then

  1. Let objtyp be (typ'' as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT _id ({ (_fid -> fd)* })) be objtyp

    2. Return $unions_set<tid>($free_funcdef(fd)*)

  2. Else If (objtyp matches pattern `ParserT%`), then

    1. Let (ParserT pt*) be objtyp

    2. (Let (_id _dir typ'' _val?) be pt)*

    3. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (objtyp matches pattern `ControlT%`), then

    1. Let (ControlT pt*) be objtyp

    2. (Let (_id _dir typ'' _val?) be pt)*

    3. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (objtyp matches pattern `PackageT%`), then

    1. Let (PackageT typ''*) be objtyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (objtyp matches pattern `TableT%%`), then

    1. Let (TableT _id typ'') be objtyp

    2. Return $free_typ(typ'')

1. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT typ''*) be synthtyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (synthtyp matches pattern `SeqDefaultT%`), then

    1. Let (SeqDefaultT typ''*) be synthtyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (synthtyp matches pattern `RecordT%`), then

    1. Let (RecordT (_member, typ'')*) be synthtyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (synthtyp matches pattern `RecordDefaultT%`), then

    1. Let (RecordDefaultT (_member, typ'')*) be synthtyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ'') be synthtyp

    2. Return $free_typ(typ'')

  2. Else If (synthtyp matches pattern `TableEnumT%%`), then

    1. Let (TableEnumT _id _member*) be synthtyp

    2. Return ({ [] })

  2. Else If (synthtyp matches pattern `TableStructT%%`), then

    1. Let (TableStructT _id (_member, typ'')*) be synthtyp

    2. Return $unions_set<tid>($free_typ(typ'')*)

  2. Else

    1. Phantom#1

2. If (typ'' = ((DefaultT) as typ)), then

  1. Return ({ [] })

2. Else

  1. Phantom#2

3. If (typ'' = ((InvalidT) as typ)), then

  1. Return ({ [] })

3. Else

  1. Phantom#3

4. If (typ'' = ((StateT) as typ)), then

  1. Return ({ [] })

4. Else

  1. Phantom#4

5. If (typ'' = ((AnyT) as typ)), then

  1. Return ({ [] })

5. Else

  1. Phantom#5

;; ../../../../spec/2c3-runtime-type-subst.watsup:9.1-10.44
def $free_typdef_poly((PolyD (tparam*, tparam_hidden*) -> typ))

1. Let tidset_typ be $free_typ(typ)

2. Let tidset_tparams be ({ tparam* ++ tparam_hidden* })

3. Return $diff_set<tid>(tidset_typ, tidset_tparams)

;; ../../../../spec/2c3-runtime-type-subst.watsup:11.1-12.44
def $free_functyp(functyp)

1. If (functyp matches pattern `ActionT%`), then

  1. Let (ActionT pt*) be functyp

  2. (Let (_id _dir typ _val?) be pt)*

  3. Return $unions_set<tid>($free_typ(typ)*)

1. Else If (functyp matches pattern `ExternFuncT%%`), then

  1. Let (ExternFuncT pt* typ_r) be functyp

  2. (Let (_id _dir typ_p _val?) be pt)*

  3. Let tidset_params be $unions_set<tid>($free_typ(typ_p)*)

  4. Let tidset_return be $free_typ(typ_r)

  5. Return $union_set<tid>(tidset_params, tidset_return)

1. Else If (functyp matches pattern `FuncT%%`), then

  1. Let (FuncT pt* typ_r) be functyp

  2. (Let (_id _dir typ_p _val?) be pt)*

  3. Let tidset_params be $unions_set<tid>($free_typ(typ_p)*)

  4. Let tidset_return be $free_typ(typ_r)

  5. Return $union_set<tid>(tidset_params, tidset_return)

1. Else If (functyp matches pattern `BuiltinMethodT%%`), then

  1. Let (BuiltinMethodT pt* typ_r) be functyp

  2. (Let (_id _dir typ_p _val?) be pt)*

  3. Let tidset_params be $unions_set<tid>($free_typ(typ_p)*)

  4. Let tidset_return be $free_typ(typ_r)

  5. Return $union_set<tid>(tidset_params, tidset_return)

1. Else If (functyp matches pattern `ExternMethodT%%`), then

  1. Let (ExternMethodT pt* typ_r) be functyp

  2. (Let (_id _dir typ_p _val?) be pt)*

  3. Let tidset_params be $unions_set<tid>($free_typ(typ_p)*)

  4. Let tidset_return be $free_typ(typ_r)

  5. Return $union_set<tid>(tidset_params, tidset_return)

1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

  1. Let (ExternAbstractMethodT pt* typ_r) be functyp

  2. (Let (_id _dir typ_p _val?) be pt)*

  3. Let tidset_params be $unions_set<tid>($free_typ(typ_p)*)

  4. Let tidset_return be $free_typ(typ_r)

  5. Return $union_set<tid>(tidset_params, tidset_return)

1. Else If (functyp matches pattern `ParserApplyMethodT%`), then

  1. Let (ParserApplyMethodT pt*) be functyp

  2. (Let (_id _dir typ _val?) be pt)*

  3. Return $unions_set<tid>($free_typ(typ)*)

1. Else If (functyp matches pattern `ControlApplyMethodT%`), then

  1. Let (ControlApplyMethodT pt*) be functyp

  2. (Let (_id _dir typ _val?) be pt)*

  3. Return $unions_set<tid>($free_typ(typ)*)

1. Else If (functyp matches pattern `TableApplyMethodT%`), then

  1. Let (TableApplyMethodT typ) be functyp

  2. Return $free_typ(typ)

;; ../../../../spec/2c3-runtime-type-subst.watsup:13.1-14.44
def $free_funcdef(funcdef)

1. If (funcdef has type monofuncdef), then

  1. Let (MonoFD ft) be (funcdef as monofuncdef)

  2. Return $free_functyp(ft)

1. Else If (funcdef has type polyfuncdef), then

  1. Let (PolyFD (tparam*, tparam_hidden*) -> ft) be (funcdef as polyfuncdef)

  2. Let tidset_ft be $free_functyp(ft)

  3. Let tidset_tparams be ({ tparam* ++ tparam_hidden* })

  4. Return $diff_set<tid>(tidset_ft, tidset_tparams)

;; ../../../../spec/2c3-runtime-type-subst.watsup:16.1-17.33
def $subst_typ(theta, typ''')

1. If (typ''' has type abstyp), then

  1. Let abstyp be (typ''' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT id) be abstyp

    2. If $in_set<id>(id, $dom_map<id, typ>(theta)), then

      1. Let typ? be $find_map<id, typ>(theta, id)

      2. If (typ? matches pattern (_)), then

        1. Let ?(typ) be typ?

        2. Return typ

  2. Else If (abstyp matches pattern `SpecT%%`), then

    1. Let (SpecT ptd typ*) be abstyp

    2. Let ptd' be $subst_typdef_poly(theta, ptd)

    3. Let typ'''* be $subst_typ(theta, typ)*

    4. Return ((SpecT ptd' typ'''*) as typ)

1. Else If (typ''' has type aliastyp), then

  1. Let (DefT typ) be (typ''' as aliastyp)

  2. Return $subst_typ(theta, typ)

1. Else If (typ''' has type datatyp), then

  1. Let datatyp be (typ''' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT id typ) be datatyp

    2. Return ((NewT id $subst_typ(theta, typ)) as typ)

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT id typ (member, val)*) be datatyp

    2. Return ((SEnumT id $subst_typ(theta, typ) (member, val)*) as typ)

  2. Else If (datatyp matches pattern `ListT%`), then

    1. Let (ListT typ) be datatyp

    2. Return ((ListT $subst_typ(theta, typ)) as typ)

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ*) be datatyp

    2. Return ((TupleT $subst_typ(theta, typ)*) as typ)

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ int) be datatyp

    2. Return ((StackT $subst_typ(theta, typ) int) as typ)

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT id (member, typ)*) be datatyp

    2. Return ((StructT id (member, $subst_typ(theta, typ))*) as typ)

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT id (member, typ)*) be datatyp

    2. Return ((HeaderT id (member, $subst_typ(theta, typ))*) as typ)

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT id (member, typ)*) be datatyp

    2. Return ((UnionT id (member, $subst_typ(theta, typ))*) as typ)

1. Else If (typ''' has type objtyp), then

  1. Let objtyp be (typ''' as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT id fmap) be objtyp

    2. Let ({ (fid -> funcdef)* }) be fmap

    3. Let fmap' be ({ (fid -> $subst_funcdef(theta, funcdef))* })

    4. Return ((ExternT id fmap') as typ)

  2. Else If (objtyp matches pattern `ParserT%`), then

    1. Let (ParserT pt*) be objtyp

    2. (Let (id dir typ''' val?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ''') val?))*

    4. Return ((ParserT pt'*) as typ)

  2. Else If (objtyp matches pattern `ControlT%`), then

    1. Let (ControlT pt*) be objtyp

    2. (Let (id dir typ''' val?) be pt)*

    3. (Let pt' be (id dir $subst_typ(theta, typ''') val?))*

    4. Return ((ControlT pt'*) as typ)

  2. Else If (objtyp matches pattern `PackageT%`), then

    1. Let (PackageT typ'''*) be objtyp

    2. Return ((PackageT $subst_typ(theta, typ''')*) as typ)

  2. Else If (objtyp matches pattern `TableT%%`), then

    1. Let (TableT id typ''') be objtyp

    2. Return ((TableT id $subst_typ(theta, typ''')) as typ)

1. Else If (typ''' has type synthtyp), then

  1. Let synthtyp be (typ''' as synthtyp)

  2. If (synthtyp matches pattern `TableStructT%%`), then

    1. Let (TableStructT id (member, typ''')*) be synthtyp

    2. Return ((TableStructT id (member, $subst_typ(theta, typ'''))*) as typ)

  2. Else If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT typ'''*) be synthtyp

    2. Return ((SeqT $subst_typ(theta, typ''')*) as typ)

  2. Else If (synthtyp matches pattern `SeqDefaultT%`), then

    1. Let (SeqDefaultT typ'''*) be synthtyp

    2. Return ((SeqDefaultT $subst_typ(theta, typ''')*) as typ)

  2. Else If (synthtyp matches pattern `RecordT%`), then

    1. Let (RecordT (member, typ''')*) be synthtyp

    2. Return ((RecordT (member, $subst_typ(theta, typ'''))*) as typ)

  2. Else If (synthtyp matches pattern `RecordDefaultT%`), then

    1. Let (RecordDefaultT (member, typ''')*) be synthtyp

    2. Return ((RecordDefaultT (member, $subst_typ(theta, typ'''))*) as typ)

  2. Else If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ''') be synthtyp

    2. Return ((SetT $subst_typ(theta, typ''')) as typ)

2. Otherwise

  1. Return typ'''

;; ../../../../spec/2c3-runtime-type-subst.watsup:18.1-19.33
def $subst_typdef_poly(theta, (PolyD (tparam*, tparam_hidden*) -> typ))

1. Let ({ tid_free* }) be $diff_set<tid>($free_typ(typ), ({ tparam* ++ tparam_hidden* }))

2. (Let typ? be $find_map<tid, typ>(theta, tid_free))*

3. If ((typ? matches pattern (_)))*, then

  1. (Let ?(typ_free) be typ?)*

  2. Let tidset_capture be $unions_set<tid>($free_typ(typ_free)*)

  3. Let tparam'* be $fresh_tids(|tparam* ++ tparam_hidden*|)

  4. If (~$in_set<tid>(tparam', tidset_capture))*, then

    1. Let tparam''* be tparam'*[0 : |tparam*|]

    2. Let tparam''_hidden* be tparam'*[|tparam*| : |tparam_hidden*|]

    3. Let theta' be $adds_map<tid, typ>(theta, tparam*, ((VarT tparam'') as typ)*)

    4. Let theta'' be $adds_map<tid, typ>(theta', tparam_hidden*, ((VarT tparam''_hidden) as typ)*)

    5. Let typ' be $subst_typ(theta'', typ)

    6. Return (PolyD (tparam''*, tparam''_hidden*) -> typ')

  4. Else

    1. Phantom#6

3. Else

  1. Phantom#7

;; ../../../../spec/2c3-runtime-type-subst.watsup:20.1-21.33
def $subst_funcdef(theta, funcdef)

1. If (funcdef has type monofuncdef), then

  1. Let (MonoFD ft) be (funcdef as monofuncdef)

  2. Return ((MonoFD $subst_functyp(theta, ft)) as funcdef)

1. Else If (funcdef has type polyfuncdef), then

  1. Let (PolyFD (tparam*, tparam_hidden*) -> ft) be (funcdef as polyfuncdef)

  2. Let ({ tid_free* }) be $diff_set<tid>($free_functyp(ft), ({ tparam* ++ tparam_hidden* }))

  3. (Let typ? be $find_map<tid, typ>(theta, tid_free))*

  4. If ((typ? matches pattern (_)))*, then

    1. (Let ?(typ_free) be typ?)*

    2. Let tidset_capture be $unions_set<tid>($free_typ(typ_free)*)

    3. Let tparam'* be $fresh_tids(|tparam* ++ tparam_hidden*|)

    4. If (~$in_set<tid>(tparam', tidset_capture))*, then

      1. Let tparam''* be tparam'*[0 : |tparam*|]

      2. Let tparam''_hidden* be tparam'*[|tparam*| : |tparam_hidden*|]

      3. Let theta' be $adds_map<tid, typ>(theta, tparam*, ((VarT tparam') as typ)*)

      4. Let theta'' be $adds_map<tid, typ>(theta', tparam_hidden*, ((VarT tparam''_hidden) as typ)*)

      5. Let ft' be $subst_functyp(theta'', ft)

      6. Return ((PolyFD (tparam''*, tparam''_hidden*) -> ft') as funcdef)

    4. Else

      1. Phantom#8

  4. Else

    1. Phantom#9

;; ../../../../spec/2c3-runtime-type-subst.watsup:22.1-23.33
def $subst_functyp(theta, functyp)

1. If (functyp matches pattern `BuiltinMethodT%%`), then

  1. Let (BuiltinMethodT pt* typ) be functyp

  2. (Let (id dir typ_p val?) be pt)*

  3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?))*

  4. Return (BuiltinMethodT pt'* $subst_typ(theta, typ))

1. Else If (functyp matches pattern `ActionT%`), then

  1. Let (ActionT pt*) be functyp

  2. (Let (id dir typ val?) be pt)*

  3. (Let pt' be (id dir $subst_typ(theta, typ) val?))*

  4. Return (ActionT pt'*)

1. Else If (functyp matches pattern `ParserApplyMethodT%`), then

  1. Let (ParserApplyMethodT pt*) be functyp

  2. (Let (id dir typ val?) be pt)*

  3. (Let pt' be (id dir $subst_typ(theta, typ) val?))*

  4. Return (ParserApplyMethodT pt'*)

1. Else If (functyp matches pattern `ControlApplyMethodT%`), then

  1. Let (ControlApplyMethodT pt*) be functyp

  2. (Let (id dir typ val?) be pt)*

  3. (Let pt' be (id dir $subst_typ(theta, typ) val?))*

  4. Return (ControlApplyMethodT pt'*)

1. Else If (functyp matches pattern `TableApplyMethodT%`), then

  1. Let (TableApplyMethodT typ) be functyp

  2. Return (TableApplyMethodT $subst_typ(theta, typ))

1. Else If (functyp matches pattern `ExternFuncT%%`), then

  1. Let (ExternFuncT pt* typ) be functyp

  2. (Let (id dir typ_p val?) be pt)*

  3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?))*

  4. Return (ExternFuncT pt'* $subst_typ(theta, typ))

1. Else If (functyp matches pattern `FuncT%%`), then

  1. Let (FuncT pt* typ) be functyp

  2. (Let (id dir typ_p val?) be pt)*

  3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?))*

  4. Return (FuncT pt'* $subst_typ(theta, typ))

1. Else If (functyp matches pattern `ExternMethodT%%`), then

  1. Let (ExternMethodT pt* typ) be functyp

  2. (Let (id dir typ_p val?) be pt)*

  3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?))*

  4. Return (ExternMethodT pt'* $subst_typ(theta, typ))

1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

  1. Let (ExternAbstractMethodT pt* typ) be functyp

  2. (Let (id dir typ_p val?) be pt)*

  3. (Let pt' be (id dir $subst_typ(theta, typ_p) val?))*

  4. Return (ExternAbstractMethodT pt'* $subst_typ(theta, typ))

;; ../../../../spec/2c3-runtime-type-subst.watsup:24.1-25.33
def $subst_constyp(theta, (ConsT pt* typ))

1. (Let (id dir typ_p val?) be pt)*

2. (Let pt' be (id dir $subst_typ(theta, typ_p) val?))*

3. Return (ConsT pt'* $subst_typ(theta, typ))

;; ../../../../spec/2c3-runtime-type-subst.watsup:317.1-318.57
def $specialize_typdef(typdef, typ*')

1. If (typdef has type monotypdef), then

  1. Let (MonoD typ) be (typdef as monotypdef)

  2. If (typ*' matches pattern []), then

    1. Return typ

  2. Else

    1. Phantom#10

1. Else

  1. Phantom#11

2. Let typ_a* be typ*'

3. If (typdef has type polytypdef), then

  1. Let (PolyD (tparam*, tparam_hidden*) -> typ) be (typdef as polytypdef)

  2. Let tparam'* be tparam* ++ tparam_hidden*

  3. Let theta be ({ (tparam' -> typ_a)* })

  4. Return $subst_typ(theta, typ)

3. Else

  1. Phantom#12

;; ../../../../spec/2c3-runtime-type-subst.watsup:329.1-330.57
def $specialize_funcdef(funcdef, typ*')

1. If (funcdef has type monofuncdef), then

  1. Let (MonoFD ft) be (funcdef as monofuncdef)

  2. If (typ*' matches pattern []), then

    1. Return (ft, [])

  2. Else

    1. Phantom#13

1. Else

  1. Phantom#14

2. Let typ_a* be typ*'

3. If (funcdef has type polyfuncdef), then

  1. Let (PolyFD (tparam*, tparam_hidden*) -> ft) be (funcdef as polyfuncdef)

  2. Let tparam'* be tparam* ++ tparam_hidden*

  3. If (|tparam'*| = |typ_a*|), then

    1. Return ($subst_functyp(({ (tparam' -> typ_a)* }), ft), [])

  3. Else

    1. Phantom#15

  4. If ((|typ_a*| = 0) /\ (|tparam'*| > 0)), then

    1. Let tid_fresh* be $fresh_tids(|tparam'*|)

    2. Return ($subst_functyp(({ (tparam' -> ((VarT tid_fresh) as typ))* }), ft), tid_fresh*)

  4. Else

    1. Phantom#16

  5. If (((|typ_a*| > 0) /\ (|tparam*| = |typ_a*|)) /\ (|tparam_hidden*| > 0)), then

    1. Let tid_fresh* be $fresh_tids(|tparam_hidden*|)

    2. Let typ_a'* be typ_a* ++ ((VarT tid_fresh) as typ)*

    3. Return ($subst_functyp(({ (tparam' -> typ_a')* }), ft), tid_fresh*)

  5. Else

    1. Phantom#17

3. Else

  1. Phantom#18

;; ../../../../spec/2c3-runtime-type-subst.watsup:359.1-360.57
def $specialize_consdef((ConsD (tparam*, tparam_hidden*) -> ct), typ_a*)

1. Let tparam'* be tparam* ++ tparam_hidden*

2. If (|tparam'*| = |typ_a*|), then

  1. Return ($subst_constyp(({ (tparam' -> typ_a)* }), ct), [])

2. Else

  1. Phantom#19

3. If ((|typ_a*| = 0) /\ (|tparam'*| > 0)), then

  1. Let tid_fresh* be $fresh_tids(|tparam'*|)

  2. Return ($subst_constyp(({ (tparam' -> ((VarT tid_fresh) as typ))* }), ct), tid_fresh*)

3. Else

  1. Phantom#20

4. If (((|typ_a*| > 0) /\ (|tparam*| = |typ_a*|)) /\ (|tparam_hidden*| > 0)), then

  1. Let tid_fresh* be $fresh_tids(|tparam_hidden*|)

  2. Let typ_a'* be typ_a* ++ ((VarT tid_fresh) as typ)*

  3. Return ($subst_constyp(({ (tparam' -> typ_a')* }), ct), tid_fresh*)

4. Else

  1. Phantom#21

;; ../../../../spec/2c3-runtime-type-subst.watsup:387.1-388.47
def $canon_typ(typ'')

1. If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `SpecT%%`), then

    1. Let (SpecT ptd typ_a*) be abstyp

    2. Let typ be $specialize_typdef((ptd as typdef), typ_a*)

    3. Return $canon_typ(typ)

1. Else If (typ'' has type aliastyp), then

  1. Let (DefT typ) be (typ'' as aliastyp)

  2. Return $canon_typ(typ)

2. Otherwise

  1. Return typ''

;; ../../../../spec/2c4-runtime-type-util.watsup:7.1-8.28
def $is_nominal(typ)

1. Return $is_nominal'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:9.1-9.29
def $is_nominal'(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id _member*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id _typ _(member, val)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id _(member, typ)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id _(member, typ)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id _(member, typ)*) be datatyp

    2. Return true

1. Else If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT _id _map<fid, funcdef>) be objtyp

    2. Return true

  2. Else If (objtyp matches pattern `TableT%%`), then

    1. Let (TableT _id _typ) be objtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c4-runtime-type-util.watsup:25.1-26.32
def $is_deftable(typ)

1. Return $is_deftable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:27.1-27.30
def $is_deftable'(typ'')

1. If (typ'' = ((ErrT) as typ)), then

  1. Return true

2. If (typ'' = ((StrT) as typ)), then

  1. Return true

3. If (typ'' = ((BoolT) as typ)), then

  1. Return true

4. If (typ'' = ((IntT) as typ)), then

  1. Return true

5. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `VBitT%`), then

    1. Let (VBitT _width) be numtyp

    2. Return true

5. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ') be datatyp

    2. Return $is_deftable(typ')

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id _member*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id typ' _(member, val)*) be datatyp

    2. Return $is_deftable(typ')

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ'*) be datatyp

    2. If ($is_deftable(typ'))*, then

      1. Return true

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ'' _int) be datatyp

    2. Return $is_deftable(typ'')

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id (_member, typ'')*) be datatyp

    2. If ($is_deftable(typ''))*, then

      1. Return true

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id (_member, typ'')*) be datatyp

    2. If ($is_deftable(typ''))*, then

      1. Return true

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id (_member, typ'')*) be datatyp

    2. If ($is_deftable(typ''))*, then

      1. Return true

6. Otherwise

  1. Return false

;; ../../../../spec/2c4-runtime-type-util.watsup:54.1-55.30
def $is_equalable(typ)

1. Return $is_equalable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:56.1-56.31
def $is_equalable'(typ)

1. If (typ = ((VoidT) as typ)), then

  1. Return false

2. If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return false

2. Else If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT _id _map<fid, funcdef>) be objtyp

    2. Return false

  2. Else If (objtyp matches pattern `ParserT%`), then

    1. Let (ParserT _paramtyp*) be objtyp

    2. Return false

  2. Else If (objtyp matches pattern `ControlT%`), then

    1. Let (ControlT _paramtyp*) be objtyp

    2. Return false

  2. Else If (objtyp matches pattern `PackageT%`), then

    1. Let (PackageT _typ*) be objtyp

    2. Return false

  2. Else If (objtyp matches pattern `TableT%%`), then

    1. Let (TableT _id _typ) be objtyp

    2. Return false

2. Else If (typ has type synthtyp), then

  1. Let synthtyp be (typ as synthtyp)

  2. Return ($is_seqt((synthtyp as typ)) \/ $is_recordt((synthtyp as typ)))

3. Otherwise

  1. Return true

;; ../../../../spec/2c4-runtime-type-util.watsup:72.1-73.31
def $is_assignable(typ)

1. Return $is_assignable'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:74.1-74.32
def $is_assignable'(typ)

1. If (typ = ((VoidT) as typ)), then

  1. Return false

2. If (typ = ((StrT) as typ)), then

  1. Return false

3. If (typ = ((IntT) as typ)), then

  1. Return false

4. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. Return false

4. Else If (typ has type synthtyp), then

  1. Let synthtyp be (typ as synthtyp)

  2. Return false

5. Otherwise

  1. Return true

;; ../../../../spec/2c4-runtime-type-util.watsup:89.1-89.26
def $get_width(typ)

1. Return $get_width'($canon_typ(typ))

;; ../../../../spec/2c4-runtime-type-util.watsup:90.1-90.27
def $get_width'(typ'')

1. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. Return w

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. Return w

  2. Else If (numtyp matches pattern `VBitT%`), then

    1. Let (VBitT w) be numtyp

    2. Return w

  2. Else

    1. Phantom#24

1. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $get_width(typ'')

  2. Else

    1. Phantom#22

1. Else

  1. Phantom#23

;; ../../../../spec/2c5-runtime-type-alpha.watsup:5.1-7.20
relation Type_alpha: typ'', typ'''

1. If (typ'' has type basetyp), then

  1. Let basetyp be (typ'' as basetyp)

  2. If (typ''' has type basetyp), then

    1. Let basetyp' be (typ''' as basetyp)

    2. If (basetyp = basetyp'), then

      1. The relation holds

    2. Else

      1. Phantom#123

  2. Else

    1. Phantom#124

1. Else If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT id) be abstyp

    2. If (typ''' has type abstyp), then

      1. Let abstyp' be (typ''' as abstyp)

      2. If (abstyp' matches pattern `VarT%`), then

        1. Let (VarT id') be abstyp'

        2. If (id = id'), then

          1. The relation holds

        2. Else

          1. Phantom#120

      2. Else

        1. Phantom#121

    2. Else

      1. Phantom#122

  2. Else If (abstyp matches pattern `SpecT%%`), then

    1. Let (SpecT ptd_a typ_a*) be abstyp

    2. If (typ''' has type abstyp), then

      1. Let abstyp' be (typ''' as abstyp)

      2. If (abstyp' matches pattern `SpecT%%`), then

        1. Let (SpecT ptd_b typ_b*) be abstyp'

        2. Let typ_a' be $specialize_typdef((ptd_a as typdef), typ_a*)

        3. Let typ_b' be $specialize_typdef((ptd_b as typdef), typ_b*)

        4. If (Type_alpha: typ_a' ~~ typ_b' holds), then

          1. If ($is_nominal(typ_a') /\ $is_nominal(typ_b')), then

            1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

              1. The relation holds

            1. Else

              1. Phantom#114

          1. Else

            1. Phantom#115

          2. If (~$is_nominal(typ_a') /\ ~$is_nominal(typ_b')), then

            1. The relation holds

          2. Else

            1. Phantom#116

        4. Else

          1. Phantom#117

      2. Else

        1. Phantom#118

    2. Else

      1. Phantom#119

1. Else If (typ'' has type aliastyp), then

  1. Let (DefT typ_a) be (typ'' as aliastyp)

  2. If (Type_alpha: typ_a ~~ typ''' holds), then

    1. The relation holds

  2. Else

    1. Phantom#113

1. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT id typ'') be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `NewT%%`), then

        1. Let (NewT id' typ''') be datatyp'

        2. If (id = id'), then

          1. If (Type_alpha: typ'' ~~ typ''' holds), then

            1. The relation holds

          1. Else

            1. Phantom#109

        2. Else

          1. Phantom#110

      2. Else

        1. Phantom#111

    2. Else

      1. Phantom#112

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT id member*) be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `EnumT%%`), then

        1. Let (EnumT id' member'*) be datatyp'

        2. If (id = id'), then

          1. If ((member = member'))*, then

            1. The relation holds

          1. Else

            1. Phantom#105

        2. Else

          1. Phantom#106

      2. Else

        1. Phantom#107

    2. Else

      1. Phantom#108

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT id typ'' (member, val_a)*) be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `SEnumT%%%`), then

        1. Let (SEnumT id' typ''' (member', val_b)*) be datatyp'

        2. If (id = id'), then

          1. If ((member = member'))*, then

            1. If (Type_alpha: typ'' ~~ typ''' holds), then

              1. If ((val_a = val_b))*, then

                1. The relation holds

              1. Else

                1. Phantom#99

            1. Else

              1. Phantom#100

          1. Else

            1. Phantom#101

        2. Else

          1. Phantom#102

      2. Else

        1. Phantom#103

    2. Else

      1. Phantom#104

  2. Else If (datatyp matches pattern `ListT%`), then

    1. Let (ListT typ'') be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `ListT%`), then

        1. Let (ListT typ''') be datatyp'

        2. If (Type_alpha: typ'' ~~ typ''' holds), then

          1. The relation holds

        2. Else

          1. Phantom#96

      2. Else

        1. Phantom#97

    2. Else

      1. Phantom#98

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `TupleT%`), then

        1. Let (TupleT typ'''*) be datatyp'

        2. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#93

      2. Else

        1. Phantom#94

    2. Else

      1. Phantom#95

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ'' i_size) be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `StackT%%`), then

        1. Let (StackT typ''' int) be datatyp'

        2. If (i_size = int), then

          1. If (Type_alpha: typ'' ~~ typ''' holds), then

            1. The relation holds

          1. Else

            1. Phantom#89

        2. Else

          1. Phantom#90

      2. Else

        1. Phantom#91

    2. Else

      1. Phantom#92

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT id (member, typ'')*) be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `StructT%%`), then

        1. Let (StructT id' (member', typ''')*) be datatyp'

        2. If (id = id'), then

          1. If ((member = member'))*, then

            1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

              1. The relation holds

            1. Else

              1. Phantom#84

          1. Else

            1. Phantom#85

        2. Else

          1. Phantom#86

      2. Else

        1. Phantom#87

    2. Else

      1. Phantom#88

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT id (member, typ'')*) be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `HeaderT%%`), then

        1. Let (HeaderT id' (member', typ''')*) be datatyp'

        2. If (id = id'), then

          1. If ((member = member'))*, then

            1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

              1. The relation holds

            1. Else

              1. Phantom#79

          1. Else

            1. Phantom#80

        2. Else

          1. Phantom#81

      2. Else

        1. Phantom#82

    2. Else

      1. Phantom#83

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT id (member, typ'')*) be datatyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp' be (typ''' as datatyp)

      2. If (datatyp' matches pattern `UnionT%%`), then

        1. Let (UnionT id' (member', typ''')*) be datatyp'

        2. If (id = id'), then

          1. If ((member = member'))*, then

            1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

              1. The relation holds

            1. Else

              1. Phantom#74

          1. Else

            1. Phantom#75

        2. Else

          1. Phantom#76

      2. Else

        1. Phantom#77

    2. Else

      1. Phantom#78

1. Else If (typ'' has type objtyp), then

  1. Let objtyp be (typ'' as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT id fmap_a) be objtyp

    2. If (typ''' has type objtyp), then

      1. Let objtyp' be (typ''' as objtyp)

      2. If (objtyp' matches pattern `ExternT%%`), then

        1. Let (ExternT id' fmap_b) be objtyp'

        2. If (id = id'), then

          1. Let ({ (fid_a -> fd_a)* }) be fmap_a

          2. Let ({ (fid_b -> fd_b)* }) be fmap_b

          3. If $eq_set<fid>(({ fid_a* }), ({ fid_b* })), then

            1. (Let funcdef? be $find_map<fid, funcdef>(fmap_a, fid_a))*

            2. If ((funcdef? matches pattern (_)))*, then

              1. (Let ?(fd_a') be funcdef?)*

              2. (Let funcdef?' be $find_map<fid, funcdef>(fmap_b, fid_a))*

              3. If ((funcdef?' matches pattern (_)))*, then

                1. (Let ?(fd_b') be funcdef?')*

                2. If ((FuncDef_alpha: fd_a' ~~ fd_b' holds))*, then

                  1. The relation holds

                2. Else

                  1. Phantom#67

              3. Else

                1. Phantom#68

            2. Else

              1. Phantom#69

          3. Else

            1. Phantom#70

        2. Else

          1. Phantom#71

      2. Else

        1. Phantom#72

    2. Else

      1. Phantom#73

  2. Else If (objtyp matches pattern `ParserT%`), then

    1. Let (ParserT pt_a*) be objtyp

    2. If (typ''' has type objtyp), then

      1. Let objtyp' be (typ''' as objtyp)

      2. If (objtyp' matches pattern `ParserT%`), then

        1. Let (ParserT pt_b*) be objtyp'

        2. (Let (_id dir_a typ'' _val?) be pt_a)*

        3. (Let (_id' dir_b typ''' _val?') be pt_b)*

        4. If ((dir_a = dir_b))*, then

          1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

            1. The relation holds

          1. Else

            1. Phantom#63

        4. Else

          1. Phantom#64

      2. Else

        1. Phantom#65

    2. Else

      1. Phantom#66

  2. Else If (objtyp matches pattern `ControlT%`), then

    1. Let (ControlT pt_a*) be objtyp

    2. If (typ''' has type objtyp), then

      1. Let objtyp' be (typ''' as objtyp)

      2. If (objtyp' matches pattern `ControlT%`), then

        1. Let (ControlT pt_b*) be objtyp'

        2. (Let (_id dir_a typ'' _val?) be pt_a)*

        3. (Let (_id' dir_b typ''' _val?') be pt_b)*

        4. If ((dir_a = dir_b))*, then

          1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

            1. The relation holds

          1. Else

            1. Phantom#59

        4. Else

          1. Phantom#60

      2. Else

        1. Phantom#61

    2. Else

      1. Phantom#62

  2. Else If (objtyp matches pattern `PackageT%`), then

    1. Let (PackageT typ''*) be objtyp

    2. If (typ''' has type objtyp), then

      1. Let objtyp' be (typ''' as objtyp)

      2. If (objtyp' matches pattern `PackageT%`), then

        1. Let (PackageT typ'''*) be objtyp'

        2. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#56

      2. Else

        1. Phantom#57

    2. Else

      1. Phantom#58

  2. Else If (objtyp matches pattern `TableT%%`), then

    1. Let (TableT id typ'') be objtyp

    2. If (typ''' has type objtyp), then

      1. Let objtyp' be (typ''' as objtyp)

      2. If (objtyp' matches pattern `TableT%%`), then

        1. Let (TableT id' typ''') be objtyp'

        2. If (id = id'), then

          1. If (Type_alpha: typ'' ~~ typ''' holds), then

            1. The relation holds

          1. Else

            1. Phantom#52

        2. Else

          1. Phantom#53

      2. Else

        1. Phantom#54

    2. Else

      1. Phantom#55

1. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT typ''*) be synthtyp

    2. If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `SeqT%`), then

        1. Let (SeqT typ'''*) be synthtyp'

        2. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#49

      2. Else

        1. Phantom#50

    2. Else

      1. Phantom#51

  2. Else If (synthtyp matches pattern `SeqDefaultT%`), then

    1. Let (SeqDefaultT typ''*) be synthtyp

    2. If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `SeqDefaultT%`), then

        1. Let (SeqDefaultT typ'''*) be synthtyp'

        2. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#46

      2. Else

        1. Phantom#47

    2. Else

      1. Phantom#48

  2. Else If (synthtyp matches pattern `RecordT%`), then

    1. Let (RecordT (member, typ'')*) be synthtyp

    2. If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `RecordT%`), then

        1. Let (RecordT (member', typ''')*) be synthtyp'

        2. If ((member = member'))*, then

          1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

            1. The relation holds

          1. Else

            1. Phantom#42

        2. Else

          1. Phantom#43

      2. Else

        1. Phantom#44

    2. Else

      1. Phantom#45

  2. Else If (synthtyp matches pattern `RecordDefaultT%`), then

    1. Let (RecordDefaultT (member, typ'')*) be synthtyp

    2. If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `RecordDefaultT%`), then

        1. Let (RecordDefaultT (member', typ''')*) be synthtyp'

        2. If ((member = member'))*, then

          1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

            1. The relation holds

          1. Else

            1. Phantom#38

        2. Else

          1. Phantom#39

      2. Else

        1. Phantom#40

    2. Else

      1. Phantom#41

  2. Else If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ'') be synthtyp

    2. If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `SetT%`), then

        1. Let (SetT typ''') be synthtyp'

        2. If (Type_alpha: typ'' ~~ typ''' holds), then

          1. The relation holds

        2. Else

          1. Phantom#35

      2. Else

        1. Phantom#36

    2. Else

      1. Phantom#37

  2. Else If (synthtyp matches pattern `TableEnumT%%`), then

    1. Let (TableEnumT id member*) be synthtyp

    2. If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `TableEnumT%%`), then

        1. Let (TableEnumT id' member'*) be synthtyp'

        2. If (id = id'), then

          1. If ((member = member'))*, then

            1. The relation holds

          1. Else

            1. Phantom#31

        2. Else

          1. Phantom#32

      2. Else

        1. Phantom#33

    2. Else

      1. Phantom#34

  2. Else If (synthtyp matches pattern `TableStructT%%`), then

    1. Let (TableStructT id (member, typ'')*) be synthtyp

    2. If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `TableStructT%%`), then

        1. Let (TableStructT id' (member', typ''')*) be synthtyp'

        2. If (id = id'), then

          1. If ((member = member'))*, then

            1. If ((Type_alpha: typ'' ~~ typ''' holds))*, then

              1. The relation holds

            1. Else

              1. Phantom#25

          1. Else

            1. Phantom#26

        2. Else

          1. Phantom#27

      2. Else

        1. Phantom#28

    2. Else

      1. Phantom#29

  2. Else

    1. Phantom#30

2. If (typ''' has type aliastyp), then

  1. Let (DefT typ''') be (typ''' as aliastyp)

  2. If (Type_alpha: typ'' ~~ typ''' holds), then

    1. The relation holds

  2. Else

    1. Phantom#125

2. Else

  1. Phantom#126

3. If (typ'' = ((DefaultT) as typ)), then

  1. If (typ''' = ((DefaultT) as typ)), then

    1. The relation holds

  1. Else

    1. Phantom#127

3. Else

  1. Phantom#128

4. If (typ'' = ((InvalidT) as typ)), then

  1. If (typ''' = ((InvalidT) as typ)), then

    1. The relation holds

  1. Else

    1. Phantom#129

4. Else

  1. Phantom#130

5. If (typ'' = ((StateT) as typ)), then

  1. If (typ''' = ((StateT) as typ)), then

    1. The relation holds

  1. Else

    1. Phantom#131

5. Else

  1. Phantom#132

6. If (typ'' = ((AnyT) as typ)), then

  1. If (typ''' = ((AnyT) as typ)), then

    1. The relation holds

  1. Else

    1. Phantom#133

6. Else

  1. Phantom#134

;; ../../../../spec/2c5-runtime-type-alpha.watsup:9.1-11.20
relation FuncType_alpha: functyp, functyp'

1. If (functyp matches pattern `BuiltinMethodT%%`), then

  1. Let (BuiltinMethodT pt_a* typ_r_a) be functyp

  2. If (functyp' matches pattern `BuiltinMethodT%%`), then

    1. Let (BuiltinMethodT pt_b* typ_r_b) be functyp'

    2. (Let (_id dir_a typ_a _val?) be pt_a)*

    3. (Let (_id' dir_b typ_b _val?') be pt_b)*

    4. If ((dir_a = dir_b))*, then

      1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

        1. If (Type_alpha: typ_r_a ~~ typ_r_b holds), then

          1. The relation holds

        1. Else

          1. Phantom#162

      1. Else

        1. Phantom#163

    4. Else

      1. Phantom#164

  2. Else

    1. Phantom#165

1. Else If (functyp matches pattern `ActionT%`), then

  1. Let (ActionT pt_a*) be functyp

  2. If (functyp' matches pattern `ActionT%`), then

    1. Let (ActionT pt_b*) be functyp'

    2. (Let (_id dir_a typ_a _val?) be pt_a)*

    3. (Let (_id' dir_b typ_b _val?') be pt_b)*

    4. If ((dir_a = dir_b))*, then

      1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

        1. The relation holds

      1. Else

        1. Phantom#159

    4. Else

      1. Phantom#160

  2. Else

    1. Phantom#161

1. Else If (functyp matches pattern `ParserApplyMethodT%`), then

  1. Let (ParserApplyMethodT pt_a*) be functyp

  2. If (functyp' matches pattern `ParserApplyMethodT%`), then

    1. Let (ParserApplyMethodT pt_b*) be functyp'

    2. (Let (_id dir_a typ_a _val?) be pt_a)*

    3. (Let (_id' dir_b typ_b _val?') be pt_b)*

    4. If ((dir_a = dir_b))*, then

      1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

        1. The relation holds

      1. Else

        1. Phantom#156

    4. Else

      1. Phantom#157

  2. Else

    1. Phantom#158

1. Else If (functyp matches pattern `ControlApplyMethodT%`), then

  1. Let (ControlApplyMethodT pt_a*) be functyp

  2. If (functyp' matches pattern `ControlApplyMethodT%`), then

    1. Let (ControlApplyMethodT pt_b*) be functyp'

    2. (Let (_id dir_a typ_a _val?) be pt_a)*

    3. (Let (_id' dir_b typ_b _val?') be pt_b)*

    4. If ((dir_a = dir_b))*, then

      1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

        1. The relation holds

      1. Else

        1. Phantom#153

    4. Else

      1. Phantom#154

  2. Else

    1. Phantom#155

1. Else If (functyp matches pattern `TableApplyMethodT%`), then

  1. Let (TableApplyMethodT typ_a) be functyp

  2. If (functyp' matches pattern `TableApplyMethodT%`), then

    1. Let (TableApplyMethodT typ_b) be functyp'

    2. If (Type_alpha: typ_a ~~ typ_b holds), then

      1. The relation holds

    2. Else

      1. Phantom#151

  2. Else

    1. Phantom#152

1. Else If (functyp matches pattern `ExternFuncT%%`), then

  1. Let (ExternFuncT pt_a* typ_r_a) be functyp

  2. If (functyp' matches pattern `ExternFuncT%%`), then

    1. Let (ExternFuncT pt_b* typ_r_b) be functyp'

    2. (Let (_id dir_a typ_a _val?) be pt_a)*

    3. (Let (_id' dir_b typ_b _val?') be pt_b)*

    4. If ((dir_a = dir_b))*, then

      1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

        1. If (Type_alpha: typ_r_a ~~ typ_r_b holds), then

          1. The relation holds

        1. Else

          1. Phantom#147

      1. Else

        1. Phantom#148

    4. Else

      1. Phantom#149

  2. Else

    1. Phantom#150

1. Else If (functyp matches pattern `FuncT%%`), then

  1. Let (FuncT pt_a* typ_r_a) be functyp

  2. If (functyp' matches pattern `FuncT%%`), then

    1. Let (FuncT pt_b* typ_r_b) be functyp'

    2. (Let (_id dir_a typ_a _val?) be pt_a)*

    3. (Let (_id' dir_b typ_b _val?') be pt_b)*

    4. If ((dir_a = dir_b))*, then

      1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

        1. If (Type_alpha: typ_r_a ~~ typ_r_b holds), then

          1. The relation holds

        1. Else

          1. Phantom#143

      1. Else

        1. Phantom#144

    4. Else

      1. Phantom#145

  2. Else

    1. Phantom#146

1. Else If (functyp matches pattern `ExternMethodT%%`), then

  1. Let (ExternMethodT pt_a* typ_r_a) be functyp

  2. If (functyp' matches pattern `ExternMethodT%%`), then

    1. Let (ExternMethodT pt_b* typ_r_b) be functyp'

    2. (Let (_id dir_a typ_a _val?) be pt_a)*

    3. (Let (_id' dir_b typ_b _val?') be pt_b)*

    4. If ((dir_a = dir_b))*, then

      1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

        1. If (Type_alpha: typ_r_a ~~ typ_r_b holds), then

          1. The relation holds

        1. Else

          1. Phantom#139

      1. Else

        1. Phantom#140

    4. Else

      1. Phantom#141

  2. Else

    1. Phantom#142

1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

  1. Let (ExternAbstractMethodT pt_a* typ_r_a) be functyp

  2. If (functyp' matches pattern `ExternAbstractMethodT%%`), then

    1. Let (ExternAbstractMethodT pt_b* typ_r_b) be functyp'

    2. (Let (_id dir_a typ_a _val?) be pt_a)*

    3. (Let (_id' dir_b typ_b _val?') be pt_b)*

    4. If ((dir_a = dir_b))*, then

      1. If ((Type_alpha: typ_a ~~ typ_b holds))*, then

        1. If (Type_alpha: typ_r_a ~~ typ_r_b holds), then

          1. The relation holds

        1. Else

          1. Phantom#135

      1. Else

        1. Phantom#136

    4. Else

      1. Phantom#137

  2. Else

    1. Phantom#138

;; ../../../../spec/2c5-runtime-type-alpha.watsup:13.1-15.20
relation FuncDef_alpha: funcdef, funcdef'

1. If (funcdef has type monofuncdef), then

  1. Let (MonoFD ft_a) be (funcdef as monofuncdef)

  2. If (funcdef' has type monofuncdef), then

    1. Let (MonoFD ft_b) be (funcdef' as monofuncdef)

    2. If (FuncType_alpha: ft_a ~~ ft_b holds), then

      1. The relation holds

    2. Else

      1. Phantom#170

  2. Else

    1. Phantom#171

1. Else If (funcdef has type polyfuncdef), then

  1. Let (PolyFD (tparam_a*, tparam_hidden_a*) -> ft_a) be (funcdef as polyfuncdef)

  2. If (funcdef' has type polyfuncdef), then

    1. Let (PolyFD (tparam_b*, tparam_hidden_b*) -> ft_b) be (funcdef' as polyfuncdef)

    2. If (|tparam_a*| = |tparam_b*|), then

      1. If (|tparam_hidden_a*| = |tparam_hidden_b*|), then

        1. Let tid_fresh* be $fresh_tids(|tparam_a* ++ tparam_hidden_a*|)

        2. Let tparam_a'* be tparam_a* ++ tparam_hidden_a*

        3. Let ft_a' be $subst_functyp(({ (tparam_a' -> ((VarT tid_fresh) as typ))* }), ft_a)

        4. Let tparam_b'* be tparam_b* ++ tparam_hidden_b*

        5. Let ft_b' be $subst_functyp(({ (tparam_b' -> ((VarT tid_fresh) as typ))* }), ft_b)

        6. If (FuncType_alpha: ft_a' ~~ ft_b' holds), then

          1. The relation holds

        6. Else

          1. Phantom#166

      1. Else

        1. Phantom#167

    2. Else

      1. Phantom#168

  2. Else

    1. Phantom#169

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:5.1-5.39
relation Type_wf: tidset, typ'''''

1. If (typ''''' has type basetyp), then

  1. Let basetyp be (typ''''' as basetyp)

  2. The relation holds

1. Else If (typ''''' has type abstyp), then

  1. Let abstyp be (typ''''' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT tid) be abstyp

    2. If $in_set<tid>(tid, tidset), then

      1. The relation holds

    2. Else

      1. Phantom#220

  2. Else If (abstyp matches pattern `SpecT%%`), then

    1. Let (SpecT ptd typ_a*) be abstyp

    2. Let typ''''' be $specialize_typdef((ptd as typdef), typ_a*)

    3. If (Type_wf: tidset |- typ''''' holds), then

      1. The relation holds

    3. Else

      1. Phantom#219

1. Else If (typ''''' has type aliastyp), then

  1. Let (DefT typ''''') be (typ''''' as aliastyp)

  2. If $nestable_deft(typ'''''), then

    1. If (Type_wf: tidset |- typ''''' holds), then

      1. The relation holds

    1. Else

      1. Phantom#217

  2. Else

    1. Phantom#218

1. Else If (typ''''' has type datatyp), then

  1. Let datatyp be (typ''''' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ''''') be datatyp

    2. If $nestable_newt(typ'''''), then

      1. If (Type_wf: tidset |- typ''''' holds), then

        1. The relation holds

      1. Else

        1. Phantom#215

    2. Else

      1. Phantom#216

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id member*) be datatyp

    2. If $distinct_<member>(member*), then

      1. The relation holds

    2. Else

      1. Phantom#214

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id typ''''' (member, val)*) be datatyp

    2. If $distinct_<member>(member*), then

      1. If $nestable_senumt(typ'''''), then

        1. If (Type_wf: tidset |- typ''''' holds), then

          1. The relation holds

        1. Else

          1. Phantom#211

      1. Else

        1. Phantom#212

    2. Else

      1. Phantom#213

  2. Else If (datatyp matches pattern `ListT%`), then

    1. Let (ListT typ''''') be datatyp

    2. If $nestable_listt(typ'''''), then

      1. If (Type_wf: tidset |- typ''''' holds), then

        1. The relation holds

      1. Else

        1. Phantom#209

    2. Else

      1. Phantom#210

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ'''''*) be datatyp

    2. If ($nestable_tuplet(typ'''''))*, then

      1. If ((Type_wf: tidset |- typ''''' holds))*, then

        1. The relation holds

      1. Else

        1. Phantom#207

    2. Else

      1. Phantom#208

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ''''' i_size) be datatyp

    2. If (i_size >= (0 as int)), then

      1. If $nestable_stackt(typ'''''), then

        1. If (Type_wf: tidset |- typ''''' holds), then

          1. The relation holds

        1. Else

          1. Phantom#204

      1. Else

        1. Phantom#205

    2. Else

      1. Phantom#206

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id (member, typ''''')*) be datatyp

    2. If $distinct_<member>(member*), then

      1. If ($nestable_structt(typ'''''))*, then

        1. If ((Type_wf: tidset |- typ''''' holds))*, then

          1. The relation holds

        1. Else

          1. Phantom#201

      1. Else

        1. Phantom#202

    2. Else

      1. Phantom#203

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id (member, typ''''')*) be datatyp

    2. If $distinct_<member>(member*), then

      1. If ($nestable_headert(typ'''''))*, then

        1. If ((Type_wf: tidset |- typ''''' holds))*, then

          1. The relation holds

        1. Else

          1. Phantom#198

      1. Else

        1. Phantom#199

    2. Else

      1. Phantom#200

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id (member, typ''''')*) be datatyp

    2. If $distinct_<member>(member*), then

      1. If ($nestable_uniont(typ'''''))*, then

        1. If ((Type_wf: tidset |- typ''''' holds))*, then

          1. The relation holds

        1. Else

          1. Phantom#195

      1. Else

        1. Phantom#196

    2. Else

      1. Phantom#197

1. Else If (typ''''' has type objtyp), then

  1. Let objtyp be (typ''''' as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT _id fmap) be objtyp

    2. Let ({ (fid -> funcdef)* }) be fmap

    3. If ((FuncDef_wf: tidset |- funcdef holds))*, then

      1. The relation holds

    3. Else

      1. Phantom#194

  2. Else If (objtyp matches pattern `ParserT%`), then

    1. Let (ParserT pt*) be objtyp

    2. If (ParamTypes_wf: tidset |- pt* holds), then

      1. The relation holds

    2. Else

      1. Phantom#193

  2. Else If (objtyp matches pattern `ControlT%`), then

    1. Let (ControlT pt*) be objtyp

    2. If (ParamTypes_wf: tidset |- pt* holds), then

      1. The relation holds

    2. Else

      1. Phantom#192

  2. Else If (objtyp matches pattern `PackageT%`), then

    1. Let (PackageT typ'''''*) be objtyp

    2. If ((Type_wf: tidset |- typ''''' holds))*, then

      1. The relation holds

    2. Else

      1. Phantom#191

  2. Else If (objtyp matches pattern `TableT%%`), then

    1. Let (TableT _id typ''''') be objtyp

    2. Let typ''''' be $canon_typ(typ''''')

    3. If $is_table_structt(typ'''''), then

      1. If (Type_wf: tidset |- typ''''' holds), then

        1. The relation holds

      1. Else

        1. Phantom#189

    3. Else

      1. Phantom#190

1. Else If (typ''''' has type synthtyp), then

  1. Let synthtyp be (typ''''' as synthtyp)

  2. If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT typ'''''*) be synthtyp

    2. If ((Type_wf: tidset |- typ''''' holds))*, then

      1. The relation holds

    2. Else

      1. Phantom#188

  2. Else If (synthtyp matches pattern `SeqDefaultT%`), then

    1. Let (SeqDefaultT typ'''''*) be synthtyp

    2. If ((Type_wf: tidset |- typ''''' holds))*, then

      1. The relation holds

    2. Else

      1. Phantom#187

  2. Else If (synthtyp matches pattern `RecordT%`), then

    1. Let (RecordT (member, typ''''')*) be synthtyp

    2. If $distinct_<member>(member*), then

      1. If ((Type_wf: tidset |- typ''''' holds))*, then

        1. The relation holds

      1. Else

        1. Phantom#185

    2. Else

      1. Phantom#186

  2. Else If (synthtyp matches pattern `RecordDefaultT%`), then

    1. Let (RecordDefaultT (member, typ''''')*) be synthtyp

    2. If $distinct_<member>(member*), then

      1. If ((Type_wf: tidset |- typ''''' holds))*, then

        1. The relation holds

      1. Else

        1. Phantom#183

    2. Else

      1. Phantom#184

  2. Else If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ''''') be synthtyp

    2. Let typ''''' be $canon_typ(typ''''')

    3. If $nestable_sett(typ'''''), then

      1. If (Type_wf: tidset |- typ''''' holds), then

        1. The relation holds

      1. Else

        1. Phantom#181

    3. Else

      1. Phantom#182

  2. Else If (synthtyp matches pattern `TableEnumT%%`), then

    1. Let (TableEnumT _id member*) be synthtyp

    2. If $distinct_<member>(member*), then

      1. The relation holds

    2. Else

      1. Phantom#180

  2. Else If (synthtyp matches pattern `TableStructT%%`), then

    1. Let (TableStructT _id (member, typ''''')*) be synthtyp

    2. If (member* = ["hit", "miss", "action_run"]), then

      1. Let typ* be typ'''''*

      2. If (typ* matches pattern [ _/3 ]), then

        1. Let [typ''''', typ''', typ''''] be typ*

        2. If (typ''''' = ((BoolT) as typ)), then

          1. If (typ''' = ((BoolT) as typ)), then

            1. If (typ'''' has type synthtyp), then

              1. Let synthtyp' be (typ'''' as synthtyp)

              2. If (synthtyp' matches pattern `TableEnumT%%`), then

                1. Let (TableEnumT id_e member_e*) be synthtyp'

                2. If (Type_wf: tidset |- ((TableEnumT id_e member_e*) as typ) holds), then

                  1. The relation holds

                2. Else

                  1. Phantom#172

              2. Else

                1. Phantom#173

            1. Else

              1. Phantom#174

          1. Else

            1. Phantom#175

        2. Else

          1. Phantom#176

      2. Else

        1. Phantom#177

    2. Else

      1. Phantom#178

  2. Else

    1. Phantom#179

2. If (typ''''' = ((DefaultT) as typ)), then

  1. The relation holds

2. Else

  1. Phantom#221

3. If (typ''''' = ((InvalidT) as typ)), then

  1. The relation holds

3. Else

  1. Phantom#222

4. If (typ''''' = ((StateT) as typ)), then

  1. The relation holds

4. Else

  1. Phantom#223

5. If (typ''''' = ((AnyT) as typ)), then

  1. The relation holds

5. Else

  1. Phantom#224

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:6.1-6.42
relation TypeDef_wf: tidset, typdef

1. If (typdef has type monotypdef), then

  1. Let (MonoD typ) be (typdef as monotypdef)

  2. If $nestable_monod(typ), then

    1. If (Type_wf: tidset |- typ holds), then

      1. The relation holds

    1. Else

      1. Phantom#228

  2. Else

    1. Phantom#229

1. Else If (typdef has type polytypdef), then

  1. Let (PolyD (tparam*, tparam_hidden*) -> typ) be (typdef as polytypdef)

  2. If $nestable_polyd(typ), then

    1. If $distinct_<tid>(tparam* ++ tparam_hidden*), then

      1. Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* }))

      2. If (Type_wf: tidset' |- typ holds), then

        1. The relation holds

      2. Else

        1. Phantom#225

    1. Else

      1. Phantom#226

  2. Else

    1. Phantom#227

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:8.1-8.44
relation ParamType_wf: tidset, (_id dir typ val?)

1. If (val? matches pattern ()), then

  1. If (Type_wf: tidset |- typ holds), then

    1. If ($is_externt($canon_typ(typ)) => (dir = (NO))), then

      1. The relation holds

    1. Else

      1. Phantom#233

  1. Else

    1. Phantom#234

1. Else If (val? matches pattern (_)), then

  1. Let ?(val) be val?

  2. If (Type_wf: tidset |- typ holds), then

    1. If ($is_externt($canon_typ(typ)) => (dir = (NO))), then

      1. If ((dir = (IN)) \/ (dir = (NO))), then

        1. The relation holds

      1. Else

        1. Phantom#230

    1. Else

      1. Phantom#231

  2. Else

    1. Phantom#232

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:9.1-9.45
relation ParamTypes_wf: tidset, pt*

1. (Let (id _dir _typ _val?) be pt)*

2. If $distinct_<id>(id*), then

  1. If ((ParamType_wf: tidset |- pt holds))*, then

    1. The relation holds

  1. Else

    1. Phantom#235

2. Else

  1. Phantom#236

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:11.1-11.43
relation FuncType_wf: tidset, functyp

1. If (functyp matches pattern `BuiltinMethodT%%`), then

  1. Let (BuiltinMethodT pt* typ_r) be functyp

  2. If (ParamTypes_wf: tidset |- pt* holds), then

    1. If (Type_wf: tidset |- typ_r holds), then

      1. The relation holds

    1. Else

      1. Phantom#257

  2. Else

    1. Phantom#258

1. Else If (functyp matches pattern `ActionT%`), then

  1. Let (ActionT pt*) be functyp

  2. If (ParamTypes_wf: tidset |- pt* holds), then

    1. (Let (id dir typ val?) be pt)*

    2. If $is_trailing_action(dir*), then

      1. (Let typ' be $canon_typ(typ))*

      2. If (((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_intt(typ')) /\ ~$is_obj(typ')) /\ (~$is_strt(typ') \/ (dir = (NO)))))*, then

        1. The relation holds

      2. Else

        1. Phantom#254

    2. Else

      1. Phantom#255

  2. Else

    1. Phantom#256

1. Else If (functyp matches pattern `ParserApplyMethodT%`), then

  1. Let (ParserApplyMethodT pt*) be functyp

  2. If (ParamTypes_wf: tidset |- pt* holds), then

    1. (Let (id dir typ val?) be pt)*

    2. (Let typ' be $canon_typ(typ))*

    3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

      1. The relation holds

    3. Else

      1. Phantom#252

  2. Else

    1. Phantom#253

1. Else If (functyp matches pattern `ControlApplyMethodT%`), then

  1. Let (ControlApplyMethodT pt*) be functyp

  2. If (ParamTypes_wf: tidset |- pt* holds), then

    1. (Let (id dir typ val?) be pt)*

    2. (Let typ' be $canon_typ(typ))*

    3. The relation holds

  2. Else

    1. Phantom#251

1. Else If (functyp matches pattern `TableApplyMethodT%`), then

  1. Let (TableApplyMethodT typ) be functyp

  2. If (typ has type synthtyp), then

    1. Let synthtyp be (typ as synthtyp)

    2. If (synthtyp matches pattern `TableStructT%%`), then

      1. Let (TableStructT _id _(member, typ)*) be synthtyp

      2. The relation holds

    2. Else

      1. Phantom#249

  2. Else

    1. Phantom#250

1. Else If (functyp matches pattern `ExternFuncT%%`), then

  1. Let (ExternFuncT pt* typ_r) be functyp

  2. If (ParamTypes_wf: tidset |- pt* holds), then

    1. (Let (id dir typ val?) be pt)*

    2. (Let typ' be $canon_typ(typ))*

    3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

      1. If (Type_wf: tidset |- typ_r holds), then

        1. The relation holds

      1. Else

        1. Phantom#246

    3. Else

      1. Phantom#247

  2. Else

    1. Phantom#248

1. Else If (functyp matches pattern `FuncT%%`), then

  1. Let (FuncT pt* typ_r) be functyp

  2. If (ParamTypes_wf: tidset |- pt* holds), then

    1. (Let (id dir typ val?) be pt)*

    2. (Let typ' be $canon_typ(typ))*

    3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~$is_obj(typ')) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

      1. If (Type_wf: tidset |- typ_r holds), then

        1. The relation holds

      1. Else

        1. Phantom#243

    3. Else

      1. Phantom#244

  2. Else

    1. Phantom#245

1. Else If (functyp matches pattern `ExternMethodT%%`), then

  1. Let (ExternMethodT pt* typ_r) be functyp

  2. If (ParamTypes_wf: tidset |- pt* holds), then

    1. (Let (id dir typ val?) be pt)*

    2. (Let typ' be $canon_typ(typ))*

    3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

      1. If (Type_wf: tidset |- typ_r holds), then

        1. The relation holds

      1. Else

        1. Phantom#240

    3. Else

      1. Phantom#241

  2. Else

    1. Phantom#242

1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

  1. Let (ExternAbstractMethodT pt* typ_r) be functyp

  2. If (ParamTypes_wf: tidset |- pt* holds), then

    1. (Let (id dir typ val?) be pt)*

    2. (Let typ' be $canon_typ(typ))*

    3. If ((((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))) /\ (~($is_strt(typ') \/ $is_intt(typ')) \/ (dir = (NO)))))*, then

      1. If (Type_wf: tidset |- typ_r holds), then

        1. The relation holds

      1. Else

        1. Phantom#237

    3. Else

      1. Phantom#238

  2. Else

    1. Phantom#239

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:12.1-12.43
relation FuncDef_wf: tidset, funcdef

1. If (funcdef has type monofuncdef), then

  1. Let (MonoFD ft) be (funcdef as monofuncdef)

  2. If (((($is_builtinmethodt(ft) \/ $is_actiont(ft)) \/ $is_parserapplymethodt(ft)) \/ $is_controlapplymethodt(ft)) \/ $is_tableapplymethodt(ft)), then

    1. If (FuncType_wf: tidset |- ft holds), then

      1. The relation holds

    1. Else

      1. Phantom#262

  2. Else

    1. Phantom#263

1. Else If (funcdef has type polyfuncdef), then

  1. Let (PolyFD (tparam*, tparam_hidden*) -> ft) be (funcdef as polyfuncdef)

  2. If ((($is_externfunct(ft) \/ $is_funct(ft)) \/ $is_externmethodt(ft)) \/ $is_externabstractmethodt(ft)), then

    1. If $distinct_<tid>(tparam* ++ tparam_hidden*), then

      1. Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* }))

      2. If (FuncType_wf: tidset' |- ft holds), then

        1. The relation holds

      2. Else

        1. Phantom#259

    1. Else

      1. Phantom#260

  2. Else

    1. Phantom#261

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:14.52-14.60
syntax consctxt = 
   | `CONSCTXT`()

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:15.1-15.53
relation CParamType_wf: tidset, consctxt, (id dir typ val?)

1. If (dir matches pattern `NO`), then

  1. If (Type_wf: tidset |- typ holds), then

    1. The relation holds

  1. Else

    1. Phantom#264

1. Else

  1. Phantom#265

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:16.1-16.54
relation CParamTypes_wf: tidset, consctxt, pt*

1. (Let (id _dir _typ _val?) be pt)*

2. If $distinct_<id>(id*), then

  1. If ((CParamType_wf: tidset consctxt |- pt holds))*, then

    1. The relation holds

  1. Else

    1. Phantom#266

2. Else

  1. Phantom#267

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:18.1-18.43
relation ConsType_wf: tidset, (ConsT pt* typ)

1. If (CParamTypes_wf: tidset (CONSCTXT) |- pt* holds), then

  1. If (Type_wf: tidset |- typ holds), then

    1. Let typ'' be $canon_typ(typ)

    2. If (typ'' has type objtyp), then

      1. Let objtyp be (typ'' as objtyp)

      2. If (objtyp matches pattern `ExternT%%`), then

        1. Let (ExternT id fmap) be objtyp

        2. (Let (_id _dir typ_p _val?) be pt)*

        3. (Let typ' be $canon_typ(typ_p))*

        4. If (((~$is_deft(typ') /\ ~$is_spect(typ')) /\ ~($is_obj(typ') /\ ~$is_externt(typ'))))*, then

          1. The relation holds

        4. Else

          1. Phantom#268

      2. Else

        1. Phantom#269

    2. Else

      1. Phantom#270

    3. Let typ' be $canon_typ(typ)

    4. If (typ' has type objtyp), then

      1. Let objtyp be (typ' as objtyp)

      2. If (objtyp matches pattern `ParserT%`), then

        1. Let (ParserT _paramtyp*) be objtyp

        2. (Let (_id _dir typ_p _val?) be pt)*

        3. (Let typ_p' be $canon_typ(typ_p))*

        4. If (((((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_controlt(typ_p')) /\ ~$is_packaget(typ_p')) /\ ~$is_tablet(typ_p')))*, then

          1. The relation holds

        4. Else

          1. Phantom#274

      2. Else If (objtyp matches pattern `ControlT%`), then

        1. Let (ControlT _paramtyp*) be objtyp

        2. (Let (_id _dir typ_p _val?) be pt)*

        3. (Let typ_p' be $canon_typ(typ_p))*

        4. If (((((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_parsert(typ_p')) /\ ~$is_packaget(typ_p')) /\ ~$is_tablet(typ_p')))*, then

          1. The relation holds

        4. Else

          1. Phantom#273

      2. Else If (objtyp matches pattern `PackageT%`), then

        1. Let (PackageT _typ*) be objtyp

        2. (Let (_id _dir typ_p _val?) be pt)*

        3. (Let typ_p' be $canon_typ(typ_p))*

        4. If (((~$is_deft(typ_p') /\ ~$is_spect(typ_p')) /\ ~$is_tablet(typ_p')))*, then

          1. The relation holds

        4. Else

          1. Phantom#271

      2. Else

        1. Phantom#272

    4. Else

      1. Phantom#275

  1. Else

    1. Phantom#276

1. Else

  1. Phantom#277

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:19.1-19.43
relation ConsDef_wf: tidset, (ConsD (tparam*, tparam_hidden*) -> constyp)

1. Let (ConsT _paramtyp* typ_r) be constyp

2. Let typ_r' be $canon_typ(typ_r)

3. If $is_externt(typ_r'), then

  1. If $distinct_<tid>(tparam* ++ tparam_hidden*), then

    1. Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* }))

    2. If (ConsType_wf: tidset' |- constyp holds), then

      1. The relation holds

    2. Else

      1. Phantom#278

  1. Else

    1. Phantom#279

3. Else

  1. Phantom#280

4. If $is_parsert(typ_r'), then

  1. If $distinct_<tid>(tparam* ++ tparam_hidden*), then

    1. Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* }))

    2. If (ConsType_wf: tidset' |- constyp holds), then

      1. The relation holds

    2. Else

      1. Phantom#281

  1. Else

    1. Phantom#282

4. Else

  1. Phantom#283

5. If $is_controlt(typ_r'), then

  1. If $distinct_<tid>(tparam* ++ tparam_hidden*), then

    1. Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* }))

    2. If (ConsType_wf: tidset' |- constyp holds), then

      1. The relation holds

    2. Else

      1. Phantom#284

  1. Else

    1. Phantom#285

5. Else

  1. Phantom#286

6. If $is_packaget(typ_r'), then

  1. If $distinct_<tid>(tparam* ++ tparam_hidden*), then

    1. Let tidset' be $union_set<tid>(tidset, ({ tparam* ++ tparam_hidden* }))

    2. If (ConsType_wf: tidset' |- constyp holds), then

      1. The relation holds

    2. Else

      1. Phantom#287

  1. Else

    1. Phantom#288

6. Else

  1. Phantom#289

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:37.1-37.31
def $nestable_deft(typ)

1. Return $nestable'_deft($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:38.1-38.32
def $nestable'_deft(typ)

1. If (typ has type basetyp), then

  1. Let basetyp be (typ as basetyp)

  2. Return (~$is_voidt((basetyp as typ)) /\ ~$is_matchkindt((basetyp as typ)))

1. Else If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

1. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:52.1-52.31
def $nestable_newt(typ)

1. Return $nestable'_newt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:53.1-53.32
def $nestable'_newt(typ)

1. If (typ = ((BoolT) as typ)), then

  1. Return true

2. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

2. Else If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

2. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:73.1-73.33
def $nestable_senumt(typ)

1. Return $nestable'_senumt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:74.1-74.34
def $nestable'_senumt(typ'')

1. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

1. Else If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

1. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $nestable_newt_in_senumt(typ'')

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:75.1-75.41
def $nestable_newt_in_senumt(typ)

1. Return $nestable_newt_in_senumt'($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:76.1-76.42
def $nestable_newt_in_senumt'(typ)

1. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

1. Else If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

1. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:100.1-100.32
def $nestable_listt(typ)

1. Return $nestable'_listt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:101.1-101.33
def $nestable'_listt(typ)

1. If (typ has type basetyp), then

  1. Let basetyp be (typ as basetyp)

  2. Return ~$is_voidt((basetyp as typ))

1. Else If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

1. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:114.1-114.33
def $nestable_tuplet(typ)

1. Return $nestable'_tuplet($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:115.1-115.34
def $nestable'_tuplet(typ)

1. If (typ = ((ErrT) as typ)), then

  1. Return true

2. If (typ = ((BoolT) as typ)), then

  1. Return true

3. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. Return ~$is_intt((numtyp as typ))

3. Else If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

3. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. Return ~$is_listt((datatyp as typ))

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:131.1-131.33
def $nestable_stackt(typ)

1. Return $nestable'_stackt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:132.1-132.34
def $nestable'_stackt(typ)

1. If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT tid) be abstyp

    2. Return true

1. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id _(member, typ)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id _(member, typ)*) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:147.1-147.34
def $nestable_structt(typ)

1. Return $nestable'_structt($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:148.1-148.35
def $nestable'_structt(typ)

1. If (typ = ((ErrT) as typ)), then

  1. Return true

2. If (typ = ((BoolT) as typ)), then

  1. Return true

3. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. Return ~$is_intt((numtyp as typ))

3. Else If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

3. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. Return ~$is_listt((datatyp as typ))

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:165.1-165.34
def $nestable_headert(typ)

1. Return $nestable'_headert($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:166.1-166.35
def $nestable'_headert(typ'')

1. If (typ'' = ((BoolT) as typ)), then

  1. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. Return ~$is_intt((numtyp as typ))

2. Else If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

2. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id _typ _(member, val)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id (_member, typ'')*) be datatyp

    2. If ($nestable_structt_in_headert(typ''))*, then

      1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:167.1-167.45
def $nestable_structt_in_headert(typ)

1. Return $nestable'_structt_in_headert($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:168.1-168.46
def $nestable'_structt_in_headert(typ'')

1. If (typ'' = ((BoolT) as typ)), then

  1. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

2. Else If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

2. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id _typ _(member, val)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id (_member, typ'')*) be datatyp

    2. If ($nestable_structt_in_headert(typ''))*, then

      1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:199.1-199.33
def $nestable_uniont(typ)

1. Return $nestable'_uniont($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:200.1-200.34
def $nestable'_uniont(typ)

1. If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

1. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id _(member, typ)*) be datatyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:262.1-262.31
def $nestable_sett(typ)

1. Return $nestable'_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:263.1-263.32
def $nestable'_sett(typ'')

1. If (typ'' = ((ErrT) as typ)), then

  1. Return true

2. If (typ'' = ((BoolT) as typ)), then

  1. Return true

3. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

3. Else If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

3. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id _member*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id _typ _(member, val)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. If ($nestable_tuplet_in_sett(typ''))*, then

      1. Return true

3. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT typ''*) be synthtyp

    2. If ($nestable_seqt_in_sett(typ''))*, then

      1. Return true

4. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:264.1-264.41
def $nestable_tuplet_in_sett(typ)

1. Return $nestable'_tuplet_in_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:265.1-265.42
def $nestable'_tuplet_in_sett(typ'')

1. If (typ'' = ((BoolT) as typ)), then

  1. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

2. Else If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

2. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id _member*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id _typ _(member, val)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. If ($nestable_tuplet_in_sett(typ''))*, then

      1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:266.1-266.39
def $nestable_seqt_in_sett(typ)

1. Return $nestable'_seqt_in_sett($canon_typ(typ))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:267.1-267.40
def $nestable'_seqt_in_sett(typ'')

1. If (typ'' = ((BoolT) as typ)), then

  1. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

2. Else If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

2. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id _member*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id _typ _(member, val)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. If ($nestable_seqt_in_sett(typ''))*, then

      1. Return true

2. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT typ''*) be synthtyp

    2. If ($nestable_seqt_in_sett(typ''))*, then

      1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:339.1-339.32
def $nestable_monod(typ)

1. If (typ has type abstyp), then

  1. Let abstyp be (typ as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT _id) be abstyp

    2. Return true

1. Else If (typ has type aliastyp), then

  1. Let (DefT _typ) be (typ as aliastyp)

  2. Return true

1. Else If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id _typ) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT _id _member*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id _typ _(member, val)*) be datatyp

    2. Return true

1. Else If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `TableT%%`), then

    1. Let (TableT _id _typ) be objtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:355.1-355.32
def $nestable_polyd(typ)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT _typ*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT _typ _int) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id _(member, typ)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id _(member, typ)*) be datatyp

    2. Return true

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id _(member, typ)*) be datatyp

    2. Return true

1. Else If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT _id _map<fid, funcdef>) be objtyp

    2. Return true

  2. Else If (objtyp matches pattern `ParserT%`), then

    1. Let (ParserT _paramtyp*) be objtyp

    2. Return true

  2. Else If (objtyp matches pattern `ControlT%`), then

    1. Let (ControlT _paramtyp*) be objtyp

    2. Return true

  2. Else If (objtyp matches pattern `PackageT%`), then

    1. Let (PackageT _typ*) be objtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:406.1-407.38
def $is_trailing_action(dir*)

1. Return $is_trailing_action'(true, $rev_<dir>(dir*))

;; ../../../../spec/2c6-runtime-type-wellformed.watsup:408.1-408.44
def $is_trailing_action'(_bool', dir*)

1. If (dir* matches pattern []), then

  1. Return true

1. Else If (dir* matches pattern _ :: _), then

  1. Let dir_h :: dir_t* be dir*

  2. If ~(dir_h matches pattern `NO`), then

    1. Return $is_trailing_action'(false, dir_t*)

  2. Else

    1. Phantom#290

2. If (_bool' = true), then

  1. If (dir* matches pattern _ :: _), then

    1. Let dir :: dir_t* be dir*

    2. If (dir matches pattern `NO`), then

      1. Return $is_trailing_action'(true, dir_t*)

    2. Else

      1. Phantom#294

  1. Else

    1. Phantom#295

2. Else If (_bool' = false), then

  1. If (dir* matches pattern _ :: _), then

    1. Let dir :: dir_t* be dir*

    2. If (dir matches pattern `NO`), then

      1. Return false

    2. Else

      1. Phantom#291

  1. Else

    1. Phantom#292

2. Else

  1. Phantom#293

;; ../../../../spec/2d1-runtime-numerics.watsup:5.1-5.21
def $pow2



;; ../../../../spec/2d1-runtime-numerics.watsup:7.1-7.25
def $shl



;; ../../../../spec/2d1-runtime-numerics.watsup:8.1-8.25
def $shr



;; ../../../../spec/2d1-runtime-numerics.watsup:9.1-9.36
def $shr_arith



;; ../../../../spec/2d1-runtime-numerics.watsup:11.1-11.21
def $bneg



;; ../../../../spec/2d1-runtime-numerics.watsup:12.1-12.26
def $band



;; ../../../../spec/2d1-runtime-numerics.watsup:13.1-13.26
def $bxor



;; ../../../../spec/2d1-runtime-numerics.watsup:14.1-14.25
def $bor



;; ../../../../spec/2d1-runtime-numerics.watsup:16.1-16.33
def $bitacc



;; ../../../../spec/2d1-runtime-numerics.watsup:22.1-23.32
def $un_op(unop, val)

1. If (unop matches pattern `BNOT`), then

  1. Return $un_bnot(val)

1. Else If (unop matches pattern `LNOT`), then

  1. Return $un_lnot(val)

1. Else If (unop matches pattern `UPLUS`), then

  1. Return $un_plus(val)

1. Else If (unop matches pattern `UMINUS`), then

  1. Return $un_minus(val)

;; ../../../../spec/2d1-runtime-numerics.watsup:27.1-27.24
def $un_bnot(val)

1. If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs) be val

  2. Let i be $bneg(bs)

  3. Return (FBitV w $to_bitstr((w as int), $bneg(bs)))

1. Else

  1. Phantom#296

;; ../../../../spec/2d1-runtime-numerics.watsup:36.1-36.24
def $un_lnot(val)

1. If (val matches pattern `BoolV%`), then

  1. Let (BoolV b) be val

  2. Return (BoolV ~b)

1. Else

  1. Phantom#297

;; ../../../../spec/2d1-runtime-numerics.watsup:44.1-44.24
def $un_plus(val)

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i) be val

  2. Return (IntV i)

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs) be val

  2. Return (FIntV w bs)

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs) be val

  2. Return (FBitV w bs)

1. Else

  1. Phantom#298

;; ../../../../spec/2d1-runtime-numerics.watsup:54.1-54.25
def $un_minus(val)

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i) be val

  2. Return (IntV -i)

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs) be val

  2. Let bs' be $to_bitstr((w as int), $to_int((w as int), -bs))

  3. Return (FIntV w bs')

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs) be val

  2. Let bs' be ($pow2(w) - bs)

  3. Return (FBitV w bs')

1. Else

  1. Phantom#299

;; ../../../../spec/2d1-runtime-numerics.watsup:70.1-71.24
def $bin_op(binop, val_l, val_r)

1. If (binop matches pattern `PLUS`), then

  1. Return $bin_plus(val_l, val_r)

1. Else If (binop matches pattern `MINUS`), then

  1. Return $bin_minus(val_l, val_r)

1. Else If (binop matches pattern `MUL`), then

  1. Return $bin_mul(val_l, val_r)

1. Else If (binop matches pattern `DIV`), then

  1. Return $bin_div(val_l, val_r)

1. Else If (binop matches pattern `MOD`), then

  1. Return $bin_mod(val_l, val_r)

1. Else If (binop matches pattern `SHL`), then

  1. Return $bin_shl(val_l, val_r)

1. Else If (binop matches pattern `SHR`), then

  1. Return $bin_shr(val_l, val_r)

1. Else If (binop matches pattern `LE`), then

  1. Return (BoolV $bin_le(val_l, val_r))

1. Else If (binop matches pattern `GE`), then

  1. Return (BoolV $bin_ge(val_l, val_r))

1. Else If (binop matches pattern `LT`), then

  1. Return (BoolV $bin_lt(val_l, val_r))

1. Else If (binop matches pattern `GT`), then

  1. Return (BoolV $bin_gt(val_l, val_r))

1. Else If (binop matches pattern `EQ`), then

  1. Return (BoolV $bin_eq(val_l, val_r))

1. Else If (binop matches pattern `NE`), then

  1. Return (BoolV ~$bin_eq(val_l, val_r))

1. Else If (binop matches pattern `BAND`), then

  1. Return $bin_band(val_l, val_r)

1. Else If (binop matches pattern `BXOR`), then

  1. Return $bin_bxor(val_l, val_r)

1. Else If (binop matches pattern `BOR`), then

  1. Return $bin_bor(val_l, val_r)

1. Else If (binop matches pattern `CONCAT`), then

  1. Return $bin_concat(val_l, val_r)

1. Else If (binop matches pattern `LAND`), then

  1. Return $bin_land(val_l, val_r)

1. Else If (binop matches pattern `LOR`), then

  1. Return $bin_lor(val_l, val_r)

1. Else

  1. Phantom#300

;; ../../../../spec/2d1-runtime-numerics.watsup:75.1-75.30
def $bin_plus(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (IntV (i_l + i_r))

  2. Else

    1. Phantom#306

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let bs be $to_bitstr((w as int), (i_l + i_r))

      4. Return (FIntV w bs)

    2. Else

      1. Phantom#304

  2. Else

    1. Phantom#305

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let bs be $to_bitstr((w as int), (i_l + i_r))

      4. Return (FBitV w bs)

    2. Else

      1. Phantom#301

  2. Else

    1. Phantom#302

1. Else

  1. Phantom#303

;; ../../../../spec/2d1-runtime-numerics.watsup:93.1-93.31
def $bin_minus(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (IntV (i_l - i_r))

  2. Else

    1. Phantom#312

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let bs be $to_bitstr((w as int), (i_l - i_r))

      4. Return (FIntV w bs)

    2. Else

      1. Phantom#310

  2. Else

    1. Phantom#311

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let bs be $to_bitstr((w as int), (i_l - i_r))

      4. Return (FBitV w bs)

    2. Else

      1. Phantom#307

  2. Else

    1. Phantom#308

1. Else

  1. Phantom#309

;; ../../../../spec/2d1-runtime-numerics.watsup:111.1-111.29
def $bin_mul(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (IntV (i_l * i_r))

  2. Else

    1. Phantom#318

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let bs be $to_bitstr((w as int), (i_l * i_r))

      4. Return (FIntV w bs)

    2. Else

      1. Phantom#316

  2. Else

    1. Phantom#317

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let bs be $to_bitstr((w as int), (i_l * i_r))

      4. Return (FBitV w bs)

    2. Else

      1. Phantom#313

  2. Else

    1. Phantom#314

1. Else

  1. Phantom#315

;; ../../../../spec/2d1-runtime-numerics.watsup:127.1-127.29
def $bin_div(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (IntV (i_l / i_r))

  2. Else

    1. Phantom#319

1. Else

  1. Phantom#320

;; ../../../../spec/2d1-runtime-numerics.watsup:135.1-135.29
def $bin_mod(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (IntV (i_l \ i_r))

  2. Else

    1. Phantom#321

1. Else

  1. Phantom#322

;; ../../../../spec/2d1-runtime-numerics.watsup:143.1-143.29
def $bin_shl(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (IntV $shl(i_l, i_r))

  2. Else If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV w_r bs_r) be val'

    2. Let i_r be $to_int((w_r as int), bs_r)

    3. Return (IntV $shl(i_l, i_r))

  2. Else If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV w_r bs_r) be val'

    2. Return (IntV $shl(i_l, bs_r))

  2. Else

    1. Phantom#326

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w_l bs_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Let val_r be (FIntV w_l $to_int((w_l as int), i_r))

    3. Return $bin_shl((FIntV w_l bs_l), val_r)

  2. Else If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV w_r bs_r) be val'

    2. Let i_l be $to_int((w_l as int), bs_l)

    3. Let i_r be $to_int((w_r as int), bs_r)

    4. Let i be $shl(i_l, i_r)

    5. Return (FIntV w_l $to_bitstr((w_l as int), i))

  2. Else If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV w_r bs_r) be val'

    2. Let i_l be $to_int((w_l as int), bs_l)

    3. Let i be $shl(i_l, bs_r)

    4. Return (FIntV w_l $to_bitstr((w_l as int), i))

  2. Else

    1. Phantom#325

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w_l bs_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Let val_r be (FBitV w_l $to_int((w_l as int), i_r))

    3. Return $bin_shl((FBitV w_l bs_l), val_r)

  2. Else If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV w_r bs_r) be val'

    2. Let i_r be $to_int((w_r as int), bs_r)

    3. Let i be $shl(bs_l, i_r)

    4. Return (FBitV w_l $to_bitstr((w_l as int), i))

  2. Else If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV w_r bs_r) be val'

    2. Let i be $shl(bs_l, bs_r)

    3. Return (FBitV w_l $to_bitstr((w_l as int), i))

  2. Else

    1. Phantom#323

1. Else

  1. Phantom#324

;; ../../../../spec/2d1-runtime-numerics.watsup:176.1-176.29
def $bin_shr(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (IntV $shr(i_l, i_r))

  2. Else If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV w_r bs_r) be val'

    2. Let i_r be $to_int((w_r as int), bs_r)

    3. Return (IntV $shr(i_l, i_r))

  2. Else If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV w_r bs_r) be val'

    2. Return (IntV $shr(i_l, bs_r))

  2. Else

    1. Phantom#336

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w_l bs_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Let i_l be $to_int((w_l as int), bs_l)

    3. If (i_l < (0 as int)), then

      1. Let i be $shr_arith(bs_l, i_r, ($pow2(w_l) - (1 as int)))

      2. Return (FIntV w_l $to_bitstr((w_l as int), i))

    3. Else

      1. Phantom#334

    4. If (i_l >= (0 as int)), then

      1. Let i be $shr(bs_l, i_r)

      2. Return (FIntV w_l $to_bitstr((w_l as int), i))

    4. Else

      1. Phantom#335

  2. Else If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV w_r bs_r) be val'

    2. Let i_l be $to_int((w_l as int), bs_l)

    3. Let i_r be $to_int((w_r as int), bs_r)

    4. If (i_l < (0 as int)), then

      1. Let i be $shr_arith(bs_l, i_r, ($pow2(w_l) - (1 as int)))

      2. Return (FIntV w_l $to_bitstr((w_l as int), i))

    4. Else

      1. Phantom#332

    5. If (i_l >= (0 as int)), then

      1. Let i be $shr(bs_l, i_r)

      2. Return (FIntV w_l $to_bitstr((w_l as int), i))

    5. Else

      1. Phantom#333

  2. Else If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV w_r bs_r) be val'

    2. Let i_l be $to_int((w_l as int), bs_l)

    3. If (i_l < (0 as int)), then

      1. Let i be $shr_arith(bs_l, bs_r, ($pow2(w_l) - (1 as int)))

      2. Return (FIntV w_l $to_bitstr((w_l as int), i))

    3. Else

      1. Phantom#329

    4. If (i_l >= (0 as int)), then

      1. Let i be $shr(bs_l, bs_r)

      2. Return (FIntV w_l $to_bitstr((w_l as int), i))

    4. Else

      1. Phantom#330

  2. Else

    1. Phantom#331

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w_l bs_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Let val_r be (FBitV w_l $to_int((w_l as int), i_r))

    3. Return $bin_shr((FBitV w_l bs_l), val_r)

  2. Else If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV w_r bs_r) be val'

    2. Let i_r be $to_int((w_r as int), bs_r)

    3. Let i be $shr(bs_l, i_r)

    4. Return (FBitV w_l $to_bitstr((w_l as int), i))

  2. Else If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV w_r bs_r) be val'

    2. Let i be $shr(bs_l, bs_r)

    3. Return (FBitV w_l $to_bitstr((w_l as int), i))

  2. Else

    1. Phantom#327

1. Else

  1. Phantom#328

;; ../../../../spec/2d1-runtime-numerics.watsup:229.1-229.29
def $bin_le(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (i_l <= i_r)

  2. Else

    1. Phantom#342

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Return (i_l <= i_r)

    2. Else

      1. Phantom#340

  2. Else

    1. Phantom#341

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Return (bs_l <= bs_r)

    2. Else

      1. Phantom#337

  2. Else

    1. Phantom#338

1. Else

  1. Phantom#339

;; ../../../../spec/2d1-runtime-numerics.watsup:241.1-241.29
def $bin_ge(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (i_l >= i_r)

  2. Else

    1. Phantom#348

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Return (i_l >= i_r)

    2. Else

      1. Phantom#346

  2. Else

    1. Phantom#347

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Return (bs_l >= bs_r)

    2. Else

      1. Phantom#343

  2. Else

    1. Phantom#344

1. Else

  1. Phantom#345

;; ../../../../spec/2d1-runtime-numerics.watsup:253.1-253.29
def $bin_lt(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (i_l < i_r)

  2. Else

    1. Phantom#354

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Return (i_l < i_r)

    2. Else

      1. Phantom#352

  2. Else

    1. Phantom#353

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Return (bs_l < bs_r)

    2. Else

      1. Phantom#349

  2. Else

    1. Phantom#350

1. Else

  1. Phantom#351

;; ../../../../spec/2d1-runtime-numerics.watsup:265.1-265.29
def $bin_gt(val, val')

1. If (val matches pattern `IntV%`), then

  1. Let (IntV i_l) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_r) be val'

    2. Return (i_l > i_r)

  2. Else

    1. Phantom#360

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Return (i_l > i_r)

    2. Else

      1. Phantom#358

  2. Else

    1. Phantom#359

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Return (bs_l > bs_r)

    2. Else

      1. Phantom#355

  2. Else

    1. Phantom#356

1. Else

  1. Phantom#357

;; ../../../../spec/2d1-runtime-numerics.watsup:277.1-277.29
def $bin_eq(val, val')

1. If (val matches pattern `ErrV%`), then

  1. Let (ErrV member_a) be val

  2. If (val' matches pattern `ErrV%`), then

    1. Let (ErrV member_b) be val'

    2. Return (member_a = member_b)

  2. Else

    1. Phantom#381

1. Else If (val matches pattern `MatchKindV%`), then

  1. Let (MatchKindV member_a) be val

  2. If (val' matches pattern `MatchKindV%`), then

    1. Let (MatchKindV member_b) be val'

    2. Return (member_a = member_b)

  2. Else

    1. Phantom#380

1. Else If (val matches pattern `StrV%`), then

  1. Let (StrV text_a) be val

  2. If (val' matches pattern `StrV%`), then

    1. Let (StrV text_b) be val'

    2. Return (text_a = text_b)

  2. Else

    1. Phantom#379

1. Else If (val matches pattern `BoolV%`), then

  1. Let (BoolV b_a) be val

  2. If (val' matches pattern `BoolV%`), then

    1. Let (BoolV b_b) be val'

    2. Return (b_a = b_b)

  2. Else

    1. Phantom#378

1. Else If (val matches pattern `IntV%`), then

  1. Let (IntV i_a) be val

  2. If (val' matches pattern `IntV%`), then

    1. Let (IntV i_b) be val'

    2. Return (i_a = i_b)

  2. Else

    1. Phantom#377

1. Else If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_a) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_b) be val'

    2. If (w = nat), then

      1. Return (bs_a = bs_b)

    2. Else

      1. Phantom#375

  2. Else

    1. Phantom#376

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_a) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_b) be val'

    2. If (w = nat), then

      1. Return (bs_a = bs_b)

    2. Else

      1. Phantom#373

  2. Else

    1. Phantom#374

1. Else If (val matches pattern `VBitV%%%`), then

  1. Let (VBitV w _width bs_a) be val

  2. If (val' matches pattern `VBitV%%%`), then

    1. Let (VBitV nat _width' bs_b) be val'

    2. If (w = nat), then

      1. Return (bs_a = bs_b)

    2. Else

      1. Phantom#371

  2. Else

    1. Phantom#372

1. Else If (val matches pattern `EnumFieldV%%`), then

  1. Let (EnumFieldV id_a member_a) be val

  2. If (val' matches pattern `EnumFieldV%%`), then

    1. Let (EnumFieldV id_b member_b) be val'

    2. Return ((id_a = id_b) /\ (member_a = member_b))

  2. Else

    1. Phantom#370

1. Else If (val matches pattern `SEnumFieldV%%%`), then

  1. Let (SEnumFieldV id_a member_a val_a) be val

  2. If (val' matches pattern `SEnumFieldV%%%`), then

    1. Let (SEnumFieldV id_b member_b val_b) be val'

    2. Return (((id_a = id_b) /\ (member_a = member_b)) /\ $bin_eq(val_a, val_b))

  2. Else

    1. Phantom#369

1. Else If (val matches pattern `ListV%`), then

  1. Let (ListV val_a*) be val

  2. If (val' matches pattern `ListV%`), then

    1. Let (ListV val_b*) be val'

    2. Return $bin_eqs(val_a*, val_b*)

  2. Else

    1. Phantom#368

1. Else If (val matches pattern `TupleV%`), then

  1. Let (TupleV val_a*) be val

  2. If (val' matches pattern `TupleV%`), then

    1. Let (TupleV val_b*) be val'

    2. Return $bin_eqs(val_a*, val_b*)

  2. Else

    1. Phantom#367

1. Else If (val matches pattern `StackV%%%`), then

  1. Let (StackV val_a* _int i_size_a) be val

  2. If (val' matches pattern `StackV%%%`), then

    1. Let (StackV val_b* _int' i_size_b) be val'

    2. Return ($bin_eqs(val_a*, val_b*) /\ (i_size_a = i_size_b))

  2. Else

    1. Phantom#366

1. Else If (val matches pattern `StructV%%`), then

  1. Let (StructV id_a (member_a, val_a)*) be val

  2. If (val' matches pattern `StructV%%`), then

    1. Let (StructV id_b (member_b, val_b)*) be val'

    2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*, (member_b, val_b)*))

  2. Else

    1. Phantom#365

1. Else If (val matches pattern `HeaderV%%`), then

  1. Let (HeaderV id_a (member_a, val_a)*) be val

  2. If (val' matches pattern `StructV%%`), then

    1. Let (StructV id_b (member_b, val_b)*) be val'

    2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*, (member_b, val_b)*))

  2. Else

    1. Phantom#364

1. Else If (val matches pattern `UnionV%%`), then

  1. Let (UnionV id_a (member_a, val_a)*) be val

  2. If (val' matches pattern `StructV%%`), then

    1. Let (StructV id_b (member_b, val_b)*) be val'

    2. Return ((id_a = id_b) /\ $bin_eqs_((member_a, val_a)*, (member_b, val_b)*))

  2. Else

    1. Phantom#363

1. Else If (val matches pattern `InvalidV`), then

  1. If (val' matches pattern `InvalidV`), then

    1. Return true

  1. Else

    1. Phantom#361

1. Else

  1. Phantom#362

;; ../../../../spec/2d1-runtime-numerics.watsup:278.1-278.32
def $bin_eqs(val*, val*')

1. If (val* matches pattern []), then

  1. If (val*' matches pattern []), then

    1. Return true

  1. Else If (val*' matches pattern _ :: _), then

    1. Let _val :: _val* be val*'

    2. Return false

1. Else If (val* matches pattern _ :: _), then

  1. Let _val :: _val* be val*

  2. If (val*' matches pattern []), then

    1. Return false

  2. Else

    1. Phantom#382

  3. Let val_ah :: val_at* be val*

  4. If (val*' matches pattern _ :: _), then

    1. Let val_bh :: val_bt* be val*'

    2. Return ($bin_eq(val_ah, val_bh) /\ $bin_eqs(val_at*, val_bt*))

  4. Else

    1. Phantom#383

;; ../../../../spec/2d1-runtime-numerics.watsup:279.1-279.53
def $bin_eqs_((member, val)*, (member, val)*')

1. If ((member, val)* matches pattern []), then

  1. If ((member, val)*' matches pattern []), then

    1. Return true

  1. Else If ((member, val)*' matches pattern _ :: _), then

    1. Let _(member, val) :: _(member, val)* be (member, val)*'

    2. Return false

1. Else If ((member, val)* matches pattern _ :: _), then

  1. Let _(member, val) :: _(member, val)* be (member, val)*

  2. If ((member, val)*' matches pattern []), then

    1. Return false

  2. Else

    1. Phantom#384

  3. Let (member, val_a) :: (member_at, val_at)* be (member, val)*

  4. If ((member, val)*' matches pattern _ :: _), then

    1. Let (member', val_b) :: (member_bt, val_bt)* be (member, val)*'

    2. If (member = member'), then

      1. Return ($bin_eq(val_a, val_b) /\ $bin_eqs_((member_at, val_at)*, (member_bt, val_bt)*))

    2. Else

      1. Phantom#385

  4. Else

    1. Phantom#386

;; ../../../../spec/2d1-runtime-numerics.watsup:325.1-325.30
def $bin_band(val, val')

1. If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let i be $band(i_l, i_r)

      4. Return (FIntV w $to_bitstr((w as int), i))

    2. Else

      1. Phantom#390

  2. Else

    1. Phantom#391

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i be $band(bs_l, bs_r)

      2. Return (FBitV w $to_bitstr((w as int), i))

    2. Else

      1. Phantom#387

  2. Else

    1. Phantom#388

1. Else

  1. Phantom#389

;; ../../../../spec/2d1-runtime-numerics.watsup:341.1-341.30
def $bin_bxor(val, val')

1. If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let i be $bxor(i_l, i_r)

      4. Return (FIntV w $to_bitstr((w as int), i))

    2. Else

      1. Phantom#395

  2. Else

    1. Phantom#396

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i be $bxor(bs_l, bs_r)

      2. Return (FBitV w $to_bitstr((w as int), i))

    2. Else

      1. Phantom#392

  2. Else

    1. Phantom#393

1. Else

  1. Phantom#394

;; ../../../../spec/2d1-runtime-numerics.watsup:357.1-357.29
def $bin_bor(val, val')

1. If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i_l be $to_int((w as int), bs_l)

      2. Let i_r be $to_int((w as int), bs_r)

      3. Let i be $bor(i_l, i_r)

      4. Return (FIntV w $to_bitstr((w as int), i))

    2. Else

      1. Phantom#400

  2. Else

    1. Phantom#401

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w bs_l) be val

  2. If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV nat bs_r) be val'

    2. If (w = nat), then

      1. Let i be $bor(bs_l, bs_r)

      2. Return (FBitV w $to_bitstr((w as int), i))

    2. Else

      1. Phantom#397

  2. Else

    1. Phantom#398

1. Else

  1. Phantom#399

;; ../../../../spec/2d1-runtime-numerics.watsup:373.1-373.32
def $bin_concat(val, val')

1. If (val matches pattern `FIntV%%`), then

  1. Let (FIntV w_l bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV w_r bs_r) be val'

    2. Let i_l be $to_int((w_l as int), bs_l)

    3. Let i_l' be $shl(i_l, (w_r as int))

    4. Let i_l'' be (i_l' + bs_r)

    5. Let w be (w_l + w_r)

    6. Return (FIntV w $to_bitstr((w as int), i_l''))

  2. Else If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV w_r bs_r) be val'

    2. Let i_l be $to_int((w_l as int), bs_l)

    3. Let i_l' be $shl(i_l, (w_r as int))

    4. Let i_l'' be (i_l' + bs_r)

    5. Let w be (w_l + w_r)

    6. Return (FIntV w $to_bitstr((w as int), i_l''))

  2. Else

    1. Phantom#404

1. Else If (val matches pattern `FBitV%%`), then

  1. Let (FBitV w_l bs_l) be val

  2. If (val' matches pattern `FIntV%%`), then

    1. Let (FIntV w_r bs_r) be val'

    2. Let i_l be $shl(bs_l, (w_r as int))

    3. Let i_l' be (i_l + bs_r)

    4. Let w be (w_l + w_r)

    5. Return (FBitV w $to_bitstr((w as int), i_l'))

  2. Else If (val' matches pattern `FBitV%%`), then

    1. Let (FBitV w_r bs_r) be val'

    2. Let i_l be $shl(bs_l, (w_r as int))

    3. Let i_l' be (i_l + bs_r)

    4. Let w be (w_l + w_r)

    5. Return (FBitV w $to_bitstr((w as int), i_l'))

  2. Else

    1. Phantom#402

1. Else

  1. Phantom#403

;; ../../../../spec/2d1-runtime-numerics.watsup:402.1-402.30
def $bin_land(val, val')

1. If (val matches pattern `BoolV%`), then

  1. Let (BoolV b_l) be val

  2. If (val' matches pattern `BoolV%`), then

    1. Let (BoolV b_r) be val'

    2. Return (BoolV (b_l /\ b_r))

  2. Else

    1. Phantom#405

1. Else

  1. Phantom#406

;; ../../../../spec/2d1-runtime-numerics.watsup:410.1-410.29
def $bin_lor(val, val')

1. If (val matches pattern `BoolV%`), then

  1. Let (BoolV b_l) be val

  2. If (val' matches pattern `BoolV%`), then

    1. Let (BoolV b_r) be val'

    2. Return (BoolV (b_l \/ b_r))

  2. Else

    1. Phantom#407

1. Else

  1. Phantom#408

;; ../../../../spec/2d1-runtime-numerics.watsup:420.1-421.21
def $cast_op(typ, val'')

1. If (val'' matches pattern `BoolV%`), then

  1. Let (BoolV b) be val''

  2. Return $cast_bool(typ, b)

1. Else If (val'' matches pattern `IntV%`), then

  1. Let (IntV i) be val''

  2. Return $cast_int(typ, i)

1. Else If (val'' matches pattern `FIntV%%`), then

  1. Let (FIntV w bs) be val''

  2. Return $cast_fint(typ, w, bs)

1. Else If (val'' matches pattern `FBitV%%`), then

  1. Let (FBitV w bs) be val''

  2. Return $cast_fbit(typ, w, bs)

1. Else If (val'' matches pattern `SEnumFieldV%%%`), then

  1. Let (SEnumFieldV _id _member val'') be val''

  2. Return $cast_op(typ, val'')

1. Else If (val'' matches pattern `StructV%%`), then

  1. Let (StructV id (member, val'')*) be val''

  2. Return $cast_struct(typ, id, (member, val'')*)

1. Else If (val'' matches pattern `HeaderV%%`), then

  1. Let (HeaderV id (member, val'')*) be val''

  2. Return $cast_header(typ, id, (member, val'')*)

1. Else If (val'' matches pattern `SeqV%`), then

  1. Let (SeqV val''*) be val''

  2. Return $cast_seq(typ, val''*)

1. Else If (val'' matches pattern `RecordV%`), then

  1. Let (RecordV (member, val'')*) be val''

  2. Return $cast_record(typ, (member, val'')*)

1. Else If (val'' matches pattern `DefaultV`), then

  1. Return $default(typ)

1. Else If (val'' matches pattern `SetV%`), then

  1. Let (SetV setval) be val''

  2. If (setval matches pattern `SingletonSet%`), then

    1. Let (SingletonSet val'') be setval

    2. Return $cast_set_singleton(typ, val'')

  2. Else If (setval matches pattern `MaskSet%%`), then

    1. Let (MaskSet val_b val_m) be setval

    2. Return $cast_set_mask(typ, val_b, val_m)

  2. Else If (setval matches pattern `RangeSet%%`), then

    1. Let (RangeSet val_l val_u) be setval

    2. Return $cast_set_range(typ, val_l, val_u)

1. Else

  1. Phantom#409

;; ../../../../spec/2d1-runtime-numerics.watsup:423.1-423.24
def $default(typ)

1. Return $default'($canon_typ(typ))

;; ../../../../spec/2d1-runtime-numerics.watsup:424.1-424.25
def $default'(typ'')

1. If (typ'' = ((ErrT) as typ)), then

  1. Return (ErrV "NoError")

1. Else

  1. Phantom#410

2. If (typ'' = ((StrT) as typ)), then

  1. Return (StrV "")

2. Else

  1. Phantom#411

3. If (typ'' = ((BoolT) as typ)), then

  1. Return (BoolV false)

3. Else

  1. Phantom#412

4. If (typ'' = ((IntT) as typ)), then

  1. Return (IntV (0 as int))

4. Else

  1. Phantom#413

5. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. Return (FIntV w (0 as bitstr))

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. Return (FBitV w (0 as bitstr))

  2. Else If (numtyp matches pattern `VBitT%`), then

    1. Let (VBitT w) be numtyp

    2. Return (VBitV w 0 (0 as bitstr))

  2. Else

    1. Phantom#420

5. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `EnumT%%`), then

    1. Let (EnumT id member*) be datatyp

    2. If (member* matches pattern _ :: _), then

      1. Let member_h :: _member* be member*

      2. Return (EnumFieldV id member_h)

    2. Else

      1. Phantom#418

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT id typ'' (member, val)*) be datatyp

    2. Let val_zero be $cast_int(typ'', (0 as int))

    3. Let member? be $assoc_<val, member>(val_zero, (val, member)*)

    4. If (member? matches pattern (_)), then

      1. Let ?(member_zero) be member?

      2. Return (SEnumFieldV id member_zero val_zero)

    4. Else

      1. Phantom#416

    5. If (?() = $assoc_<val, member>(val_zero, (val, member)*)), then

      1. Return (SEnumFieldV id "__UNSPECIFIED" val_zero)

    5. Else

      1. Phantom#417

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. Return (TupleV $default(typ'')*)

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ'' int) be datatyp

    2. If (int has type nat), then

      1. Let n_s be (int as nat)

      2. Let val* be $repeat_<val>($default(typ''), n_s)

      3. Return (StackV val* (0 as int) (n_s as int))

    2. Else

      1. Phantom#415

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT id (member, typ'')*) be datatyp

    2. Return (StructV id (member, $default(typ''))*)

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT id (member, typ'')*) be datatyp

    2. Return (HeaderV id (member, $default(typ''))*)

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT id (member, typ'')*) be datatyp

    2. Return (UnionV id (member, $default(typ''))*)

  2. Else

    1. Phantom#414

5. Else

  1. Phantom#419

;; ../../../../spec/2d1-runtime-numerics.watsup:428.1-428.32
def $cast_bool(typ, b)

1. Return $cast_bool'($canon_typ(typ), b)

;; ../../../../spec/2d1-runtime-numerics.watsup:429.1-429.33
def $cast_bool'(typ'', b')

1. If (typ'' = ((BoolT) as typ)), then

  1. Return (BoolV b')

1. Else

  1. Phantom#421

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. If (b' = true), then

      1. Return (FBitV w (1 as bitstr))

    2. Else If (b' = false), then

      1. Return (FBitV w (0 as bitstr))

    2. Else

      1. Phantom#424

  2. Else

    1. Phantom#425

2. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $cast_bool(typ'', b')

  2. Else

    1. Phantom#422

2. Else

  1. Phantom#423

;; ../../../../spec/2d1-runtime-numerics.watsup:442.1-442.30
def $cast_int(typ, i)

1. Return $cast_int'($canon_typ(typ), i)

;; ../../../../spec/2d1-runtime-numerics.watsup:443.1-443.31
def $cast_int'(typ'', i)

1. If (typ'' = ((BoolT) as typ)), then

  1. Return (BoolV (i = (0 as int)))

1. Else

  1. Phantom#426

2. If (typ'' = ((IntT) as typ)), then

  1. Return (IntV i)

2. Else

  1. Phantom#427

3. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. Return (FIntV w $to_bitstr((w as int), i))

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. Return (FBitV w $to_bitstr((w as int), i))

  2. Else

    1. Phantom#431

3. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $cast_int(typ'', i)

  2. Else

    1. Phantom#430

3. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ'') be synthtyp

    2. Let val be $cast_int(typ'', i)

    3. Return (SetV (SingletonSet val))

  2. Else

    1. Phantom#428

3. Else

  1. Phantom#429

;; ../../../../spec/2d1-runtime-numerics.watsup:459.1-459.41
def $cast_fint(typ, w, bs)

1. Return $cast_fint'($canon_typ(typ), w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:460.1-460.42
def $cast_fint'(typ'', w', bs)

1. If (typ'' = ((IntT) as typ)), then

  1. Return (IntV $to_int((w' as int), bs))

1. Else

  1. Phantom#432

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w_to) be numtyp

    2. Let bs' be $to_bitstr((w_to as int), $to_int((w' as int), bs))

    3. Return (FIntV w_to bs')

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w_to) be numtyp

    2. Let bs' be $to_bitstr((w_to as int), $to_int((w' as int), bs))

    3. Return (FBitV w_to bs')

  2. Else

    1. Phantom#436

2. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $cast_fint(typ'', w', bs)

  2. Else

    1. Phantom#435

2. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ'') be synthtyp

    2. Let val be $cast_fint(typ'', w', bs)

    3. Return (SetV (SingletonSet val))

  2. Else

    1. Phantom#433

2. Else

  1. Phantom#434

;; ../../../../spec/2d1-runtime-numerics.watsup:477.1-477.41
def $cast_fbit(typ, w, bs)

1. Return $cast_fbit'($canon_typ(typ), w, bs)

;; ../../../../spec/2d1-runtime-numerics.watsup:478.1-478.42
def $cast_fbit'(typ'', w', bs)

1. If (typ'' = ((BoolT) as typ)), then

  1. Return (BoolV (bs = (1 as bitstr)))

1. Else

  1. Phantom#437

2. If (typ'' = ((IntT) as typ)), then

  1. Return (IntV bs)

2. Else

  1. Phantom#438

3. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w_to) be numtyp

    2. Let bs' be $to_bitstr((w_to as int), bs)

    3. Return (FIntV w_to bs')

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w_to) be numtyp

    2. Let bs' be $to_bitstr((w_to as int), bs)

    3. Return (FBitV w_to bs')

  2. Else

    1. Phantom#442

3. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $cast_fbit(typ'', w', bs)

  2. Else

    1. Phantom#441

3. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ'') be synthtyp

    2. Let val be $cast_fbit(typ'', w', bs)

    3. Return (SetV (SingletonSet val))

  2. Else

    1. Phantom#439

3. Else

  1. Phantom#440

;; ../../../../spec/2d1-runtime-numerics.watsup:500.1-500.48
def $cast_struct(typ, id, (member, val)*)

1. Return $cast_struct'($canon_typ(typ), id, (member, val)*)

;; ../../../../spec/2d1-runtime-numerics.watsup:501.1-501.49
def $cast_struct'(typ, id', (member, val)*)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT id _(member, typ)*) be datatyp

    2. If (id = id'), then

      1. Return (StructV id (member, val)*)

    2. Else

      1. Phantom#443

  2. Else

    1. Phantom#444

1. Else

  1. Phantom#445

;; ../../../../spec/2d1-runtime-numerics.watsup:513.1-513.48
def $cast_header(typ, id, (member, val)*)

1. Return $cast_header'($canon_typ(typ), id, (member, val)*)

;; ../../../../spec/2d1-runtime-numerics.watsup:514.1-514.49
def $cast_header'(typ, id', (member, val)*)

1. If (typ has type datatyp), then

  1. Let datatyp be (typ as datatyp)

  2. If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT id _(member, typ)*) be datatyp

    2. If (id = id'), then

      1. Return (HeaderV id (member, val)*)

    2. Else

      1. Phantom#446

  2. Else

    1. Phantom#447

1. Else

  1. Phantom#448

;; ../../../../spec/2d1-runtime-numerics.watsup:526.1-526.31
def $cast_seq(typ, val*)

1. Return $cast_seq'($canon_typ(typ), val*)

;; ../../../../spec/2d1-runtime-numerics.watsup:527.1-527.32
def $cast_seq'(typ', val*)

1. If (typ' has type datatyp), then

  1. Let datatyp be (typ' as datatyp)

  2. If (datatyp matches pattern `ListT%`), then

    1. Let (ListT typ) be datatyp

    2. (Let val' be $cast_op(typ, val))*

    3. Return (ListV val'*)

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ*) be datatyp

    2. (Let val' be $cast_op(typ, val))*

    3. Return (TupleV val'*)

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ i_size) be datatyp

    2. (Let val' be $cast_op(typ, val))*

    3. Let i_idx be (|val*| as int)

    4. Return (StackV val'* i_idx i_size)

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT id (member, typ)*) be datatyp

    2. (Let val' be $cast_op(typ, val))*

    3. Return (StructV id (member, val')*)

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT id (member, typ)*) be datatyp

    2. (Let val' be $cast_op(typ, val))*

    3. Return (HeaderV id (member, val')*)

  2. Else

    1. Phantom#449

1. Else

  1. Phantom#450

;; ../../../../spec/2d1-runtime-numerics.watsup:553.1-553.44
def $cast_record(typ, (member, val)*)

1. Return $cast_record'($canon_typ(typ), (member, val)*)

;; ../../../../spec/2d1-runtime-numerics.watsup:554.1-554.45
def $cast_record'(typ', (member, val)*)

1. If (typ' has type datatyp), then

  1. Let datatyp be (typ' as datatyp)

  2. If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT id (member_t, typ)*) be datatyp

    2. (Let val? be $find_map<member, val>(({ (member -> val)* }), member_t))*

    3. If ((val? matches pattern (_)))*, then

      1. (Let ?(val') be val?)*

      2. (Let val'' be $cast_op(typ, val'))*

      3. Return (StructV id (member_t, val'')*)

    3. Else

      1. Phantom#453

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT id (member_t, typ)*) be datatyp

    2. (Let val? be $find_map<member, val>(({ (member -> val)* }), member_t))*

    3. If ((val? matches pattern (_)))*, then

      1. (Let ?(val') be val?)*

      2. (Let val'' be $cast_op(typ, val'))*

      3. Return (HeaderV id (member_t, val'')*)

    3. Else

      1. Phantom#451

  2. Else

    1. Phantom#452

1. Else

  1. Phantom#454

;; ../../../../spec/2d1-runtime-numerics.watsup:581.1-581.40
def $cast_set_singleton(typ, val)

1. Return $cast_set_singleton'($canon_typ(typ), val)

;; ../../../../spec/2d1-runtime-numerics.watsup:582.1-582.41
def $cast_set_singleton'(typ', val)

1. If (typ' has type synthtyp), then

  1. Let synthtyp be (typ' as synthtyp)

  2. If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ) be synthtyp

    2. Let val' be $cast_op(typ, val)

    3. Return (SetV (SingletonSet val'))

  2. Else

    1. Phantom#455

1. Else

  1. Phantom#456

;; ../../../../spec/2d1-runtime-numerics.watsup:589.1-589.40
def $cast_set_mask(typ, val_b, val_m)

1. Return $cast_set_mask'($canon_typ(typ), val_b, val_m)

;; ../../../../spec/2d1-runtime-numerics.watsup:590.1-590.41
def $cast_set_mask'(typ', val_b, val_m)

1. If (typ' has type synthtyp), then

  1. Let synthtyp be (typ' as synthtyp)

  2. If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ) be synthtyp

    2. Let val_b' be $cast_op(typ, val_b)

    3. Let val_m' be $cast_op(typ, val_m)

    4. Return (SetV (MaskSet val_b' val_m'))

  2. Else

    1. Phantom#457

1. Else

  1. Phantom#458

;; ../../../../spec/2d1-runtime-numerics.watsup:598.1-598.41
def $cast_set_range(typ, val_l, val_u)

1. Return $cast_set_range'($canon_typ(typ), val_l, val_u)

;; ../../../../spec/2d1-runtime-numerics.watsup:599.1-599.42
def $cast_set_range'(typ', val_l, val_u)

1. If (typ' has type synthtyp), then

  1. Let synthtyp be (typ' as synthtyp)

  2. If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ) be synthtyp

    2. Let val_l' be $cast_op(typ, val_l)

    3. Let val_u' be $cast_op(typ, val_u)

    4. Return (SetV (RangeSet val_l' val_u'))

  2. Else

    1. Phantom#459

1. Else

  1. Phantom#460

;; ../../../../spec/2d1-runtime-numerics.watsup:650.1-650.58
def $bitacc_op(val_b, val_h, val_l)

1. Let i_b be $get_num(val_b)

2. Let i_h be $get_num(val_h)

3. Let i_l be $get_num(val_l)

4. Let int be ((i_h + (1 as int)) - i_l)

5. If (int has type nat), then

  1. Let w be (int as nat)

  2. Let i be $bitacc(i_b, i_h, i_l)

  3. Return (FBitV w i)

5. Else

  1. Phantom#461

;; ../../../../spec/2d2-runtime-builtins.watsup:5.1-6.34
def $size(typ, text)

1. If (text = "minSizeInBits"), then

  1. Return $size_minSizeInBits(typ)

1. Else If (text = "minSizeInBytes"), then

  1. Return $size_minSizeInBytes(typ)

1. Else If (text = "maxSizeInBits"), then

  1. Return $size_maxSizeInBits(typ)

1. Else If (text = "maxSizeInBytes"), then

  1. Return $size_maxSizeInBytes(typ)

1. Else

  1. Phantom#462

;; ../../../../spec/2d2-runtime-builtins.watsup:8.1-8.35
def $size_minSizeInBits(typ)

1. Return (IntV ($size_minSizeInBits'(typ) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:9.1-9.36
def $size_minSizeInBits'(typ)

1. Return $size_minSizeInBits''($canon_typ(typ))

;; ../../../../spec/2d2-runtime-builtins.watsup:10.1-10.37
def $size_minSizeInBits''(typ'')

1. If (typ'' = ((BoolT) as typ)), then

  1. Return 1

1. Else

  1. Phantom#463

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. Return w

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. Return w

  2. Else If (numtyp matches pattern `VBitT%`), then

    1. Let (VBitT _width) be numtyp

    2. Return 0

  2. Else

    1. Phantom#467

2. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $size_minSizeInBits'(typ'')

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id typ'' _(member, val)*) be datatyp

    2. Return $size_minSizeInBits'(typ'')

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. Return $sum($size_minSizeInBits'(typ'')*)

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ'' int) be datatyp

    2. If (int has type nat), then

      1. Let n_s be (int as nat)

      2. Return ($size_minSizeInBits'(typ'') * n_s)

    2. Else

      1. Phantom#465

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id (_member, typ'')*) be datatyp

    2. Return $sum($size_minSizeInBits'(typ'')*)

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id (_member, typ'')*) be datatyp

    2. Return $sum($size_minSizeInBits'(typ'')*)

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id (_member, typ'')*) be datatyp

    2. Return $min($size_minSizeInBits'(typ'')*)

  2. Else

    1. Phantom#464

2. Else

  1. Phantom#466

;; ../../../../spec/2d2-runtime-builtins.watsup:12.1-12.36
def $size_minSizeInBytes(typ)

1. Let n be $size_minSizeInBits'(typ)

2. Return (IntV ((n / 8) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:14.1-14.35
def $size_maxSizeInBits(typ)

1. Return (IntV ($size_maxSizeInBits'(typ) as int))

;; ../../../../spec/2d2-runtime-builtins.watsup:15.1-15.36
def $size_maxSizeInBits'(typ)

1. Return $size_maxSizeInBits''($canon_typ(typ))

;; ../../../../spec/2d2-runtime-builtins.watsup:16.1-16.37
def $size_maxSizeInBits''(typ'')

1. If (typ'' = ((BoolT) as typ)), then

  1. Return 1

1. Else

  1. Phantom#468

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. Return w

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. Return w

  2. Else If (numtyp matches pattern `VBitT%`), then

    1. Let (VBitT w) be numtyp

    2. Return w

  2. Else

    1. Phantom#472

2. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ'') be datatyp

    2. Return $size_maxSizeInBits'(typ'')

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id typ'' _(member, val)*) be datatyp

    2. Return $size_maxSizeInBits'(typ'')

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. Return $sum($size_maxSizeInBits'(typ'')*)

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ'' int) be datatyp

    2. If (int has type nat), then

      1. Let n_s be (int as nat)

      2. Return ($size_maxSizeInBits'(typ'') * n_s)

    2. Else

      1. Phantom#470

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT _id (_member, typ'')*) be datatyp

    2. Return $sum($size_maxSizeInBits'(typ'')*)

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT _id (_member, typ'')*) be datatyp

    2. Return $sum($size_maxSizeInBits'(typ'')*)

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT _id (_member, typ'')*) be datatyp

    2. Return $max($size_maxSizeInBits'(typ'')*)

  2. Else

    1. Phantom#469

2. Else

  1. Phantom#471

;; ../../../../spec/2d2-runtime-builtins.watsup:18.1-18.36
def $size_maxSizeInBytes(typ)

1. Let n be $size_maxSizeInBits'(typ)

2. Return (IntV ((n / 8) as int))

;; ../../../../spec/2e-runtime-env.watsup:11.15-11.31
syntax styp = 
   | `%%%%`(typ, dir, ctk, val?)

;; ../../../../spec/2e-runtime-env.watsup:18.45-18.58
syntax frame = map<id, styp>

;; ../../../../spec/2e-runtime-env.watsup:20.1-20.27
def $empty_frame

1. Return $empty_map<id, styp>

;; ../../../../spec/2e-runtime-env.watsup:24.57-24.73
syntax tdenv = map<tid, typdef>

;; ../../../../spec/2e-runtime-env.watsup:26.1-26.27
def $empty_tdenv

1. Return $empty_map<tid, typdef>

;; ../../../../spec/2e-runtime-env.watsup:30.57-30.74
syntax fdenv = map<fid, funcdef>

;; ../../../../spec/2e-runtime-env.watsup:32.1-32.27
def $empty_fdenv

1. Return $empty_map<fid, funcdef>

;; ../../../../spec/2e-runtime-env.watsup:36.57-36.74
syntax cdenv = map<fid, consdef>

;; ../../../../spec/2e-runtime-env.watsup:38.1-38.27
def $empty_cdenv

1. Return $empty_map<cid, consdef>

;; ../../../../spec/2e-runtime-env.watsup:45.1-45.36
def $check_func_name(id_l, id_r)

1. Return (id_l = id_r)

;; ../../../../spec/2e-runtime-env.watsup:49.1-49.42
def $check_arity_more(id_a?*, id_p*)

1. Return (|id_a?*| > |id_p*|)

;; ../../../../spec/2e-runtime-env.watsup:53.1-53.37
def $check_arity(id_a?*, id_p*)

1. Return (|id_a?*| = |id_p*|)

;; ../../../../spec/2e-runtime-env.watsup:57.1-57.42
def $check_arity_less(id_a?*, id_p*)

1. Return (|id_a?*| < |id_p*|)

;; ../../../../spec/2e-runtime-env.watsup:61.1-61.46
def $get_params_missing_names(id*, id_a*)

1. If (id* matches pattern []), then

  1. Return []

1. Else If (id* matches pattern _ :: _), then

  1. Let id_p_h :: id_p_t* be id*

  2. If ~$in_set<id>(id_p_h, ({ id_a* })), then

    1. Return id_p_h :: $get_params_missing_names(id_p_t*, id_a*)

  2. Else

    1. Phantom#473

  3. Otherwise

    1. Return $get_params_missing_names(id_p_t*, id_a*)

;; ../../../../spec/2e-runtime-env.watsup:73.1-73.68
def $find_match_named<V>(fid, V, id_a*, (id_p, bool_p)*)

1. If $eq_set<id>(({ id_a* }), ({ id_p* })), then

  1. Return ?((fid, V, []))

2. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:83.1-84.59
def $find_match_named_default<V>(fid, V, id_a*, (id_p, bool_p)*)

1. Let id_deft* be $get_params_missing_names(id_p*, id_a*)

2. If ($find_match_named<V>(fid, V, id_a* ++ id_deft*, (id_p, bool_p)*) =/= ?()), then

  1. Return ?((fid, V, id_deft*))

3. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:94.1-95.61
def $find_match_unnamed_default<V>(fid, V, id_a?*, (id_p, bool_p)*)

1. Let ((id, bool)*, (id_deft, bool')*) be $partition_<(id, bool)>((id_p, bool_p)*, |id_a?*|)

2. If ((bool' = true))*, then

  1. Return ?((fid, V, id_deft*))

3. Otherwise

  1. Return ?()

;; ../../../../spec/2e-runtime-env.watsup:104.1-105.57
def $find_matching_func<V>(id_f, id_a?*, id*', (id_f' (id_p, bool_p)*), V)

1. Let id_a'* be id*'

2. If ~$check_func_name(id_f, id_f'), then

  1. Return ?()

2. Else If $check_func_name(id_f, id_f'), then

  1. If $check_arity_more(id_a?*, id_p*), then

    1. Return ?()

  1. Else

    1. Phantom#474

3. If (|id_a'*| > 0), then

  1. If $check_func_name(id_f, id_f'), then

    1. If $check_arity(id_a?*, id_p*), then

      1. Return $find_match_named<V>((id_f' (id_p, bool_p)*), V, id_a'*, (id_p, bool_p)*)

    1. Else

      1. Phantom#475

    2. If $check_arity_less(id_a?*, id_p*), then

      1. Return $find_match_named_default<V>((id_f' (id_p, bool_p)*), V, id_a'*, (id_p, bool_p)*)

    2. Else

      1. Phantom#476

  1. Else

    1. Phantom#477

3. Else

  1. Phantom#478

4. If (id*' matches pattern []), then

  1. If $check_func_name(id_f, id_f'), then

    1. If $check_arity(id_a?*, id_p*), then

      1. Return ?(((id_f' (id_p, bool_p)*), V, []))

    1. Else

      1. Phantom#479

    2. If $check_arity_less(id_a?*, id_p*), then

      1. Return $find_match_unnamed_default<V>((id_f' (id_p, bool_p)*), V, id_a?*, (id_p, bool_p)*)

    2. Else

      1. Phantom#480

  1. Else

    1. Phantom#481

4. Else

  1. Phantom#482

;; ../../../../spec/2e-runtime-env.watsup:142.1-143.58
def $find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid*, V*)

1. If (fid* matches pattern []), then

  1. If (V* matches pattern []), then

    1. Return []

  1. Else

    1. Phantom#486

1. Else If (fid* matches pattern _ :: _), then

  1. Let fid_h :: fid_t* be fid*

  2. If (V* matches pattern _ :: _), then

    1. Let V_h :: V_t* be V*

    2. If ($find_matching_func<V>(id_f, id_a?*, id_a'*, fid_h, V_h) = ?()), then

      1. Return $find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid_t*, V_t*)

    2. Else

      1. Phantom#483

    3. Let (fid, V, id*)? be $find_matching_func<V>(id_f, id_a?*, id_a'*, fid_h, V_h)

    4. If ((fid, V, id*)? matches pattern (_)), then

      1. Let ?((fid, V, id_deft*)) be (fid, V, id*)?

      2. Return (fid, V, id_deft*) :: $find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid_t*, V_t*)

    4. Else

      1. Phantom#484

  2. Else

    1. Phantom#485

;; ../../../../spec/2e-runtime-env.watsup:156.1-157.41
def $find_func<V>(id_f, id_a?*, ({ (fid -> V)* }))

1. If (|id_a?*| > 0), then

  1. (Let id? be id_a?)*

  2. If ((id? matches pattern (_)))*, then

    1. (Let ?(id_a') be id?)*

    2. If ($find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid*, V*) = []), then

      1. Return ?()

    2. Else

      1. Phantom#487

    3. Let (fid, V, id*)* be $find_matching_funcs<V>(id_f, id_a?*, id_a'*, fid*, V*)

    4. If ((fid, V, id*)* matches pattern [ _/1 ]), then

      1. Let [(fid', V', id_deft*)] be (fid, V, id*)*

      2. Return ?((fid', V', id_deft*))

    4. Else

      1. Phantom#488

  2. Else

    1. Phantom#489

1. Else

  1. Phantom#490

2. If ((id_a? = ?()))*, then

  1. If ($find_matching_funcs<V>(id_f, id_a?*, [], fid*, V*) = []), then

    1. Return ?()

  1. Else

    1. Phantom#491

  2. Let (fid, V, id*)* be $find_matching_funcs<V>(id_f, id_a?*, [], fid*, V*)

  3. If ((fid, V, id*)* matches pattern [ _/1 ]), then

    1. Let [(fid', V', id_deft*)] be (fid, V, id*)*

    2. Return ?((fid', V', id_deft*))

  3. Else

    1. Phantom#492

2. Else

  1. Phantom#493

;; ../../../../spec/2e-runtime-env.watsup:180.1-180.55
def $find_funcs_by_name(id_f, fid*, funcdef*)

1. If (fid* matches pattern []), then

  1. If (funcdef* matches pattern []), then

    1. Return []

  1. Else

    1. Phantom#497

1. Else If (fid* matches pattern _ :: _), then

  1. Let (id_h _(id, bool)*) :: fid_t* be fid*

  2. If (funcdef* matches pattern _ :: _), then

    1. Let fd_h :: fd_t* be funcdef*

    2. If (id_f = id_h), then

      1. Return fd_h :: $find_funcs_by_name(id_f, fid_t*, fd_t*)

    2. Else

      1. Phantom#494

  2. Else

    1. Phantom#495

  3. Let _fid :: fid_t* be fid*

  4. If (funcdef* matches pattern _ :: _), then

    1. Let _funcdef :: fd_t* be funcdef*

    2. Otherwise

      1. Return $find_funcs_by_name(id_f, fid_t*, fd_t*)

  4. Else

    1. Phantom#496

;; ../../../../spec/2e-runtime-env.watsup:192.1-193.23
def $find_func_by_name(id_f, ({ (fid -> fd)* }))

1. If ([] = $find_funcs_by_name(id_f, fid*, fd*)), then

  1. Return ?()

1. Else

  1. Phantom#498

2. Let funcdef* be $find_funcs_by_name(id_f, fid*, fd*)

3. If (funcdef* matches pattern [ _/1 ]), then

  1. Let [fd_f] be funcdef*

  2. Return ?(fd_f)

3. Else

  1. Phantom#499

;; ../../../../spec/2f-runtime-ctk.watsup:5.14-5.30
syntax ctk = 
   | `LCTK`()
   | `CTK`()
   | `DYN`()

;; ../../../../spec/2f-runtime-ctk.watsup:7.1-7.81
def $join_ctk(ctk'', ctk''')

1. If (ctk'' matches pattern `LCTK`), then

  1. If (ctk''' matches pattern `LCTK`), then

    1. Return (LCTK)

  1. Else If (ctk''' matches pattern `CTK`), then

    1. Return (CTK)

1. Else If (ctk'' matches pattern `CTK`), then

  1. If (ctk''' matches pattern `LCTK`), then

    1. Return (CTK)

  1. Else If (ctk''' matches pattern `CTK`), then

    1. Return (CTK)

2. Otherwise

  1. Return (DYN)

;; ../../../../spec/2f-runtime-ctk.watsup:16.1-16.75
def $joins_ctk(ctk*'')

1. If (ctk*'' matches pattern []), then

  1. Return (DYN)

1. Else If (ctk*'' matches pattern [ _/1 ]), then

  1. Let [ctk] be ctk*''

  2. Return ctk

1. Else If (ctk*'' matches pattern _ :: _), then

  1. Let ctk_a :: ctk*'' be ctk*''

  2. If (ctk*'' matches pattern [ _/1 ]), then

    1. Let [ctk_b] be ctk*''

    2. Return $join_ctk(ctk_a, ctk_b)

  2. Else If (ctk*'' matches pattern _ :: _), then

    1. Let ctk_b :: ctk_c* be ctk*''

    2. Let ctk_d be $join_ctk(ctk_a, ctk_b)

    3. Return $joins_ctk(ctk_d :: ctk_c*)

  2. Else

    1. Phantom#500

1. Else

  1. Phantom#501

;; ../../../../spec/2g-runtime-flow.watsup:5.15-5.25
syntax flow = 
   | `CONT`()
   | `RET`()

;; ../../../../spec/2g-runtime-flow.watsup:9.1-9.85
def $join_flow(flow'', flow''')

1. If (flow'' matches pattern `RET`), then

  1. If (flow''' matches pattern `RET`), then

    1. Return (RET)

  1. Else

    1. Phantom#502

1. Else

  1. Phantom#503

2. Return (CONT)

;; ../../../../spec/3-syntax-il.watsup:5.16-5.19
syntax numIL = num

;; ../../../../spec/3-syntax-il.watsup:15.15-15.17
syntax idIL = id

;; ../../../../spec/3-syntax-il.watsup:21.17-21.21
syntax nameIL = name

;; ../../../../spec/3-syntax-il.watsup:27.19-27.23
syntax memberIL = idIL

;; ../../../../spec/3-syntax-il.watsup:33.22-33.26
syntax matchkindIL = idIL

;; ../../../../spec/3-syntax-il.watsup:39.23-39.27
syntax statelabelIL = idIL

;; ../../../../spec/3-syntax-il.watsup:45.17-45.21
syntax unopIL = unop

;; ../../../../spec/3-syntax-il.watsup:51.18-51.23
syntax binopIL = binop

;; ../../../../spec/3-syntax-il.watsup:57.16-57.19
syntax dirIL = dir

;; ../../../../spec/3-syntax-il.watsup:69.17-69.20
syntax typeIL = typ

;; ../../../../spec/3-syntax-il.watsup:75.19-75.21
syntax tparamIL = id

;; ../../../../spec/3-syntax-il.watsup:81.18-81.40
syntax paramIL = 
   | `%%%%`(idIL, dirIL, typeIL, val?)

;; ../../../../spec/3-syntax-il.watsup:87.19-87.26
syntax cparamIL = paramIL

;; ../../../../spec/3-syntax-il.watsup:93.17-93.23
syntax targIL = typeIL

;; ../../../../spec/3-syntax-il.watsup:100.1-102.39
syntax argIL = 
   | `ExprA%`(exprIL)
   | `NameA%%`(idIL, exprIL?)
   | `AnyA`()

;; ../../../../spec/3-syntax-il.watsup:109.1-111.33
syntax keysetIL = 
   | `ExprK%`(exprIL)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec/3-syntax-il.watsup:117.23-117.45
syntax selectcaseIL = 
   | `%%`(keysetIL*, statelabelIL)

;; ../../../../spec/3-syntax-il.watsup:123.18-123.29
syntax annotIL = 
   | `(%;%)`(typ, ctk)

;; ../../../../spec/3-syntax-il.watsup:125.1-145.128
syntax exprIL = 
   | `ValueE%%`(val, annotIL)
   | `NameE%%`(nameIL, annotIL)
   | `SeqE%%`(exprIL*, annotIL)
   | `SeqDefaultE%%`(exprIL*, annotIL)
   | `RecordE%%`((memberIL, exprIL)*, annotIL)
   | `RecordDefaultE%%`((memberIL, exprIL)*, annotIL)
   | `DefaultE%`(annotIL)
   | `UnE%%%`(unopIL, exprIL, annotIL)
   | `BinE%%%%`(binopIL, exprIL, exprIL, annotIL)
   | `TernE%%%%`(exprIL, exprIL, exprIL, annotIL)
   | `CastE%%%`(typeIL, exprIL, annotIL)
   | `MaskE%%%`(exprIL, exprIL, annotIL)
   | `RangeE%%%`(exprIL, exprIL, annotIL)
   | `SelectE%%%`(exprIL*, selectcaseIL*, annotIL)
   | `ArrAccE%%%`(exprIL, exprIL, annotIL)
   | `BitAccE%%%%`(exprIL, exprIL, exprIL, annotIL)
   | `ExprAccE%%%`(exprIL, memberIL, annotIL)
   | `CallFuncE%%%%`(nameIL, targIL*, argIL*, annotIL)
   | `CallMethodE%%%%%`(exprIL, memberIL, targIL*, argIL*, annotIL)
   | `CallTypeE%%%%%`(nameIL, memberIL, targIL*, argIL*, annotIL)
   | `InstE%%%%`(nameIL, targIL*, argIL*, annotIL)

;; ../../../../spec/3-syntax-il.watsup:151.18-151.75
syntax blockIL = 
   | `BlockB%`(stmtIL*)

;; ../../../../spec/3-syntax-il.watsup:158.1-169.67
syntax stmtIL = 
   | `EmptyS`()
   | `AssignS%%`(exprIL, exprIL)
   | `SwitchS%%`(exprIL, switchcaseIL*)
   | `IfS%%%`(exprIL, stmtIL, stmtIL)
   | `BlockS%`(blockIL)
   | `ExitS`()
   | `RetS%`(exprIL?)
   | `CallFuncS%%%`(nameIL, targIL*, argIL*)
   | `CallMethodS%%%%`(exprIL, memberIL, targIL*, argIL*)
   | `CallInstS%%%%`(typeIL, nameIL, targIL*, argIL*)
   | `TransS%`(exprIL)
   | `DeclS%`(declIL)

;; ../../../../spec/3-syntax-il.watsup:176.1-177.39
syntax switchlabelIL = 
   | `ExprL%`(exprIL)
   | `DefaultL`()

;; ../../../../spec/3-syntax-il.watsup:180.1-181.56
syntax switchcaseIL = 
   | `MatchC%%`(switchlabelIL, blockIL)
   | `FallC%`(switchlabelIL)

;; ../../../../spec/3-syntax-il.watsup:187.24-187.44
syntax parserstateIL = 
   | `%%`(statelabelIL, blockIL)

;; ../../../../spec/3-syntax-il.watsup:193.16-193.26
syntax tblIL = tblpropIL*

;; ../../../../spec/3-syntax-il.watsup:199.19-199.37
syntax tblkeyIL = 
   | `%%`(exprIL, matchkindIL)

;; ../../../../spec/3-syntax-il.watsup:200.23-200.32
syntax tblkeypropIL = tblkeyIL*

;; ../../../../spec/3-syntax-il.watsup:206.22-206.53
syntax tblactionIL = 
   | `%%%%`(nameIL, argIL*, paramIL*, paramIL*)

;; ../../../../spec/3-syntax-il.watsup:207.26-207.38
syntax tblactionpropIL = tblactionIL*

;; ../../../../spec/3-syntax-il.watsup:213.21-213.52
syntax tblentryIL = 
   | `%%%%`(bool, keysetIL*, tblactionIL, val?)

;; ../../../../spec/3-syntax-il.watsup:214.25-214.41
syntax tblentrypropIL = 
   | `%%`(bool, tblentryIL*)

;; ../../../../spec/3-syntax-il.watsup:220.27-220.43
syntax tbldefaultpropIL = 
   | `%%`(bool, tblactionIL)

;; ../../../../spec/3-syntax-il.watsup:226.26-226.46
syntax tblcustompropIL = 
   | `%%%`(bool, memberIL, exprIL)

;; ../../../../spec/3-syntax-il.watsup:233.1-237.80
syntax tblpropIL = 
   | `KeyP%`(tblkeypropIL)
   | `ActionP%`(tblactionpropIL)
   | `EntryP%`(tblentrypropIL)
   | `DefaultP%`(tbldefaultpropIL)
   | `CustomP%`(tblcustompropIL)

;; ../../../../spec/3-syntax-il.watsup:244.1-246.53
syntax methodIL = 
   | `ExternConsM%%%`(idIL, tparamIL*, cparamIL*)
   | `ExternAbstractM%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)
   | `ExternM%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)

;; ../../../../spec/3-syntax-il.watsup:255.1-277.52
syntax declIL = 
   | `ConstD%%%`(idIL, typeIL, val)
   | `VarD%%%`(idIL, typeIL, exprIL?)
   | `ErrD%`(memberIL*)
   | `MatchKindD%`(memberIL*)
   | `InstD%%%%%%`(idIL, typeIL, nameIL, targIL*, argIL*, declIL*)
   | `StructD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `HeaderD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `UnionD%%%%`(idIL, tparamIL*, tparamIL*, (memberIL, typeIL)*)
   | `EnumD%%`(idIL, memberIL*)
   | `SEnumD%%%`(idIL, typeIL, (memberIL, val)*)
   | `NewTypeD%%`(idIL, typedefIL)
   | `TypeDefD%%`(idIL, typedefIL)
   | `ValueSetD%%%`(idIL, typeIL, exprIL)
   | `ParserTypeD%%%%`(idIL, tparamIL*, tparamIL*, paramIL*)
   | `ParserD%%%%%`(idIL, paramIL*, cparamIL*, declIL*, parserstateIL*)
   | `TableD%%%`(idIL, typeIL, tblIL)
   | `ControlTypeD%%%%`(idIL, tparamIL*, tparamIL*, paramIL*)
   | `ControlD%%%%%`(idIL, paramIL*, cparamIL*, declIL*, blockIL)
   | `ActionD%%%`(idIL, paramIL*, blockIL)
   | `FuncD%%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*, blockIL)
   | `ExternFuncD%%%%%`(idIL, typeIL, tparamIL*, tparamIL*, paramIL*)
   | `ExternObjectD%%%`(idIL, tparamIL*, methodIL*)
   | `PackageTypeD%%%%`(idIL, tparamIL*, tparamIL*, cparamIL*)

;; ../../../../spec/3-syntax-il.watsup:280.1-281.17
syntax typedefIL = 
   | `TypeD%`(typeIL)
   | `DeclD%`(declIL)

;; ../../../../spec/3-syntax-il.watsup:287.20-287.27
syntax programIL = declIL*

;; ../../../../spec/4a1-typing-context.watsup:5.17-5.39
syntax cursor = 
   | `GLOBAL`()
   | `BLOCK`()
   | `LOCAL`()

;; ../../../../spec/4a1-typing-context.watsup:16.3-19.18
syntax glayer = {`CDENV%`(cdenv), `TDENV%`(tdenv), `FDENV%`(fdenv), `FRAME%`(frame)}

;; ../../../../spec/4a1-typing-context.watsup:23.16-23.59
syntax bkind = 
   | `EMPTY`()
   | `EXTERN`()
   | `PARSER`()
   | `CONTROL`()
   | `PACKAGE`()

;; ../../../../spec/4a1-typing-context.watsup:26.3-30.18
syntax blayer = {`ID%`(id), `KIND%`(bkind), `TDENV%`(tdenv), `FDENV%`(fdenv), `FRAME%`(frame)}

;; ../../../../spec/4a1-typing-context.watsup:35.1-43.21
syntax lkind = 
   | `EMPTY`()
   | `EXTERNFUNC`()
   | `FUNC%`(typ)
   | `ACTION`()
   | `EXTERNMETHOD`()
   | `EXTERNABSTRACTMETHOD%`(typ)
   | `PARSERSTATE`()
   | `CONTROLAPPLYMETHOD`()
   | `TABLEAPPLYMETHOD`()

;; ../../../../spec/4a1-typing-context.watsup:46.3-49.20
syntax llayer = {`ID%`(id), `KIND%`(lkind), `TDENV%`(tdenv), `FRAMES%`(frame*)}

;; ../../../../spec/4a1-typing-context.watsup:56.3-58.19
syntax context = {`GLOBAL%`(glayer), `BLOCK%`(blayer), `LOCAL%`(llayer)}

;; ../../../../spec/4a1-typing-context.watsup:66.1-66.29
def $empty_context

1. Let glayer be {CDENV $empty_map<cid, consdef>, TDENV $empty_map<tid, typdef>, FDENV $empty_map<fid, funcdef>, FRAME $empty_map<id, styp>}

2. Let blayer be {ID "", KIND (EMPTY), TDENV $empty_map<tid, typdef>, FDENV $empty_map<fid, funcdef>, FRAME $empty_map<id, styp>}

3. Let llayer be {ID "", KIND (EMPTY), TDENV $empty_map<tid, typdef>, FRAMES [$empty_map<id, styp>]}

4. Let C be {GLOBAL glayer, BLOCK blayer, LOCAL llayer}

5. Return C

;; ../../../../spec/4a1-typing-context.watsup:91.1-92.23
def $enter(C)

1. Return C[LOCAL.FRAMES = $empty_map<id, styp> :: C.LOCAL.FRAMES]

;; ../../../../spec/4a1-typing-context.watsup:96.1-97.22
def $exit(C)

1. Let frame* be C.LOCAL.FRAMES

2. If (frame* matches pattern _ :: _), then

  1. Let frame_h :: frame_t* be frame*

  2. Return C[LOCAL.FRAMES = frame_t*]

2. Else

  1. Phantom#504

;; ../../../../spec/4a1-typing-context.watsup:106.1-107.34
def $set_blockkind(C, bkind)

1. Return C[BLOCK.KIND = bkind]

;; ../../../../spec/4a1-typing-context.watsup:111.1-112.35
def $set_localkind(C, lkind)

1. Return C[LOCAL.KIND = lkind]

;; ../../../../spec/4a1-typing-context.watsup:116.1-117.63
def $set_blockframe



;; ../../../../spec/4a1-typing-context.watsup:123.1-124.32
def $get_typ_ret_lkind(lkind)

1. If (lkind matches pattern `FUNC%`), then

  1. Let (FUNC typ) be lkind

  2. Return typ

1. Else If (lkind matches pattern `ACTION`), then

  1. Return ((VoidT) as typ)

1. Else If (lkind matches pattern `EXTERNABSTRACTMETHOD%`), then

  1. Let (EXTERNABSTRACTMETHOD typ) be lkind

  2. Return typ

1. Else If (lkind matches pattern `CONTROLAPPLYMETHOD`), then

  1. Return ((VoidT) as typ)

1. Else

  1. Phantom#505

;; ../../../../spec/4a1-typing-context.watsup:135.1-135.42
def $bound_tids(cursor, C)

1. If (cursor matches pattern `GLOBAL`), then

  1. Return $empty_set<tid>

1. Else If (cursor matches pattern `BLOCK`), then

  1. Return $dom_map<tid, typdef>(C.BLOCK.TDENV)

1. Else If (cursor matches pattern `LOCAL`), then

  1. Return $union_set<tid>($dom_map<tid, typdef>(C.LOCAL.TDENV), $bound_tids((BLOCK), C))

;; ../../../../spec/4a1-typing-context.watsup:147.1-148.84
def $add_styp(cursor, C, id, styp)

1. If (cursor matches pattern `GLOBAL`), then

  1. If ~$in_set<id>(id, $dom_map<id, styp>(C.GLOBAL.FRAME)), then

    1. Let frame be $add_map<id, styp>(C.GLOBAL.FRAME, id, styp)

    2. Return C[GLOBAL.FRAME = frame]

  1. Else

    1. Phantom#509

1. Else If (cursor matches pattern `BLOCK`), then

  1. If ~$in_set<id>(id, $dom_map<id, styp>(C.BLOCK.FRAME)), then

    1. Let frame be $add_map<id, styp>(C.BLOCK.FRAME, id, styp)

    2. Return C[BLOCK.FRAME = frame]

  1. Else

    1. Phantom#508

1. Else If (cursor matches pattern `LOCAL`), then

  1. Let frame* be C.LOCAL.FRAMES

  2. If (frame* matches pattern _ :: _), then

    1. Let frame_h :: frame_t* be frame*

    2. If ~$in_set<id>(id, $dom_map<id, styp>(frame_h)), then

      1. Let frame_h' be $add_map<id, styp>(frame_h, id, styp)

      2. Let frame* be frame_h' :: frame_t*

      3. Return C[LOCAL.FRAMES = frame*]

    2. Else

      1. Phantom#506

  2. Else

    1. Phantom#507

;; ../../../../spec/4a1-typing-context.watsup:162.1-163.88
def $add_styps(cursor, C, id*, styp*)

1. If (id* matches pattern []), then

  1. If (styp* matches pattern []), then

    1. Return C

  1. Else

    1. Phantom#511

1. Else If (id* matches pattern _ :: _), then

  1. Let id_h :: id_t* be id*

  2. If (styp* matches pattern _ :: _), then

    1. Let styp_h :: styp_t* be styp*

    2. Let C' be $add_styp(cursor, C, id_h, styp_h)

    3. Let C'' be $add_styps(cursor, C', id_t*, styp_t*)

    4. Return C''

  2. Else

    1. Phantom#510

;; ../../../../spec/4a1-typing-context.watsup:172.1-172.52
def $add_param(p, C, pt)

1. Let (id dir typ val?) be pt

2. If (dir matches pattern `NO`), then

  1. Let C' be $add_styp(p, C, id, (typ (NO) (CTK) ?()))

  2. Return C'

2. Else If (dir matches pattern `IN`), then

  1. Let C' be $add_styp(p, C, id, (typ dir (DYN) ?()))

  2. Return C'

2. Else If (dir matches pattern `OUT`), then

  1. Let C' be $add_styp(p, C, id, (typ dir (DYN) ?()))

  2. Return C'

2. Else If (dir matches pattern `INOUT`), then

  1. Let C' be $add_styp(p, C, id, (typ dir (DYN) ?()))

  2. Return C'

;; ../../../../spec/4a1-typing-context.watsup:182.1-182.54
def $add_params(p, C, paramtyp*)

1. If (paramtyp* matches pattern []), then

  1. Return C

1. Else If (paramtyp* matches pattern _ :: _), then

  1. Let pt_h :: pt_t* be paramtyp*

  2. Let C' be $add_param(p, C, pt_h)

  3. Let C'' be $add_params(p, C', pt_t*)

  4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:191.1-192.80
def $add_typdef(cursor, C, tid, td)

1. If (cursor matches pattern `GLOBAL`), then

  1. If ~$in_set<tid>(tid, $dom_map<tid, typdef>(C.GLOBAL.TDENV)), then

    1. Let tdenv be $add_map<tid, typdef>(C.GLOBAL.TDENV, tid, td)

    2. Return C[GLOBAL.TDENV = tdenv]

  1. Else

    1. Phantom#514

1. Else If (cursor matches pattern `BLOCK`), then

  1. If ~$in_set<tid>(tid, $dom_map<tid, typdef>(C.BLOCK.TDENV)), then

    1. Let tdenv be $add_map<tid, typdef>(C.BLOCK.TDENV, tid, td)

    2. Return C[BLOCK.TDENV = tdenv]

  1. Else

    1. Phantom#513

1. Else If (cursor matches pattern `LOCAL`), then

  1. If ~$in_set<tid>(tid, $dom_map<tid, typdef>(C.LOCAL.TDENV)), then

    1. Let tdenv be $add_map<tid, typdef>(C.LOCAL.TDENV, tid, td)

    2. Return C[LOCAL.TDENV = tdenv]

  1. Else

    1. Phantom#512

;; ../../../../spec/4a1-typing-context.watsup:204.1-205.84
def $add_typdefs(p, C, tid*, typdef*)

1. If (tid* matches pattern []), then

  1. If (typdef* matches pattern []), then

    1. Return C

  1. Else

    1. Phantom#516

1. Else If (tid* matches pattern _ :: _), then

  1. Let tid_h :: tid_t* be tid*

  2. If (typdef* matches pattern _ :: _), then

    1. Let td_h :: td_t* be typdef*

    2. Let C' be $add_typdef(p, C, tid_h, td_h)

    3. Let C'' be $add_typdefs(p, C', tid_t*, td_t*)

    4. Return C''

  2. Else

    1. Phantom#515

;; ../../../../spec/4a1-typing-context.watsup:214.1-214.51
def $add_tparam(cursor, C, tparam)

1. If (cursor matches pattern `BLOCK`), then

  1. Let td be ((MonoD ((VarT tparam) as typ)) as typdef)

  2. If ~$in_set<tid>(tparam, $dom_map<tid, typdef>(C.BLOCK.TDENV)), then

    1. Let tdenv be $add_map<tid, typdef>(C.BLOCK.TDENV, tparam, td)

    2. Return C[BLOCK.TDENV = tdenv]

  2. Else

    1. Phantom#519

1. Else If (cursor matches pattern `LOCAL`), then

  1. Let td be ((MonoD ((VarT tparam) as typ)) as typdef)

  2. If ~$in_set<tid>(tparam, $dom_map<tid, typdef>(C.LOCAL.TDENV)), then

    1. Let tdenv be $add_map<tid, typdef>(C.LOCAL.TDENV, tparam, td)

    2. Return C[LOCAL.TDENV = tdenv]

  2. Else

    1. Phantom#517

1. Else

  1. Phantom#518

;; ../../../../spec/4a1-typing-context.watsup:225.1-225.53
def $add_tparams(p, C, tparam*)

1. If (tparam* matches pattern []), then

  1. Return C

1. Else If (tparam* matches pattern _ :: _), then

  1. Let tparam_h :: tparam_t* be tparam*

  2. Let C' be $add_tparam(p, C, tparam_h)

  3. Let C'' be $add_tparams(p, C', tparam_t*)

  4. Return C''

;; ../../../../spec/4a1-typing-context.watsup:234.1-235.80
def $add_funcdef(cursor, C, fid, fd)

1. If (cursor matches pattern `GLOBAL`), then

  1. If ~$in_set<fid>(fid, $dom_map<fid, funcdef>(C.GLOBAL.FDENV)), then

    1. Let fdenv be $add_map<fid, funcdef>(C.GLOBAL.FDENV, fid, fd)

    2. Return C[GLOBAL.FDENV = fdenv]

  1. Else

    1. Phantom#522

1. Else If (cursor matches pattern `BLOCK`), then

  1. If ~$in_set<fid>(fid, $dom_map<fid, funcdef>(C.BLOCK.FDENV)), then

    1. Let fdenv be $add_map<fid, funcdef>(C.BLOCK.FDENV, fid, fd)

    2. Return C[BLOCK.FDENV = fdenv]

  1. Else

    1. Phantom#520

1. Else

  1. Phantom#521

;; ../../../../spec/4a1-typing-context.watsup:244.1-245.80
def $add_funcdef_non_overload(cursor, C, fid, fd)

1. If (cursor matches pattern `GLOBAL`), then

  1. Let ({ (id_k _(id, bool)*)* }) be $dom_map<fid, funcdef>(C.GLOBAL.FDENV)

  2. Let (id _(id, bool)*') be fid

  3. If ~id is in id_k*, then

    1. Let fdenv be $add_map<fid, funcdef>(C.GLOBAL.FDENV, fid, fd)

    2. Return C[GLOBAL.FDENV = fdenv]

  3. Else

    1. Phantom#525

1. Else If (cursor matches pattern `BLOCK`), then

  1. Let ({ (id_k _(id, bool)*)* }) be $dom_map<fid, funcdef>(C.BLOCK.FDENV)

  2. Let (id _(id, bool)*') be fid

  3. If ~id is in id_k*, then

    1. Let fdenv be $add_map<fid, funcdef>(C.BLOCK.FDENV, fid, fd)

    2. Return C[BLOCK.FDENV = fdenv]

  3. Else

    1. Phantom#523

1. Else

  1. Phantom#524

;; ../../../../spec/4a1-typing-context.watsup:260.1-261.80
def $add_consdef(cursor, C, cid, cd)

1. If (cursor matches pattern `GLOBAL`), then

  1. If ~$in_set<cid>(cid, $dom_map<cid, consdef>(C.GLOBAL.CDENV)), then

    1. Let cdenv be $add_map<cid, consdef>(C.GLOBAL.CDENV, cid, cd)

    2. Return C[GLOBAL.CDENV = cdenv]

  1. Else

    1. Phantom#526

1. Else

  1. Phantom#527

;; ../../../../spec/4a1-typing-context.watsup:273.1-274.57
def $find_styp(p', C, name)

1. If (name matches pattern `TOP%`), then

  1. Let (TOP id) be name

  2. Return $find_map<id, styp>(C.GLOBAL.FRAME, id)

1. Else

  1. Phantom#528

2. If (p' matches pattern `GLOBAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_map<id, styp>(C.GLOBAL.FRAME, id)

  1. Else

    1. Phantom#535

2. Else If (p' matches pattern `BLOCK`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Let styp? be $find_map<id, styp>(C.BLOCK.FRAME, id)

    3. If (styp? matches pattern (_)), then

      1. Let ?(styp) be styp?

      2. Return ?(styp)

    3. Else

      1. Phantom#532

    4. If (?() = $find_map<id, styp>(C.BLOCK.FRAME, id)), then

      1. Return $find_styp((GLOBAL), C, (CURRENT id))

    4. Else

      1. Phantom#533

  1. Else

    1. Phantom#534

2. Else If (p' matches pattern `LOCAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Let styp? be $find_maps<id, styp>(C.LOCAL.FRAMES, id)

    3. If (styp? matches pattern (_)), then

      1. Let ?(styp) be styp?

      2. Return ?(styp)

    3. Else

      1. Phantom#529

    4. If (?() = $find_maps<id, styp>(C.LOCAL.FRAMES, id)), then

      1. Return $find_styp((BLOCK), C, (CURRENT id))

    4. Else

      1. Phantom#530

  1. Else

    1. Phantom#531

;; ../../../../spec/4a1-typing-context.watsup:289.1-290.44
def $find_val(p, C, name)

1. Let styp? be $find_styp(p, C, name)

2. If (styp? matches pattern (_)), then

  1. Let ?((typ dir ctk val?)) be styp?

  2. If (val? matches pattern (_)), then

    1. Let ?(val) be val?

    2. Return ?(val)

  2. Else

    1. Phantom#536

2. Else

  1. Phantom#537

;; ../../../../spec/4a1-typing-context.watsup:297.1-298.44
def $find_typdef(p', C, name)

1. If (name matches pattern `TOP%`), then

  1. Let (TOP id) be name

  2. Return $find_map<tid, typdef>(C.GLOBAL.TDENV, id)

1. Else

  1. Phantom#538

2. If (p' matches pattern `GLOBAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_map<tid, typdef>(C.GLOBAL.TDENV, id)

  1. Else

    1. Phantom#545

2. Else If (p' matches pattern `BLOCK`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Let typdef? be $find_map<tid, typdef>(C.BLOCK.TDENV, id)

    3. If (typdef? matches pattern (_)), then

      1. Let ?(td) be typdef?

      2. Return ?(td)

    3. Else

      1. Phantom#542

    4. If (?() = $find_map<tid, typdef>(C.BLOCK.TDENV, id)), then

      1. Return $find_typdef((GLOBAL), C, (CURRENT id))

    4. Else

      1. Phantom#543

  1. Else

    1. Phantom#544

2. Else If (p' matches pattern `LOCAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Let typdef? be $find_map<tid, typdef>(C.LOCAL.TDENV, id)

    3. If (typdef? matches pattern (_)), then

      1. Let ?(td) be typdef?

      2. Return ?(td)

    3. Else

      1. Phantom#539

    4. If (?() = $find_map<tid, typdef>(C.LOCAL.TDENV, id)), then

      1. Return $find_typdef((BLOCK), C, (CURRENT id))

    4. Else

      1. Phantom#540

  1. Else

    1. Phantom#541

;; ../../../../spec/4a1-typing-context.watsup:313.1-313.28
def $to_fkey(arg*)

1. If (arg* matches pattern []), then

  1. Return []

1. Else If (arg* matches pattern _ :: _), then

  1. Let arg_h :: arg_t* be arg*

  2. Let arg be arg_h

  3. If (arg matches pattern `NameA%%`), then

    1. Let (NameA id _expr?) be arg

    2. Return ?(id) :: $to_fkey(arg_t*)

  3. Else

    1. Phantom#546

  4. Otherwise

    1. Return ?() :: $to_fkey(arg_t*)

;; ../../../../spec/4a1-typing-context.watsup:321.1-322.58
def $find_funcdef(p', C, name, arg*)

1. If (name matches pattern `TOP%`), then

  1. Let (TOP id) be name

  2. Return $find_func<funcdef>(id, $to_fkey(arg*), C.GLOBAL.FDENV)

1. Else

  1. Phantom#547

2. If (p' matches pattern `GLOBAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_func<funcdef>(id, $to_fkey(arg*), C.GLOBAL.FDENV)

  1. Else

    1. Phantom#552

2. Else If (p' matches pattern `BLOCK`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Let (fid, funcdef, id*)? be $find_func<funcdef>(id, $to_fkey(arg*), C.BLOCK.FDENV)

    3. If ((fid, funcdef, id*)? matches pattern (_)), then

      1. Let ?((fid, fd, id_deft*)) be (fid, funcdef, id*)?

      2. Return ?((fid, fd, id_deft*))

    3. Else

      1. Phantom#549

    4. If (?() = $find_func<funcdef>(id, $to_fkey(arg*), C.BLOCK.FDENV)), then

      1. Return $find_funcdef((GLOBAL), C, (CURRENT id), arg*)

    4. Else

      1. Phantom#550

  1. Else

    1. Phantom#551

2. Else If (p' matches pattern `LOCAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_funcdef((BLOCK), C, (CURRENT id), arg*)

  1. Else

    1. Phantom#548

;; ../../../../spec/4a1-typing-context.watsup:332.1-333.44
def $find_funcdef_by_name(p', C, name)

1. If (name matches pattern `TOP%`), then

  1. Let (TOP id) be name

  2. Return $find_func_by_name(id, C.GLOBAL.FDENV)

1. Else

  1. Phantom#553

2. If (p' matches pattern `GLOBAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_func_by_name(id, C.GLOBAL.FDENV)

  1. Else

    1. Phantom#558

2. Else If (p' matches pattern `BLOCK`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Let funcdef? be $find_func_by_name(id, C.BLOCK.FDENV)

    3. If (funcdef? matches pattern (_)), then

      1. Let ?(fd) be funcdef?

      2. Return ?(fd)

    3. Else

      1. Phantom#555

    4. If (?() = $find_func_by_name(id, C.BLOCK.FDENV)), then

      1. Return $find_funcdef_by_name((GLOBAL), C, (CURRENT id))

    4. Else

      1. Phantom#556

  1. Else

    1. Phantom#557

2. Else If (p' matches pattern `LOCAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_funcdef_by_name((BLOCK), C, (CURRENT id))

  1. Else

    1. Phantom#554

;; ../../../../spec/4a1-typing-context.watsup:345.1-346.58
def $find_consdef(p', C, name, arg*)

1. If (name matches pattern `TOP%`), then

  1. Let (TOP id) be name

  2. Return $find_func<consdef>(id, $to_fkey(arg*), C.GLOBAL.CDENV)

1. Else

  1. Phantom#559

2. If (p' matches pattern `GLOBAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_func<consdef>(id, $to_fkey(arg*), C.GLOBAL.CDENV)

  1. Else

    1. Phantom#562

2. Else If (p' matches pattern `BLOCK`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_consdef((GLOBAL), C, (CURRENT id), arg*)

  1. Else

    1. Phantom#561

2. Else If (p' matches pattern `LOCAL`), then

  1. If (name matches pattern `CURRENT%`), then

    1. Let (CURRENT id) be name

    2. Return $find_consdef((BLOCK), C, (CURRENT id), arg*)

  1. Else

    1. Phantom#560

;; ../../../../spec/4a2-typing-tblctx.watsup:6.1-9.11
syntax mode = 
   | `NOPRI`()
   | `NOPRILPM%`(nat)
   | `PRI`()
   | `PRILPM`()

;; ../../../../spec/4a2-typing-tblctx.watsup:12.3-15.24
syntax priority = {`VALUES%`(int*), `INIT%`(bool), `DELTA%`(int), `LARGEST_WINS%`(bool)}

;; ../../../../spec/4a2-typing-tblctx.watsup:18.3-19.17
syntax entry = {`SIZE%`(int), `CONST%`(bool)}

;; ../../../../spec/4a2-typing-tblctx.watsup:24.14-24.30
syntax key = (typ, matchkind)

;; ../../../../spec/4a2-typing-tblctx.watsup:25.17-25.42
syntax action = (name, paramtyp*, argIL*)

;; ../../../../spec/4a2-typing-tblctx.watsup:28.3-32.16
syntax tblctx = {`KEYS%`(key*), `ACTIONS%`(action*), `PRIORITIES%`(priority), `ENTRIES%`(entry), `MODE%`(mode)}

;; ../../../../spec/4a2-typing-tblctx.watsup:39.1-40.10
syntax tblstate = 
   | `LPM%`(nat)
   | `NOLPM`()

;; ../../../../spec/4a2-typing-tblctx.watsup:46.1-46.26
def $empty_pt

1. Return {VALUES [], INIT false, DELTA (1 as int), LARGEST_WINS true}

;; ../../../../spec/4a2-typing-tblctx.watsup:53.1-53.23
def $empty_et

1. Return {SIZE (0 as int), CONST true}

;; ../../../../spec/4a2-typing-tblctx.watsup:58.1-58.28
def $empty_tblctx

1. Return {KEYS [], ACTIONS [], PRIORITIES $empty_pt, ENTRIES $empty_et, MODE (NOPRI)}

;; ../../../../spec/4a2-typing-tblctx.watsup:70.1-70.35
def $add_key(key, tblctx)

1. Return tblctx[KEYS = tblctx.KEYS ++ [key]]

;; ../../../../spec/4a2-typing-tblctx.watsup:74.1-74.41
def $add_action(action, tblctx)

1. Return tblctx[ACTIONS = tblctx.ACTIONS ++ [action]]

;; ../../../../spec/4a2-typing-tblctx.watsup:78.1-78.40
def $add_priority(i, tblctx)

1. Return tblctx[PRIORITIES.VALUES = tblctx.PRIORITIES.VALUES ++ [i]]

;; ../../../../spec/4a2-typing-tblctx.watsup:87.1-87.36
def $get_lpm_prefix(val)

1. Return (LPM $get_lpm_prefix'(val, 0))

;; ../../../../spec/4a2-typing-tblctx.watsup:88.1-88.37
def $get_lpm_prefix'(val, n_prefix')

1. If (val matches pattern `FBitV%%`), then

  1. Let (FBitV nat _bitstr) be val

  2. If (nat = 0), then

    1. Return n_prefix'

  2. Else

    1. Phantom#563

  3. Let (FBitV w bitstr) be val

  4. If (bitstr has type nat), then

    1. Let n be (bitstr as nat)

    2. If (w > 0), then

      1. If ((n \ 2) =/= 0), then

        1. Let val' be (FBitV (w - 1) (((n - 1) / 2) as bitstr))

        2. Return $get_lpm_prefix'(val', (n_prefix' + 1))

      1. Else

        1. Phantom#564

    2. Else

      1. Phantom#565

    3. If (n_prefix' = 0), then

      1. If (w > 0), then

        1. If ((n \ 2) = 0), then

          1. Let val' be (FBitV (w - 1) ((n / 2) as bitstr))

          2. Return $get_lpm_prefix'(val', 0)

        1. Else

          1. Phantom#566

      1. Else

        1. Phantom#567

    3. Else

      1. Phantom#568

  4. Else

    1. Phantom#569

1. Else

  1. Phantom#570

;; ../../../../spec/4a2-typing-tblctx.watsup:107.1-107.45
def $update_mode(text', typ', tblctx)

1. If (text' = "lpm"), then

  1. If (tblctx.MODE matches pattern `NOPRI`), then

    1. Let w be $get_width(typ')

    2. Return tblctx[MODE = (NOPRILPM w)]

  1. Else If (tblctx.MODE matches pattern `PRI`), then

    1. Return tblctx[MODE = (PRILPM)]

1. Else If (text' = "range"), then

  1. If (tblctx.MODE matches pattern `NOPRI`), then

    1. Return tblctx[MODE = (PRI)]

  2. Let mode be tblctx.MODE

  3. If (mode matches pattern `NOPRILPM%`), then

    1. Let (NOPRILPM _nat) be mode

    2. Return tblctx[MODE = (PRILPM)]

1. Else If (text' = "ternary"), then

  1. If (tblctx.MODE matches pattern `NOPRI`), then

    1. Return tblctx[MODE = (PRI)]

  2. Let mode be tblctx.MODE

  3. If (mode matches pattern `NOPRILPM%`), then

    1. Let (NOPRILPM _nat) be mode

    2. Return tblctx[MODE = (PRILPM)]

1. Else If (text' = "optional"), then

  1. If (tblctx.MODE matches pattern `NOPRI`), then

    1. Return tblctx[MODE = (PRI)]

  2. Let mode be tblctx.MODE

  3. If (mode matches pattern `NOPRILPM%`), then

    1. Let (NOPRILPM _nat) be mode

    2. Return tblctx[MODE = (PRILPM)]

2. Otherwise

  1. Return tblctx

;; ../../../../spec/4a2-typing-tblctx.watsup:129.1-129.49
def $update_state(tblstate, tblstate')

1. If (tblstate matches pattern `NOLPM`), then

  1. If (tblstate' matches pattern `LPM%`), then

    1. Let (LPM nat) be tblstate'

    2. Return (LPM nat)

  1. Else If (tblstate' matches pattern `NOLPM`), then

    1. Return (NOLPM)

1. Else If (tblstate matches pattern `LPM%`), then

  1. Let (LPM nat) be tblstate

  2. If (tblstate' matches pattern `NOLPM`), then

    1. Return (LPM nat)

  2. Else

    1. Phantom#571

;; ../../../../spec/4a2-typing-tblctx.watsup:139.1-139.54
def $find_action(tblctx, name)

1. Let (name_a, pt_a*, argIL_a*)* be tblctx.ACTIONS

2. Return $assoc_<name, (paramtyp*, argIL*)>(name, (name_a, (pt_a*, argIL_a*))*)

;; ../../../../spec/4a2-typing-tblctx.watsup:145.1-145.38
def $find_last_priority(tblctx)

1. Let i_pri* be tblctx.PRIORITIES.VALUES

2. Return i_pri*[(|i_pri*| - 1)]

;; ../../../../spec/4a2-typing-tblctx.watsup:154.1-154.38
def $keys_of_table(tblprop*)

1. If (tblprop* matches pattern []), then

  1. Return []

1. Else If (tblprop* matches pattern _ :: _), then

  1. Let tblprop :: tblprop_t* be tblprop*

  2. If (tblprop matches pattern `KeyP%`), then

    1. Let (KeyP tblkeyprop) be tblprop

    2. Return tblkeyprop :: $keys_of_table(tblprop_t*)

  2. Else

    1. Phantom#572

  3. Let tblprop_h :: tblprop_t* be tblprop*

  4. Otherwise

    1. Return $keys_of_table(tblprop_t*)

;; ../../../../spec/4a2-typing-tblctx.watsup:161.1-161.44
def $actions_of_table(tblprop*)

1. If (tblprop* matches pattern []), then

  1. Return []

1. Else If (tblprop* matches pattern _ :: _), then

  1. Let tblprop :: tblprop_t* be tblprop*

  2. If (tblprop matches pattern `ActionP%`), then

    1. Let (ActionP tblactionprop) be tblprop

    2. Return tblactionprop :: $actions_of_table(tblprop_t*)

  2. Else

    1. Phantom#573

  3. Let tblprop_h :: tblprop_t* be tblprop*

  4. Otherwise

    1. Return $actions_of_table(tblprop_t*)

;; ../../../../spec/4b-typing-relation.watsup:5.1-5.29
def $annot(exprIL)

1. If (exprIL matches pattern `ValueE%%`), then

  1. Let (ValueE _val annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `NameE%%`), then

  1. Let (NameE _nameIL annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `SeqE%%`), then

  1. Let (SeqE _exprIL* annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `SeqDefaultE%%`), then

  1. Let (SeqDefaultE _exprIL* annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `RecordE%%`), then

  1. Let (RecordE _(memberIL, exprIL)* annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `RecordDefaultE%%`), then

  1. Let (RecordDefaultE _(memberIL, exprIL)* annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `DefaultE%`), then

  1. Let (DefaultE annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `UnE%%%`), then

  1. Let (UnE _unopIL _exprIL annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `BinE%%%%`), then

  1. Let (BinE _binopIL _exprIL _exprIL' annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `TernE%%%%`), then

  1. Let (TernE _exprIL _exprIL' _exprIL'' annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `CastE%%%`), then

  1. Let (CastE _typeIL _exprIL annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `MaskE%%%`), then

  1. Let (MaskE _exprIL _exprIL' annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `RangeE%%%`), then

  1. Let (RangeE _exprIL _exprIL' annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `SelectE%%%`), then

  1. Let (SelectE _exprIL* _selectcaseIL* annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `ArrAccE%%%`), then

  1. Let (ArrAccE _exprIL _exprIL' annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `BitAccE%%%%`), then

  1. Let (BitAccE _exprIL _exprIL' _exprIL'' annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `ExprAccE%%%`), then

  1. Let (ExprAccE _exprIL _memberIL annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `CallFuncE%%%%`), then

  1. Let (CallFuncE _nameIL _targIL* _argIL* annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `CallMethodE%%%%%`), then

  1. Let (CallMethodE _exprIL _memberIL _targIL* _argIL* annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `CallTypeE%%%%%`), then

  1. Let (CallTypeE _nameIL _memberIL _targIL* _argIL* annotIL) be exprIL

  2. Return annotIL

1. Else If (exprIL matches pattern `InstE%%%%`), then

  1. Let (InstE _nameIL _targIL* _argIL* annotIL) be exprIL

  2. Return annotIL

;; ../../../../spec/4b-typing-relation.watsup:34.1-36.23
relation Eval_static: p, C, exprIL''

1. If (exprIL'' matches pattern `ValueE%%`), then

  1. Let (ValueE val _annotIL) be exprIL''

  2. Result in val

1. Else If (exprIL'' matches pattern `NameE%%`), then

  1. Let (NameE name _annotIL) be exprIL''

  2. Let val? be $find_val(p, C, name)

  3. If (val? matches pattern (_)), then

    1. Let ?(val) be val?

    2. Result in val

  3. Else

    1. Phantom#587

1. Else If (exprIL'' matches pattern `SeqE%%`), then

  1. Let (SeqE exprIL''* _annotIL) be exprIL''

  2. (Eval_static: p C |- exprIL'' ~> val)*

  3. Result in (SeqV val*)

1. Else If (exprIL'' matches pattern `SeqDefaultE%%`), then

  1. Let (SeqDefaultE exprIL''* _annotIL) be exprIL''

  2. (Eval_static: p C |- exprIL'' ~> val)*

  3. Result in (SeqDefaultV val*)

1. Else If (exprIL'' matches pattern `RecordE%%`), then

  1. Let (RecordE (member, exprIL'')* _annotIL) be exprIL''

  2. (Eval_static: p C |- exprIL'' ~> val)*

  3. Result in (RecordV (member, val)*)

1. Else If (exprIL'' matches pattern `RecordDefaultE%%`), then

  1. Let (RecordDefaultE (member, exprIL'')* _annotIL) be exprIL''

  2. (Eval_static: p C |- exprIL'' ~> val)*

  3. Result in (RecordDefaultV (member, val)*)

1. Else If (exprIL'' matches pattern `DefaultE%`), then

  1. Let (DefaultE _annotIL) be exprIL''

  2. Result in (DefaultV)

1. Else If (exprIL'' matches pattern `UnE%%%`), then

  1. Let (UnE unop exprIL'' _annotIL) be exprIL''

  2. Eval_static: p C |- exprIL'' ~> val

  3. Result in $un_op(unop, val)

1. Else If (exprIL'' matches pattern `BinE%%%%`), then

  1. Let (BinE binop exprIL_l exprIL_r _annotIL) be exprIL''

  2. Eval_static: p C |- exprIL_l ~> val_l

  3. Eval_static: p C |- exprIL_r ~> val_r

  4. Result in $bin_op(binop, val_l, val_r)

1. Else If (exprIL'' matches pattern `TernE%%%%`), then

  1. Let (TernE exprIL_c exprIL_t exprIL_f _annotIL) be exprIL''

  2. Eval_static: p C |- exprIL_c ~> val'

  3. If (val' = (BoolV true)), then

    1. Eval_static: p C |- exprIL_t ~> val

    2. Result in val

  3. Else

    1. Phantom#585

  4. If (val' = (BoolV false)), then

    1. Eval_static: p C |- exprIL_f ~> val

    2. Result in val

  4. Else

    1. Phantom#586

1. Else If (exprIL'' matches pattern `CastE%%%`), then

  1. Let (CastE typ exprIL'' _annotIL) be exprIL''

  2. Eval_static: p C |- exprIL'' ~> val

  3. Result in $cast_op(typ, val)

1. Else If (exprIL'' matches pattern `BitAccE%%%%`), then

  1. Let (BitAccE exprIL_b exprIL_l exprIL_h _annotIL) be exprIL''

  2. Eval_static: p C |- exprIL_b ~> val_b

  3. Eval_static: p C |- exprIL_l ~> val_l

  4. Eval_static: p C |- exprIL_h ~> val_h

  5. Result in $bitacc_op(val_b, val_h, val_l)

1. Else If (exprIL'' matches pattern `ExprAccE%%%`), then

  1. Let (ExprAccE exprIL_b text _annotIL) be exprIL''

  2. If (text = "size"), then

    1. Eval_static: p C |- exprIL_b ~> val'

    2. If (val' matches pattern `StackV%%%`), then

      1. Let (StackV val* i_size i_idx) be val'

      2. Result in (IntV i_size)

    2. Else

      1. Phantom#583

  2. Else

    1. Phantom#584

1. Else If (exprIL'' matches pattern `CallMethodE%%%%%`), then

  1. Let (CallMethodE exprIL_b member targIL* argIL* _annotIL) be exprIL''

  2. If (targIL* matches pattern []), then

    1. If (argIL* matches pattern []), then

      1. If ((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes")), then

        1. Let (( typ_b ; _ctk )) be $annot(exprIL_b)

        2. Let val be $size(typ_b, member)

        3. Result in val

      1. Else

        1. Phantom#580

    1. Else

      1. Phantom#581

  2. Else

    1. Phantom#582

1. Else If (exprIL'' matches pattern `CallTypeE%%%%%`), then

  1. Let (CallTypeE name member targIL* argIL* _annotIL) be exprIL''

  2. If (targIL* matches pattern []), then

    1. If (argIL* matches pattern []), then

      1. If ((((member = "minSizeInBits") \/ (member = "minSizeInBytes")) \/ (member = "maxSizeInBits")) \/ (member = "maxSizeInBytes")), then

        1. Let typdef? be $find_typdef(p, C, name)

        2. If (typdef? matches pattern (_)), then

          1. Let ?(typdef) be typdef?

          2. If (typdef has type monotypdef), then

            1. Let (MonoD typ) be (typdef as monotypdef)

            2. Result in $size(typ, member)

          2. Else

            1. Phantom#574

        2. Else

          1. Phantom#575

      1. Else

        1. Phantom#576

    1. Else

      1. Phantom#577

  2. Else

    1. Phantom#578

1. Else

  1. Phantom#579

;; ../../../../spec/4b-typing-relation.watsup:43.1-45.23
relation Type_ok: p, C, type''

1. If (type'' matches pattern `VoidT`), then

  1. Result in ((VoidT) as typ), []

1. Else If (type'' matches pattern `ErrT`), then

  1. Result in ((ErrT) as typ), []

1. Else If (type'' matches pattern `MatchKindT`), then

  1. Result in ((MatchKindT) as typ), []

1. Else If (type'' matches pattern `StrT`), then

  1. Result in ((StrT) as typ), []

1. Else If (type'' matches pattern `BoolT`), then

  1. Result in ((BoolT) as typ), []

1. Else If (type'' matches pattern `IntT`), then

  1. Result in ((IntT) as typ), []

1. Else If (type'' matches pattern `FIntT%`), then

  1. Let (FIntT expr) be type''

  2. Expr_ok: p C |- expr : exprIL

  3. Let (( _typ ; ctk )) be $annot(exprIL)

  4. If (ctk matches pattern `LCTK`), then

    1. Eval_static: p C |- exprIL ~> val

    2. Let int be $get_num(val)

    3. If (int has type nat), then

      1. Let w be (int as nat)

      2. Result in ((FIntT w) as typ), []

    3. Else

      1. Phantom#599

  4. Else

    1. Phantom#600

1. Else If (type'' matches pattern `FBitT%`), then

  1. Let (FBitT expr) be type''

  2. Expr_ok: p C |- expr : exprIL

  3. Let (( _typ ; ctk )) be $annot(exprIL)

  4. If (ctk matches pattern `LCTK`), then

    1. Eval_static: p C |- exprIL ~> val

    2. Let int be $get_num(val)

    3. If (int has type nat), then

      1. Let w be (int as nat)

      2. Result in ((FBitT w) as typ), []

    3. Else

      1. Phantom#597

  4. Else

    1. Phantom#598

1. Else If (type'' matches pattern `VBitT%`), then

  1. Let (VBitT expr) be type''

  2. Expr_ok: p C |- expr : exprIL

  3. Let (( _typ ; ctk )) be $annot(exprIL)

  4. If (ctk matches pattern `LCTK`), then

    1. Eval_static: p C |- exprIL ~> val

    2. Let int be $get_num(val)

    3. If (int has type nat), then

      1. Let w be (int as nat)

      2. Result in ((VBitT w) as typ), []

    3. Else

      1. Phantom#595

  4. Else

    1. Phantom#596

1. Else If (type'' matches pattern `StackT%%`), then

  1. Let (StackT type'' expr) be type''

  2. Type_ok: p C |- type'' : typ tid_fresh*

  3. Expr_ok: p C |- expr : exprIL

  4. Let (( _typ ; ctk )) be $annot(exprIL)

  5. If (ctk matches pattern `LCTK`), then

    1. Eval_static: p C |- exprIL ~> val

    2. Let i_size be $get_num(val)

    3. Let ptd be (PolyD (["T"], []) -> ((StackT ((VarT "T") as typ) i_size) as typ))

    4. Result in ((SpecT ptd [typ]) as typ), tid_fresh*

  5. Else

    1. Phantom#594

1. Else If (type'' matches pattern `ListT%`), then

  1. Let (ListT type'') be type''

  2. Type_ok: p C |- type'' : typ tid_fresh*

  3. Let ptd be (PolyD (["T"], []) -> ((ListT ((VarT "T") as typ)) as typ))

  4. Result in ((SpecT ptd [typ]) as typ), tid_fresh*

1. Else If (type'' matches pattern `TupleT%`), then

  1. Let (TupleT type''*) be type''

  2. (Type_ok: p C |- type'' : typ tid_fresh_i*)*

  3. Let tid_fresh* be $concat_<tid>(tid_fresh_i**)

  4. Let i_idx* be ($init_(|typ*|) as int*)

  5. (Let tid be $concat_text(["T", $int_to_text(i_idx)]))*

  6. Let ptd be (PolyD (tid*, []) -> ((TupleT ((VarT tid) as typ)*) as typ))

  7. Result in ((SpecT ptd typ*) as typ), tid_fresh*

1. Else If (type'' matches pattern `NameT%`), then

  1. Let (NameT name) be type''

  2. Let typdef? be $find_typdef(p, C, name)

  3. If (typdef? matches pattern (_)), then

    1. Let ?(typdef) be typdef?

    2. If (typdef has type monotypdef), then

      1. Let (MonoD typ) be (typdef as monotypdef)

      2. Result in typ, []

    2. Else If (typdef has type polytypdef), then

      1. Let (PolyD (tparam*, tparam_hidden*) -> typ) be (typdef as polytypdef)

      2. Let ptd be (PolyD (tparam*, tparam_hidden*) -> typ)

      3. Result in ((SpecT ptd []) as typ), []

  3. Else

    1. Phantom#593

1. Else If (type'' matches pattern `SpecT%%`), then

  1. Let (SpecT name type*) be type''

  2. If (type* matches pattern []), then

    1. Let typdef? be $find_typdef(p, C, name)

    2. If (typdef? matches pattern (_)), then

      1. Let ?(typdef) be typdef?

      2. If (typdef has type monotypdef), then

        1. Let (MonoD typ) be (typdef as monotypdef)

        2. Result in typ, []

      2. Else

        1. Phantom#588

    2. Else

      1. Phantom#589

  2. Else

    1. Phantom#590

  3. Let (SpecT name type''*) be type''

  4. Let typdef? be $find_typdef(p, C, name)

  5. If (typdef? matches pattern (_)), then

    1. Let ?(typdef) be typdef?

    2. If (typdef has type polytypdef), then

      1. Let ptd be (typdef as polytypdef)

      2. Let (PolyD (tparam*, tparam_hidden*) -> typ) be ptd

      3. (Type_ok: p C |- type'' : typ_a tid_fresh_a*)*

      4. Let tid_fresh* be $concat_<tid>(tid_fresh_a**)

      5. Result in ((SpecT ptd typ_a*) as typ), tid_fresh*

    2. Else

      1. Phantom#591

  5. Else

    1. Phantom#592

1. Else If (type'' matches pattern `AnyT`), then

  1. Let tid be $fresh_tid

  2. Result in ((VarT tid) as typ), [tid]

;; ../../../../spec/4b-typing-relation.watsup:48.1-50.20
relation Sub_expl: typ_a, typ_b

1. If (Sub_expl_canon: $canon_typ(typ_a) <: $canon_typ(typ_b) holds), then

  1. The relation holds

1. Else

  1. Phantom#601

;; ../../../../spec/4b-typing-relation.watsup:51.1-53.20
relation Sub_expl_canon: typ_a, typ_b

1. If (Type_alpha: typ_a ~~ typ_b holds), then

  1. The relation holds

1. Else If ~(Type_alpha: typ_a ~~ typ_b holds), then

  1. If (Sub_expl_canon_neq: typ_a <: typ_b holds), then

    1. The relation holds

  1. Else

    1. Phantom#602

;; ../../../../spec/4b-typing-relation.watsup:54.1-56.20
relation Sub_expl_canon_neq: typ'', typ'''

1. If (typ'' = ((FBitT 1) as typ)), then

  1. If (typ''' = ((BoolT) as typ)), then

    1. The relation holds

  1. Else

    1. Phantom#603

1. Else

  1. Phantom#604

2. If (typ'' = ((BoolT) as typ)), then

  1. If (typ''' = ((FBitT 1) as typ)), then

    1. The relation holds

  1. Else

    1. Phantom#605

2. Else

  1. Phantom#606

3. If (typ'' = ((IntT) as typ)), then

  1. If (typ''' = ((BoolT) as typ)), then

    1. The relation holds

  1. Else

    1. Phantom#607

  2. If (typ''' has type numtyp), then

    1. Let numtyp be (typ''' as numtyp)

    2. If (numtyp matches pattern `FBitT%`), then

      1. Let (FBitT width) be numtyp

      2. The relation holds

    2. Else If (numtyp matches pattern `FIntT%`), then

      1. Let (FIntT width) be numtyp

      2. The relation holds

    2. Else

      1. Phantom#608

  2. Else

    1. Phantom#609

3. Else

  1. Phantom#610

4. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT width_a) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT width_b) be numtyp'

        2. The relation holds

      2. Else If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT width_b) be numtyp'

        2. The relation holds

      2. Else

        1. Phantom#669

    2. Else

      1. Phantom#670

    3. Let (FIntT width) be numtyp

    4. If (typ''' = ((IntT) as typ)), then

      1. The relation holds

    4. Else

      1. Phantom#671

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT width_a) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT width_b) be numtyp'

        2. The relation holds

      2. Else If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT width_b) be numtyp'

        2. The relation holds

      2. Else

        1. Phantom#665

    2. Else

      1. Phantom#666

    3. Let (FBitT width) be numtyp

    4. If (typ''' = ((IntT) as typ)), then

      1. The relation holds

    4. Else

      1. Phantom#667

  2. Else

    1. Phantom#668

4. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ_a) be datatyp

    2. If (Sub_impl: typ_a << typ''' holds), then

      1. The relation holds

    2. Else

      1. Phantom#664

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id typ'' _(member, val)*) be datatyp

    2. If (Sub_impl: typ'' << typ''' holds), then

      1. The relation holds

    2. Else

      1. Phantom#662

  2. Else

    1. Phantom#663

4. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT typ''*) be synthtyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp be (typ''' as datatyp)

      2. If (datatyp matches pattern `ListT%`), then

        1. Let (ListT typ''') be datatyp

        2. If ((Sub_expl: typ'' <: typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#659

      2. Else If (datatyp matches pattern `TupleT%`), then

        1. Let (TupleT typ'''*) be datatyp

        2. If ((Sub_expl: typ'' <: typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#658

      2. Else If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ''' i_size) be datatyp

        2. If ((|typ''*| as int) <= i_size), then

          1. If ((Sub_expl: typ'' <: typ''' holds))*, then

            1. The relation holds

          1. Else

            1. Phantom#656

        2. Else

          1. Phantom#657

      2. Else If (datatyp matches pattern `StructT%%`), then

        1. Let (StructT _id (_member, typ''')*) be datatyp

        2. If ((Sub_expl: typ'' <: typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#655

      2. Else If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT _id (_member, typ''')*) be datatyp

        2. If ((Sub_expl: typ'' <: typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#653

      2. Else

        1. Phantom#654

    2. Else

      1. Phantom#660

  2. Else If (synthtyp matches pattern `RecordT%`), then

    1. Let (RecordT (member_a, typ'')*) be synthtyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp be (typ''' as datatyp)

      2. If (datatyp matches pattern `StructT%%`), then

        1. Let (StructT _id (member_b, typ''')*) be datatyp

        2. If $eq_set<member>(({ member_a* }), ({ member_b* })), then

          1. (Let typ? be $find_map<member, typ>(({ (member_a -> typ'')* }), member_a))*

          2. If ((typ? matches pattern (_)))*, then

            1. (Let ?(typ_a') be typ?)*

            2. (Let typ?' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

            3. If ((typ?' matches pattern (_)))*, then

              1. (Let ?(typ_b') be typ?')*

              2. If ((Sub_expl: typ_a' <: typ_b' holds))*, then

                1. The relation holds

              2. Else

                1. Phantom#648

            3. Else

              1. Phantom#649

          2. Else

            1. Phantom#650

        2. Else

          1. Phantom#651

      2. Else If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT _id (member_b, typ''')*) be datatyp

        2. If $eq_set<member>(({ member_a* }), ({ member_b* })), then

          1. (Let typ? be $find_map<member, typ>(({ (member_a -> typ'')* }), member_a))*

          2. If ((typ? matches pattern (_)))*, then

            1. (Let ?(typ_a') be typ?)*

            2. (Let typ?' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

            3. If ((typ?' matches pattern (_)))*, then

              1. (Let ?(typ_b') be typ?')*

              2. If ((Sub_expl: typ_a' <: typ_b' holds))*, then

                1. The relation holds

              2. Else

                1. Phantom#643

            3. Else

              1. Phantom#644

          2. Else

            1. Phantom#645

        2. Else

          1. Phantom#646

      2. Else

        1. Phantom#647

    2. Else

      1. Phantom#652

  2. Else If (synthtyp matches pattern `SeqDefaultT%`), then

    1. Let (SeqDefaultT typ''*) be synthtyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp be (typ''' as datatyp)

      2. If (datatyp matches pattern `TupleT%`), then

        1. Let (TupleT typ'''*) be datatyp

        2. If (|typ''*| < |typ'''*|), then

          1. Let (typ_c*, typ_d*) be $partition_<typ>(typ'''*, |typ''*|)

          2. If ((Sub_expl: typ'' <: typ_c holds))*, then

            1. If ($is_deftable(typ_d))*, then

              1. The relation holds

            1. Else

              1. Phantom#639

          2. Else

            1. Phantom#640

        2. Else

          1. Phantom#641

      2. Else If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ''' i_size) be datatyp

        2. If ((|typ''*| as int) < i_size), then

          1. If ((Sub_expl: typ'' <: typ''' holds))*, then

            1. If $is_deftable(typ'''), then

              1. The relation holds

            1. Else

              1. Phantom#636

          1. Else

            1. Phantom#637

        2. Else

          1. Phantom#638

      2. Else If (datatyp matches pattern `StructT%%`), then

        1. Let (StructT _id (_member, typ''')*) be datatyp

        2. If (|typ''*| < |typ'''*|), then

          1. Let (typ_c*, typ_d*) be $partition_<typ>(typ'''*, |typ''*|)

          2. If ((Sub_expl: typ'' <: typ_c holds))*, then

            1. If ($is_deftable(typ_d))*, then

              1. The relation holds

            1. Else

              1. Phantom#633

          2. Else

            1. Phantom#634

        2. Else

          1. Phantom#635

      2. Else If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT _id (_member, typ''')*) be datatyp

        2. If (|typ''*| < |typ'''*|), then

          1. Let (typ_c*, typ_d*) be $partition_<typ>(typ'''*, |typ''*|)

          2. If ((Sub_expl: typ'' <: typ_c holds))*, then

            1. If ($is_deftable(typ_d))*, then

              1. The relation holds

            1. Else

              1. Phantom#629

          2. Else

            1. Phantom#630

        2. Else

          1. Phantom#631

      2. Else

        1. Phantom#632

    2. Else

      1. Phantom#642

  2. Else If (synthtyp matches pattern `RecordDefaultT%`), then

    1. Let (RecordDefaultT (member_a, typ'')*) be synthtyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp be (typ''' as datatyp)

      2. If (datatyp matches pattern `StructT%%`), then

        1. Let (StructT _id (member_b, typ''')*) be datatyp

        2. If $sub_set<member>(({ member_a* }), ({ member_b* })), then

          1. Let ({ member_c* }) be $diff_set<member>(({ member_b* }), ({ member_a* }))

          2. (Let typ? be $find_map<member, typ>(({ (member_a -> typ'')* }), member_a))*

          3. If ((typ? matches pattern (_)))*, then

            1. (Let ?(typ_a') be typ?)*

            2. (Let typ?' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

            3. If ((typ?' matches pattern (_)))*, then

              1. (Let ?(typ_b') be typ?')*

              2. If ((Sub_expl: typ_a' <: typ_b' holds))*, then

                1. (Let typ?'' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

                2. If ((typ?'' matches pattern (_)))*, then

                  1. (Let ?(typ_c') be typ?'')*

                  2. If ($is_deftable(typ_c'))*, then

                    1. The relation holds

                  2. Else

                    1. Phantom#622

                2. Else

                  1. Phantom#623

              2. Else

                1. Phantom#624

            3. Else

              1. Phantom#625

          3. Else

            1. Phantom#626

        2. Else

          1. Phantom#627

      2. Else If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT _id (member_b, typ''')*) be datatyp

        2. If $sub_set<member>(({ member_a* }), ({ member_a* })), then

          1. Let ({ member_c* }) be $diff_set<member>(({ member_b* }), ({ member_a* }))

          2. (Let typ? be $find_map<member, typ>(({ (member_a -> typ'')* }), member_a))*

          3. If ((typ? matches pattern (_)))*, then

            1. (Let ?(typ_a') be typ?)*

            2. (Let typ?' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

            3. If ((typ?' matches pattern (_)))*, then

              1. (Let ?(typ_b') be typ?')*

              2. If ((Sub_expl: typ_a' <: typ_b' holds))*, then

                1. (Let typ?'' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

                2. If ((typ?'' matches pattern (_)))*, then

                  1. (Let ?(typ_c') be typ?'')*

                  2. If ($is_deftable(typ_c'))*, then

                    1. The relation holds

                  2. Else

                    1. Phantom#615

                2. Else

                  1. Phantom#616

              2. Else

                1. Phantom#617

            3. Else

              1. Phantom#618

          3. Else

            1. Phantom#619

        2. Else

          1. Phantom#620

      2. Else

        1. Phantom#621

    2. Else

      1. Phantom#628

  2. Else If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ'') be synthtyp

    2. If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `SetT%`), then

        1. Let (SetT typ''') be synthtyp'

        2. If (Sub_expl: typ'' <: typ''' holds), then

          1. The relation holds

        2. Else

          1. Phantom#611

      2. Else

        1. Phantom#612

    2. Else

      1. Phantom#613

  2. Else

    1. Phantom#614

4. Else

  1. Phantom#661

5. If (typ''' has type datatyp), then

  1. Let datatyp be (typ''' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT _id typ''') be datatyp

    2. If (Sub_impl: typ'' << typ''' holds), then

      1. The relation holds

    2. Else

      1. Phantom#677

  2. Else If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id typ''' _(member, val)*) be datatyp

    2. If (Sub_impl: typ'' << typ''' holds), then

      1. The relation holds

    2. Else

      1. Phantom#675

  2. Else

    1. Phantom#676

5. Else If (typ''' has type synthtyp), then

  1. Let synthtyp be (typ''' as synthtyp)

  2. If (synthtyp matches pattern `SetT%`), then

    1. Let (SetT typ''') be synthtyp

    2. If (Sub_expl: typ'' <: typ''' holds), then

      1. The relation holds

    2. Else

      1. Phantom#672

  2. Else

    1. Phantom#673

5. Else

  1. Phantom#674

6. If (typ'' = ((DefaultT) as typ)), then

  1. If $is_deftable(typ'''), then

    1. The relation holds

  1. Else

    1. Phantom#678

6. Else

  1. Phantom#679

7. If (typ'' = ((InvalidT) as typ)), then

  1. If (typ''' has type datatyp), then

    1. Let datatyp be (typ''' as datatyp)

    2. If (datatyp matches pattern `HeaderT%%`), then

      1. Let (HeaderT _id _(member, typ)*) be datatyp

      2. The relation holds

    2. Else If (datatyp matches pattern `UnionT%%`), then

      1. Let (UnionT _id _(member, typ)*) be datatyp

      2. The relation holds

    2. Else

      1. Phantom#680

  1. Else

    1. Phantom#681

7. Else

  1. Phantom#682

;; ../../../../spec/4b-typing-relation.watsup:57.1-59.20
relation Sub_impl: typ_a, typ_b

1. If (Sub_impl_canon: $canon_typ(typ_a) << $canon_typ(typ_b) holds), then

  1. The relation holds

1. Else

  1. Phantom#683

;; ../../../../spec/4b-typing-relation.watsup:60.1-62.20
relation Sub_impl_canon: typ_a, typ_b

1. If (Type_alpha: typ_a ~~ typ_b holds), then

  1. The relation holds

1. Else If ~(Type_alpha: typ_a ~~ typ_b holds), then

  1. If (Sub_impl_canon_neq: typ_a << typ_b holds), then

    1. The relation holds

  1. Else

    1. Phantom#684

;; ../../../../spec/4b-typing-relation.watsup:63.1-65.20
relation Sub_impl_canon_neq: typ'', typ'''

1. If (typ'' = ((IntT) as typ)), then

  1. If (typ''' has type numtyp), then

    1. Let numtyp be (typ''' as numtyp)

    2. If (numtyp matches pattern `FBitT%`), then

      1. Let (FBitT _width) be numtyp

      2. The relation holds

    2. Else If (numtyp matches pattern `FIntT%`), then

      1. Let (FIntT _width) be numtyp

      2. The relation holds

    2. Else

      1. Phantom#685

  1. Else

    1. Phantom#686

1. Else

  1. Phantom#687

2. If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `SEnumT%%%`), then

    1. Let (SEnumT _id typ_a _(member, val)*) be datatyp

    2. If (Sub_impl: typ_a << typ''' holds), then

      1. The relation holds

    2. Else

      1. Phantom#738

  2. Else

    1. Phantom#739

2. Else If (typ'' has type synthtyp), then

  1. Let synthtyp be (typ'' as synthtyp)

  2. If (synthtyp matches pattern `SeqT%`), then

    1. Let (SeqT typ_a*) be synthtyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp be (typ''' as datatyp)

      2. If (datatyp matches pattern `ListT%`), then

        1. Let (ListT typ''') be datatyp

        2. If ((Sub_impl: typ_a << typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#736

      2. Else If (datatyp matches pattern `TupleT%`), then

        1. Let (TupleT typ'''*) be datatyp

        2. If ((Sub_impl: typ_a << typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#735

      2. Else If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ''' i_size) be datatyp

        2. If ((|typ_a*| as int) <= i_size), then

          1. If ((Sub_impl: typ_a << typ''' holds))*, then

            1. The relation holds

          1. Else

            1. Phantom#733

        2. Else

          1. Phantom#734

      2. Else If (datatyp matches pattern `StructT%%`), then

        1. Let (StructT _id (_member, typ''')*) be datatyp

        2. If ((Sub_impl: typ_a << typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#732

      2. Else If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT _id (_member, typ''')*) be datatyp

        2. If ((Sub_impl: typ_a << typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#730

      2. Else

        1. Phantom#731

    2. Else If (typ''' has type synthtyp), then

      1. Let synthtyp' be (typ''' as synthtyp)

      2. If (synthtyp' matches pattern `SeqT%`), then

        1. Let (SeqT typ'''*) be synthtyp'

        2. If ((Sub_impl: typ_a << typ''' holds))*, then

          1. The relation holds

        2. Else

          1. Phantom#727

      2. Else

        1. Phantom#728

    2. Else

      1. Phantom#729

  2. Else If (synthtyp matches pattern `RecordT%`), then

    1. Let (RecordT (member_a, typ_a)*) be synthtyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp be (typ''' as datatyp)

      2. If (datatyp matches pattern `StructT%%`), then

        1. Let (StructT _id (member_b, typ''')*) be datatyp

        2. If $eq_set<member>(({ member_a* }), ({ member_b* })), then

          1. (Let typ? be $find_map<member, typ>(({ (member_a -> typ_a)* }), member_a))*

          2. If ((typ? matches pattern (_)))*, then

            1. (Let ?(typ_a') be typ?)*

            2. (Let typ?' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

            3. If ((typ?' matches pattern (_)))*, then

              1. (Let ?(typ_b') be typ?')*

              2. If ((Sub_impl: typ_a' << typ_b' holds))*, then

                1. The relation holds

              2. Else

                1. Phantom#722

            3. Else

              1. Phantom#723

          2. Else

            1. Phantom#724

        2. Else

          1. Phantom#725

      2. Else If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT _id (member_b, typ''')*) be datatyp

        2. If $eq_set<member>(({ member_a* }), ({ member_b* })), then

          1. (Let typ? be $find_map<member, typ>(({ (member_a -> typ_a)* }), member_a))*

          2. If ((typ? matches pattern (_)))*, then

            1. (Let ?(typ_a') be typ?)*

            2. (Let typ?' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

            3. If ((typ?' matches pattern (_)))*, then

              1. (Let ?(typ_b') be typ?')*

              2. If ((Sub_impl: typ_a' << typ_b' holds))*, then

                1. The relation holds

              2. Else

                1. Phantom#717

            3. Else

              1. Phantom#718

          2. Else

            1. Phantom#719

        2. Else

          1. Phantom#720

      2. Else

        1. Phantom#721

    2. Else

      1. Phantom#726

  2. Else If (synthtyp matches pattern `SeqDefaultT%`), then

    1. Let (SeqDefaultT typ_a*) be synthtyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp be (typ''' as datatyp)

      2. If (datatyp matches pattern `TupleT%`), then

        1. Let (TupleT typ'''*) be datatyp

        2. If (|typ_a*| < |typ'''*|), then

          1. Let (typ_c*, typ_d*) be $partition_<typ>(typ'''*, |typ_a*|)

          2. If ((Sub_impl: typ_a << typ_c holds))*, then

            1. If ($is_deftable(typ_d))*, then

              1. The relation holds

            1. Else

              1. Phantom#713

          2. Else

            1. Phantom#714

        2. Else

          1. Phantom#715

      2. Else If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ''' i_size) be datatyp

        2. If ((|typ_a*| as int) < i_size), then

          1. If ((Sub_impl: typ_a << typ''' holds))*, then

            1. If $is_deftable(typ'''), then

              1. The relation holds

            1. Else

              1. Phantom#710

          1. Else

            1. Phantom#711

        2. Else

          1. Phantom#712

      2. Else If (datatyp matches pattern `StructT%%`), then

        1. Let (StructT _id (_member, typ''')*) be datatyp

        2. If (|typ_a*| < |typ'''*|), then

          1. Let (typ_c*, typ_d*) be $partition_<typ>(typ'''*, |typ_a*|)

          2. If ((Sub_impl: typ_a << typ_c holds))*, then

            1. If ($is_deftable(typ_d))*, then

              1. The relation holds

            1. Else

              1. Phantom#707

          2. Else

            1. Phantom#708

        2. Else

          1. Phantom#709

      2. Else If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT _id (_member, typ''')*) be datatyp

        2. If (|typ_a*| < |typ'''*|), then

          1. Let (typ_c*, typ_d*) be $partition_<typ>(typ'''*, |typ_a*|)

          2. If ((Sub_impl: typ_a << typ_c holds))*, then

            1. If ($is_deftable(typ_d))*, then

              1. The relation holds

            1. Else

              1. Phantom#703

          2. Else

            1. Phantom#704

        2. Else

          1. Phantom#705

      2. Else

        1. Phantom#706

    2. Else

      1. Phantom#716

  2. Else If (synthtyp matches pattern `RecordDefaultT%`), then

    1. Let (RecordDefaultT (member_a, typ_a)*) be synthtyp

    2. If (typ''' has type datatyp), then

      1. Let datatyp be (typ''' as datatyp)

      2. If (datatyp matches pattern `StructT%%`), then

        1. Let (StructT _id (member_b, typ''')*) be datatyp

        2. If $sub_set<member>(({ member_a* }), ({ member_b* })), then

          1. Let ({ member_c* }) be $diff_set<member>(({ member_b* }), ({ member_a* }))

          2. (Let typ? be $find_map<member, typ>(({ (member_a -> typ_a)* }), member_a))*

          3. If ((typ? matches pattern (_)))*, then

            1. (Let ?(typ_a') be typ?)*

            2. (Let typ?' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

            3. If ((typ?' matches pattern (_)))*, then

              1. (Let ?(typ_b') be typ?')*

              2. If ((Sub_impl: typ_a' << typ_b' holds))*, then

                1. (Let typ?'' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_c))*

                2. If ((typ?'' matches pattern (_)))*, then

                  1. (Let ?(typ_c') be typ?'')*

                  2. If ($is_deftable(typ_c'))*, then

                    1. The relation holds

                  2. Else

                    1. Phantom#695

                2. Else

                  1. Phantom#696

              2. Else

                1. Phantom#697

            3. Else

              1. Phantom#698

          3. Else

            1. Phantom#699

        2. Else

          1. Phantom#700

      2. Else If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT id (member_b, typ''')*) be datatyp

        2. If $sub_set<member>(({ member_a* }), ({ member_b* })), then

          1. Let ({ member_c* }) be $diff_set<member>(({ member_b* }), ({ member_a* }))

          2. (Let typ? be $find_map<member, typ>(({ (member_a -> typ_a)* }), member_a))*

          3. If ((typ? matches pattern (_)))*, then

            1. (Let ?(typ_a') be typ?)*

            2. (Let typ?' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_a))*

            3. If ((typ?' matches pattern (_)))*, then

              1. (Let ?(typ_b') be typ?')*

              2. If ((Sub_impl: typ_a' << typ_b' holds))*, then

                1. (Let typ?'' be $find_map<member, typ>(({ (member_b -> typ''')* }), member_c))*

                2. If ((typ?'' matches pattern (_)))*, then

                  1. (Let ?(typ_c') be typ?'')*

                  2. If ($is_deftable(typ_c'))*, then

                    1. The relation holds

                  2. Else

                    1. Phantom#688

                2. Else

                  1. Phantom#689

              2. Else

                1. Phantom#690

            3. Else

              1. Phantom#691

          3. Else

            1. Phantom#692

        2. Else

          1. Phantom#693

      2. Else

        1. Phantom#694

    2. Else

      1. Phantom#701

  2. Else

    1. Phantom#702

2. Else

  1. Phantom#737

3. If (typ'' = ((DefaultT) as typ)), then

  1. If $is_deftable(typ'''), then

    1. The relation holds

  1. Else

    1. Phantom#740

3. Else

  1. Phantom#741

4. If (typ'' = ((InvalidT) as typ)), then

  1. If (typ''' has type datatyp), then

    1. Let datatyp be (typ''' as datatyp)

    2. If (datatyp matches pattern `HeaderT%%`), then

      1. Let (HeaderT _id _(member, typ)*) be datatyp

      2. The relation holds

    2. Else If (datatyp matches pattern `UnionT%%`), then

      1. Let (UnionT _id _(member, typ)*) be datatyp

      2. The relation holds

    2. Else

      1. Phantom#742

  1. Else

    1. Phantom#743

4. Else

  1. Phantom#744

;; ../../../../spec/4b-typing-relation.watsup:75.1-77.23
relation Expr_ok: p', C, expr''

1. If (expr'' matches pattern `BoolE%`), then

  1. Let (BoolE b) be expr''

  2. Result in (ValueE (BoolV b) (( ((BoolT) as typ) ; (LCTK) )))

1. Else If (expr'' matches pattern `StrE%`), then

  1. Let (StrE t) be expr''

  2. Result in (ValueE (StrV t) (( ((StrT) as typ) ; (LCTK) )))

1. Else If (expr'' matches pattern `NumE%`), then

  1. Let (NumE num) be expr''

  2. If (num matches pattern `INT%`), then

    1. Let (INT i) be num

    2. Result in (ValueE (IntV i) (( ((IntT) as typ) ; (LCTK) )))

  2. Else If (num matches pattern `FINT%%`), then

    1. Let (FINT w i) be num

    2. Let bs be $to_bitstr((w as int), i)

    3. Result in (ValueE (FIntV w bs) (( ((FIntT w) as typ) ; (LCTK) )))

  2. Else If (num matches pattern `FBIT%%`), then

    1. Let (FBIT w i) be num

    2. Let bs be $to_bitstr((w as int), i)

    3. Result in (ValueE (FBitV w bs) (( ((FBitT w) as typ) ; (LCTK) )))

1. Else If (expr'' matches pattern `NameE%`), then

  1. Let (NameE name) be expr''

  2. Let styp? be $find_styp(p', C, name)

  3. If (styp? matches pattern (_)), then

    1. Let ?((typ _dir ctk _val?)) be styp?

    2. Result in (NameE name (( typ ; ctk )))

  3. Else

    1. Phantom#826

1. Else If (expr'' matches pattern `SeqE%`), then

  1. Let (SeqE expr''*) be expr''

  2. (Expr_ok: p' C |- expr'' : exprIL)*

  3. (Let (( typ ; ctk )) be $annot(exprIL))*

  4. Let ctk_e be $joins_ctk(ctk*)

  5. Result in (SeqE exprIL* (( ((SeqT typ*) as typ) ; ctk_e )))

1. Else If (expr'' matches pattern `SeqDefaultE%`), then

  1. Let (SeqDefaultE expr''*) be expr''

  2. (Expr_ok: p' C |- expr'' : exprIL)*

  3. (Let (( typ ; ctk )) be $annot(exprIL))*

  4. Let ctk_e be $joins_ctk(ctk*)

  5. Result in (SeqDefaultE exprIL* (( ((SeqDefaultT typ*) as typ) ; ctk_e )))

1. Else If (expr'' matches pattern `RecordE%`), then

  1. Let (RecordE (member, expr'')*) be expr''

  2. (Expr_ok: p' C |- expr'' : exprIL)*

  3. (Let (( typ ; ctk )) be $annot(exprIL))*

  4. Let ctk_e be $joins_ctk(ctk*)

  5. Result in (RecordE (member, exprIL)* (( ((RecordT (member, typ)*) as typ) ; ctk_e )))

1. Else If (expr'' matches pattern `RecordDefaultE%`), then

  1. Let (RecordDefaultE (member, expr'')*) be expr''

  2. (Expr_ok: p' C |- expr'' : exprIL)*

  3. (Let (( typ ; ctk )) be $annot(exprIL))*

  4. Let ctk_e be $joins_ctk(ctk*)

  5. Result in (RecordE (member, exprIL)* (( ((RecordDefaultT (member, typ)*) as typ) ; ctk_e )))

1. Else If (expr'' matches pattern `DefaultE`), then

  1. Result in (DefaultE (( ((DefaultT) as typ) ; (LCTK) )))

1. Else If (expr'' matches pattern `InvalidE`), then

  1. Result in (ValueE (InvalidV) (( ((InvalidT) as typ) ; (LCTK) )))

1. Else If (expr'' matches pattern `UnE%%`), then

  1. Let (UnE unop expr'') be expr''

  2. If (unop matches pattern `BNOT`), then

    1. Expr_ok: p' C |- expr'' : exprIL

    2. Let exprIL_e be $reduce_senum_unary(exprIL, $compatible_bnot)

    3. Let (( typ_e ; ctk_e )) be $annot(exprIL_e)

    4. Result in (UnE (BNOT) exprIL_e (( typ_e ; ctk_e )))

  2. Else If (unop matches pattern `LNOT`), then

    1. Expr_ok: p' C |- expr'' : exprIL

    2. Let exprIL_e be $reduce_senum_unary(exprIL, $compatible_lnot)

    3. Let (( typ_e ; ctk_e )) be $annot(exprIL_e)

    4. Result in (UnE (LNOT) exprIL_e (( typ_e ; ctk_e )))

  2. Else If (unop matches pattern `UPLUS`), then

    1. Expr_ok: p' C |- expr'' : exprIL

    2. Let exprIL_e be $reduce_senum_unary(exprIL, $compatible_uplus)

    3. Let (( typ_e ; ctk_e )) be $annot(exprIL_e)

    4. Result in (UnE (UPLUS) exprIL_e (( typ_e ; ctk_e )))

  2. Else If (unop matches pattern `UMINUS`), then

    1. Expr_ok: p' C |- expr'' : exprIL

    2. Let exprIL_e be $reduce_senum_unary(exprIL, $compatible_uminus)

    3. Let (( typ_e ; ctk_e )) be $annot(exprIL_e)

    4. Result in (UnE (UMINUS) exprIL_e (( typ_e ; ctk_e )))

1. Else If (expr'' matches pattern `BinE%%%`), then

  1. Let (BinE binop expr_l expr_r) be expr''

  2. If binop is in [(PLUS), (MINUS), (MUL)], then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r)

    4. Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_plusminusmult)

    5. Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l'')

    6. Let (( _typ ; ctk_r'' )) be $annot(exprIL_r'')

    7. Let ctk be $join_ctk(ctk_l'', ctk_r'')

    8. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

  2. Else

    1. Phantom#809

  3. If binop is in [(SPLUS), (SMINUS)], then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r)

    4. Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_satplusminus)

    5. Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l'')

    6. Let (( _typ ; ctk_r'' )) be $annot(exprIL_r'')

    7. Let ctk be $join_ctk(ctk_l'', ctk_r'')

    8. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

  3. Else

    1. Phantom#810

  4. If binop is in [(DIV), (MOD)], then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r)

    4. Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_divmod)

    5. Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l'')

    6. Let (( _typ ; ctk' )) be $annot(exprIL_r'')

    7. If (ctk' matches pattern `LCTK`), then

      1. Eval_static: p' C |- exprIL_r'' ~> val_r

      2. Let int be $get_num(val_r)

      3. If (int has type nat), then

        1. Let n_r be (int as nat)

        2. If (n_r > 0), then

          1. Let ctk be $join_ctk(ctk_l'', (LCTK))

          2. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

        2. Else

          1. Phantom#811

      3. Else

        1. Phantom#812

    7. Else

      1. Phantom#813

    8. Let (( _typ ; ctk_r'' )) be $annot(exprIL_r'')

    9. If ~(ctk_r'' matches pattern `LCTK`), then

      1. Let ctk be $join_ctk(ctk_l'', ctk_r'')

      2. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

    9. Else

      1. Phantom#814

  4. Else

    1. Phantom#815

  5. If binop is in [(SHL), (SHR)], then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $reduce_senums_binary(exprIL_l, exprIL_r, $compatible_shift)

    4. Let (( typ_l' ; ctk_l' )) be $annot(exprIL_l')

    5. Let (( typ_r' ; ctk_r' )) be $annot(exprIL_r')

    6. If (($is_fintt(typ_r') \/ $is_intt(typ_r')) => (ctk_r' = (LCTK))), then

      1. Let ctk be $join_ctk(ctk_l', ctk_r')

      2. Result in (BinE binop exprIL_l' exprIL_r' (( typ_l' ; ctk )))

    6. Else

      1. Phantom#816

  5. Else

    1. Phantom#817

  6. If binop is in [(EQ), (NE)], then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r)

    4. Let (( typ' ; ctk_l' )) be $annot(exprIL_l')

    5. Let (( _typ ; ctk_r' )) be $annot(exprIL_r')

    6. If $is_equalable(typ'), then

      1. Let ctk be $join_ctk(ctk_l', ctk_r')

      2. Result in (BinE binop exprIL_l' exprIL_r' (( ((BoolT) as typ) ; ctk )))

    6. Else

      1. Phantom#818

  6. Else

    1. Phantom#819

  7. If binop is in [(LE), (GE), (LT), (GT)], then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r)

    4. Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_compare)

    5. Let (( _typ ; ctk_l'' )) be $annot(exprIL_l'')

    6. Let (( _typ' ; ctk_r'' )) be $annot(exprIL_r'')

    7. Let ctk be $join_ctk(ctk_l'', ctk_r'')

    8. Result in (BinE binop exprIL_l'' exprIL_r'' (( ((BoolT) as typ) ; ctk )))

  7. Else

    1. Phantom#820

  8. If binop is in [(BAND), (BXOR), (BOR)], then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r)

    4. Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_bitwise)

    5. Let (( typ'' ; ctk_l'' )) be $annot(exprIL_l'')

    6. Let (( _typ ; ctk_r'' )) be $annot(exprIL_r'')

    7. Let ctk be $join_ctk(ctk_l'', ctk_r'')

    8. Result in (BinE binop exprIL_l'' exprIL_r'' (( typ'' ; ctk )))

  8. Else

    1. Phantom#821

  9. If (binop matches pattern `CONCAT`), then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $reduce_senums_binary(exprIL_l, exprIL_r, $compatible_concat)

    4. Let (( typ_l' ; ctk_l' )) be $annot(exprIL_l')

    5. Let (( typ_r' ; ctk_r' )) be $annot(exprIL_r')

    6. Let w be ($get_width(typ_l') + $get_width(typ_r'))

    7. If $is_fintt(typ_l'), then

      1. Let typ'' be ((FIntT w) as typ)

      2. Let ctk be $join_ctk(ctk_l', ctk_r')

      3. Result in (BinE (CONCAT) exprIL_l' exprIL_r' (( typ'' ; ctk )))

    7. Else

      1. Phantom#822

    8. If $is_fbitt(typ_l'), then

      1. Let typ'' be ((FBitT w) as typ)

      2. Let ctk be $join_ctk(ctk_l', ctk_r')

      3. Result in (BinE (CONCAT) exprIL_l' exprIL_r' (( typ'' ; ctk )))

    8. Else

      1. Phantom#823

  9. Else

    1. Phantom#824

  10. If binop is in [(LAND), (LOR)], then

    1. Expr_ok: p' C |- expr_l : exprIL_l

    2. Expr_ok: p' C |- expr_r : exprIL_r

    3. Let (exprIL_l', exprIL_r') be $coerce_binary(exprIL_l, exprIL_r)

    4. Let (exprIL_l'', exprIL_r'') be $reduce_senums_binary(exprIL_l', exprIL_r', $compatible_logical)

    5. Let (( _typ ; ctk_l'' )) be $annot(exprIL_l'')

    6. Let (( _typ' ; ctk_r'' )) be $annot(exprIL_r'')

    7. Let ctk be $join_ctk(ctk_l'', ctk_r'')

    8. Result in (BinE binop exprIL_l exprIL_r (( ((BoolT) as typ) ; ctk )))

  10. Else

    1. Phantom#825

1. Else If (expr'' matches pattern `TernE%%%`), then

  1. Let (TernE expr_c expr_t expr_f) be expr''

  2. Expr_ok: p' C |- expr_c : exprIL_c

  3. Let (( typ ; ctk_c )) be $annot(exprIL_c)

  4. If (typ = ((BoolT) as typ)), then

    1. Expr_ok: p' C |- expr_t : exprIL_t

    2. Expr_ok: p' C |- expr_f : exprIL_f

    3. Let (exprIL_t', exprIL_f') be $coerce_binary(exprIL_t, exprIL_f)

    4. Let (( typ' ; ctk_t )) be $annot(exprIL_t')

    5. Let (( _typ ; ctk_f )) be $annot(exprIL_f')

    6. If ($is_intt(typ') => ((ctk_c = (CTK)) \/ (ctk_c = (LCTK)))), then

      1. Let ctk be $joins_ctk([ctk_c, ctk_t, ctk_f])

      2. Result in (TernE exprIL_c exprIL_t' exprIL_f' (( typ' ; ctk )))

    6. Else

      1. Phantom#807

  4. Else

    1. Phantom#808

1. Else If (expr'' matches pattern `CastE%%`), then

  1. Let (CastE type expr_b) be expr''

  2. Type_ok: p' C |- type : typ tid*

  3. If (tid* matches pattern []), then

    1. If (Type_wf: $bound_tids(p', C) |- typ holds), then

      1. Expr_ok: p' C |- expr_b : exprIL_b

      2. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

      3. If (Sub_expl: typ_b <: typ holds), then

        1. Result in (CastE typ exprIL_b (( typ ; ctk_b )))

      3. Else

        1. Phantom#804

    1. Else

      1. Phantom#805

  3. Else

    1. Phantom#806

1. Else If (expr'' matches pattern `MaskE%%`), then

  1. Let (MaskE expr_b expr_m) be expr''

  2. Expr_ok: p' C |- expr_b : exprIL_b

  3. Expr_ok: p' C |- expr_m : exprIL_m

  4. Let (exprIL_b', exprIL_m') be $coerce_binary(exprIL_b, exprIL_m)

  5. Let (exprIL_b'', exprIL_m'') be $reduce_senums_binary(exprIL_b', exprIL_m', $compatible_mask)

  6. Let (( typ'' ; _ctk )) be $annot(exprIL_b'')

  7. Result in (MaskE exprIL_b'' exprIL_m'' (( ((SetT typ'') as typ) ; (DYN) )))

1. Else If (expr'' matches pattern `RangeE%%`), then

  1. Let (RangeE expr_lb expr_ub) be expr''

  2. Expr_ok: p' C |- expr_lb : exprIL_lb

  3. Expr_ok: p' C |- expr_ub : exprIL_ub

  4. Let (exprIL_ub', exprIL_lb') be $coerce_binary(exprIL_lb, exprIL_ub)

  5. Let (exprIL_lb'', exprIL_ub'') be $reduce_senums_binary(exprIL_lb', exprIL_ub', $compatible_range)

  6. Let (( typ'' ; _ctk )) be $annot(exprIL_lb'')

  7. Result in (RangeE exprIL_lb'' exprIL_ub'' (( ((SetT typ'') as typ) ; (DYN) )))

1. Else If (expr'' matches pattern `ArrAccE%%`), then

  1. Let (ArrAccE expr_b expr_i) be expr''

  2. Expr_ok: p' C |- expr_b : exprIL_b

  3. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

  4. Expr_ok: p' C |- expr_i : exprIL_i

  5. Let (( typ_i ; ctk )) be $annot(exprIL_i)

  6. If (ctk matches pattern `LCTK`), then

    1. Let exprIL_i' be $reduce_senum_unary(exprIL_i, $compatible_arrayindex)

    2. Let typ' be $canon_typ(typ_b)

    3. If (typ' has type datatyp), then

      1. Let datatyp be (typ' as datatyp)

      2. If (datatyp matches pattern `TupleT%`), then

        1. Let (TupleT typ_b'*) be datatyp

        2. Eval_static: p' C |- exprIL_i' ~> val_i

        3. Let int be $get_num(val_i)

        4. If (int has type nat), then

          1. Let n be (int as nat)

          2. Let typ be typ_b'*[n]

          3. Result in (ArrAccE exprIL_b exprIL_i' (( typ ; (DYN) )))

        4. Else

          1. Phantom#793

      2. Else

        1. Phantom#794

    3. Else

      1. Phantom#795

  6. Else

    1. Phantom#796

  7. Let (( typ_b ; _ctk )) be $annot(exprIL_b)

  8. If (ctk matches pattern `LCTK`), then

    1. Let exprIL_i' be $reduce_senum_unary(exprIL_i, $compatible_arrayindex)

    2. Let typ be $canon_typ(typ_b)

    3. If (typ has type datatyp), then

      1. Let datatyp be (typ as datatyp)

      2. If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ_b' i_s) be datatyp

        2. Eval_static: p' C |- exprIL_i' ~> val_i

        3. Let i be $get_num(val_i)

        4. If (((0 as int) <= i) /\ (i <= i_s)), then

          1. Result in (ArrAccE exprIL_b exprIL_i' (( typ_b' ; (DYN) )))

        4. Else

          1. Phantom#797

      2. Else

        1. Phantom#798

    3. Else

      1. Phantom#799

  8. Else

    1. Phantom#800

  9. Let (( typ_i ; ctk_i )) be $annot(exprIL_i)

  10. If ~(ctk_i matches pattern `LCTK`), then

    1. Let exprIL_i' be $reduce_senum_unary(exprIL_i, $compatible_arrayindex)

    2. Let typ be $canon_typ(typ_b)

    3. If (typ has type datatyp), then

      1. Let datatyp be (typ as datatyp)

      2. If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ_b' _int) be datatyp

        2. Result in (ArrAccE exprIL_b exprIL_i' (( typ_b' ; (DYN) )))

      2. Else

        1. Phantom#801

    3. Else

      1. Phantom#802

  10. Else

    1. Phantom#803

1. Else If (expr'' matches pattern `BitAccE%%%`), then

  1. Let (BitAccE expr_b expr_l expr_h) be expr''

  2. Expr_ok: p' C |- expr_b : exprIL_b

  3. Let exprIL_b' be $reduce_senum_unary(exprIL_b, $compatible_bitstringbase)

  4. Let (( typ_b' ; ctk_b' )) be $annot(exprIL_b')

  5. Expr_ok: p' C |- expr_l : exprIL_l

  6. Let (( typ_l ; ctk )) be $annot(exprIL_l)

  7. If (ctk matches pattern `LCTK`), then

    1. Let exprIL_l' be $reduce_senum_unary(exprIL_l, $compatible_bitstringindex)

    2. Eval_static: p' C |- exprIL_l' ~> val_l

    3. Let int be $get_num(val_l)

    4. If (int has type nat), then

      1. Let n_l be (int as nat)

      2. Let exprIL_l'' be (ValueE val_l (( typ_l ; (LCTK) )))

      3. Expr_ok: p' C |- expr_h : exprIL_h

      4. Let (( typ_h ; ctk' )) be $annot(exprIL_h)

      5. If (ctk' matches pattern `LCTK`), then

        1. Let exprIL_h' be $reduce_senum_unary(exprIL_h, $compatible_bitstringindex)

        2. Eval_static: p' C |- exprIL_h' ~> val_h

        3. Let int' be $get_num(val_h)

        4. If (int' has type nat), then

          1. Let n_h be (int' as nat)

          2. Let exprIL_h'' be (ValueE val_h (( typ_h ; (LCTK) )))

          3. If $is_valid_bitstring_slice(typ_b', n_l, n_h), then

            1. Let typ be ((FBitT ((n_h - n_l) + 1)) as typ)

            2. Result in (BitAccE exprIL_b' exprIL_l'' exprIL_h'' (( typ ; ctk_b' )))

          3. Else

            1. Phantom#788

        4. Else

          1. Phantom#789

      5. Else

        1. Phantom#790

    4. Else

      1. Phantom#791

  7. Else

    1. Phantom#792

1. Else If (expr'' matches pattern `ErrAccE%`), then

  1. Let (ErrAccE member) be expr''

  2. Let id be $concat_text(["error.", member])

  3. If (?((ErrV member)) = $find_val(p', C, (TOP id))), then

    1. Result in (ValueE (ErrV member) (( ((ErrT) as typ) ; (LCTK) )))

  3. Else

    1. Phantom#787

1. Else If (expr'' matches pattern `TypeAccE%%`), then

  1. Let (TypeAccE name member) be expr''

  2. Let typdef? be $find_typdef(p', C, name)

  3. If (typdef? matches pattern (_)), then

    1. Let ?(typdef) be typdef?

    2. If (typdef has type monotypdef), then

      1. Let (MonoD typ) be (typdef as monotypdef)

      2. Let typ' be $canon_typ(typ)

      3. If (typ' has type datatyp), then

        1. Let datatyp be (typ' as datatyp)

        2. If (datatyp matches pattern `EnumT%%`), then

          1. Let (EnumT id_t member_t*) be datatyp

          2. If member is in member_t*, then

            1. Result in (ValueE (EnumFieldV id_t member) (( typ ; (LCTK) )))

          2. Else

            1. Phantom#783

        2. Else If (datatyp matches pattern `SEnumT%%%`), then

          1. Let (SEnumT id_t typ_t (member_t, val_t)*) be datatyp

          2. Let val? be $assoc_<member, val>(member, (member_t, val_t)*)

          3. If (val? matches pattern (_)), then

            1. Let ?(val) be val?

            2. Result in (ValueE (SEnumFieldV id_t member val) (( typ ; (LCTK) )))

          3. Else

            1. Phantom#781

        2. Else

          1. Phantom#782

      3. Else

        1. Phantom#784

    2. Else

      1. Phantom#785

  3. Else

    1. Phantom#786

1. Else If (expr'' matches pattern `ExprAccE%%`), then

  1. Let (ExprAccE expr_b text) be expr''

  2. If (text = "size"), then

    1. Expr_ok: p' C |- expr_b : exprIL_b

    2. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

    3. Let typ be $canon_typ(typ_b)

    4. If (typ has type datatyp), then

      1. Let datatyp be (typ as datatyp)

      2. If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ_s int_s) be datatyp

        2. Result in (ExprAccE exprIL_b "size" (( ((FBitT 32) as typ) ; (LCTK) )))

      2. Else

        1. Phantom#772

    4. Else

      1. Phantom#773

  2. Else If (text = "lastIndex"), then

    1. If (((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE)))), then

      1. Expr_ok: p' C |- expr_b : exprIL_b

      2. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

      3. Let typ be $canon_typ(typ_b)

      4. If (typ has type datatyp), then

        1. Let datatyp be (typ as datatyp)

        2. If (datatyp matches pattern `StackT%%`), then

          1. Let (StackT typ_s int_s) be datatyp

          2. Result in (ExprAccE exprIL_b "lastIndex" (( ((FBitT 32) as typ) ; (DYN) )))

        2. Else

          1. Phantom#769

      4. Else

        1. Phantom#770

    1. Else

      1. Phantom#771

  2. Else If (text = "last"), then

    1. If (((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE)))), then

      1. Expr_ok: p' C |- expr_b : exprIL_b

      2. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

      3. Let typ be $canon_typ(typ_b)

      4. If (typ has type datatyp), then

        1. Let datatyp be (typ as datatyp)

        2. If (datatyp matches pattern `StackT%%`), then

          1. Let (StackT typ_s int_s) be datatyp

          2. Result in (ExprAccE exprIL_b "last" (( typ_s ; (DYN) )))

        2. Else

          1. Phantom#766

      4. Else

        1. Phantom#767

    1. Else

      1. Phantom#768

  2. Else If (text = "next"), then

    1. Expr_ok: p' C |- expr_b : exprIL_b

    2. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

    3. Let typ be $canon_typ(typ_b)

    4. If (typ has type datatyp), then

      1. Let datatyp be (typ as datatyp)

      2. If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ_s int_s) be datatyp

        2. Result in (ExprAccE exprIL_b "next" (( typ_s ; (DYN) )))

      2. Else

        1. Phantom#763

    4. Else

      1. Phantom#764

  2. Else

    1. Phantom#765

  3. Let (ExprAccE expr_b member) be expr''

  4. Expr_ok: p' C |- expr_b : exprIL_b

  5. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

  6. Let typ' be $canon_typ(typ_b)

  7. If (typ' has type datatyp), then

    1. Let datatyp be (typ' as datatyp)

    2. If (datatyp matches pattern `StructT%%`), then

      1. Let (StructT id_s (member_s, typ_s)*) be datatyp

      2. Let typ? be $assoc_<member, typ>(member, (member_s, typ_s)*)

      3. If (typ? matches pattern (_)), then

        1. Let ?(typ) be typ?

        2. Result in (ExprAccE exprIL_b member (( typ ; (DYN) )))

      3. Else

        1. Phantom#780

    2. Else If (datatyp matches pattern `HeaderT%%`), then

      1. Let (HeaderT id_h (member_h, typ_h)*) be datatyp

      2. Let typ? be $assoc_<member, typ>(member, (member_h, typ_h)*)

      3. If (typ? matches pattern (_)), then

        1. Let ?(typ) be typ?

        2. Result in (ExprAccE exprIL_b member (( typ ; (DYN) )))

      3. Else

        1. Phantom#779

    2. Else If (datatyp matches pattern `UnionT%%`), then

      1. Let (UnionT id_u (member_u, typ_u)*) be datatyp

      2. Let typ? be $assoc_<member, typ>(member, (member_u, typ_u)*)

      3. If (typ? matches pattern (_)), then

        1. Let ?(typ) be typ?

        2. Result in (ExprAccE exprIL_b member (( typ ; (DYN) )))

      3. Else

        1. Phantom#777

    2. Else

      1. Phantom#778

  7. Else If (typ' has type synthtyp), then

    1. Let synthtyp be (typ' as synthtyp)

    2. If (synthtyp matches pattern `TableStructT%%`), then

      1. Let (TableStructT id_t (member_t, typ_t)*) be synthtyp

      2. Let typ? be $assoc_<member, typ>(member, (member_t, typ_t)*)

      3. If (typ? matches pattern (_)), then

        1. Let ?(typ) be typ?

        2. Result in (ExprAccE exprIL_b member (( typ ; (DYN) )))

      3. Else

        1. Phantom#774

    2. Else

      1. Phantom#775

  7. Else

    1. Phantom#776

1. Else If (expr'' matches pattern `CallFuncE%%%`), then

  1. Let (CallFuncE name targ* arg*) be expr''

  2. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

  3. Let tid_fresh* be $concat_<tid>(tid_fresh_a**)

  4. FuncType_ok: p' C |- name targIL* arg* : ft tid_fresh_inserted* id_deft*

  5. Let tid_fresh'* be $concat_<tid>(tid_fresh* :: [tid_fresh_inserted*])

  6. Call_ok: p' C tid_fresh'* |- ft targIL* arg* id_deft* : typ targIL'* argIL'*

  7. If (typ =/= ((VoidT) as typ)), then

    1. Result in (CallFuncE name targIL'* argIL'* (( typ ; (DYN) )))

  7. Else

    1. Phantom#762

1. Else If (expr'' matches pattern `CallMethodE%%%%`), then

  1. Let (CallMethodE expr_b member targ* arg*) be expr''

  2. If (targ* matches pattern []), then

    1. If (arg* matches pattern []), then

      1. If member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"], then

        1. MethodType_ok: p' C |- expr_b member [] [] : ft exprIL_b tid_fresh_inserted* id_deft*

        2. Call_ok: p' C [] |- ft [] [] [] : typ targIL* argIL*

        3. If (typ = ((IntT) as typ)), then

          1. If (targIL* matches pattern []), then

            1. If (argIL* matches pattern []), then

              1. Result in (CallMethodE exprIL_b member [] [] (( ((IntT) as typ) ; (LCTK) )))

            1. Else

              1. Phantom#754

          1. Else

            1. Phantom#755

        3. Else

          1. Phantom#756

      1. Else

        1. Phantom#757

    1. Else

      1. Phantom#758

  2. Else

    1. Phantom#759

  3. Let (CallMethodE expr_b member targ* arg*) be expr''

  4. If ~member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"], then

    1. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

    2. Let tid_fresh* be $concat_<tid>(tid_fresh_a**)

    3. MethodType_ok: p' C |- expr_b member targIL* arg* : ft exprIL_b tid_fresh_inserted* id_deft*

    4. Let tid_fresh'* be $concat_<tid>([tid_fresh* ++ tid_fresh_inserted*])

    5. Call_ok: p' C tid_fresh'* |- ft targIL* arg* id_deft* : typ targIL'* argIL'*

    6. If (typ =/= ((VoidT) as typ)), then

      1. Result in (CallMethodE exprIL_b member targIL'* argIL'* (( typ ; (DYN) )))

    6. Else

      1. Phantom#760

  4. Else

    1. Phantom#761

1. Else If (expr'' matches pattern `CallTypeE%%%%`), then

  1. Let (CallTypeE name member targ* arg*) be expr''

  2. If (targ* matches pattern []), then

    1. If (arg* matches pattern []), then

      1. Let typdef? be $find_typdef(p', C, name)

      2. If (typdef? matches pattern (_)), then

        1. Let ?(typdef) be typdef?

        2. If member is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"], then

          1. Let ft be (BuiltinMethodT [] ((IntT) as typ))

          2. Call_ok: p' C [] |- ft [] [] [] : typ targIL* argIL*

          3. If (typ = ((IntT) as typ)), then

            1. If (targIL* matches pattern []), then

              1. If (argIL* matches pattern []), then

                1. Result in (CallTypeE name member [] [] (( ((IntT) as typ) ; (LCTK) )))

              1. Else

                1. Phantom#747

            1. Else

              1. Phantom#748

          3. Else

            1. Phantom#749

        2. Else

          1. Phantom#750

      2. Else

        1. Phantom#751

    1. Else

      1. Phantom#752

  2. Else

    1. Phantom#753

1. Else If (expr'' matches pattern `InstE%%%`), then

  1. Let (InstE name targ* arg*) be expr''

  2. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

  3. Let tid_fresh* be $concat_<tid>(tid_fresh_a**)

  4. ConsType_ok: p' C |- name targIL* arg* : ct tid_fresh_inserted* id_deft*

  5. Let tid_fresh'* be $concat_<tid>([tid_fresh* ++ tid_fresh_inserted*])

  6. Inst_ok: p' C tid_fresh'* |- ct targIL* arg* id_deft* : typ targIL'* argIL'*

  7. If $not_abstract_extern_object(typ), then

    1. Result in (InstE name targIL'* argIL'* (( typ ; (CTK) )))

  7. Else

    1. Phantom#745

1. Else

  1. Phantom#746

2. If (p' matches pattern `LOCAL`), then

  1. If (expr'' matches pattern `SelectE%%`), then

    1. Let (SelectE expr_k* selectcase*) be expr''

    2. If (C.LOCAL.KIND matches pattern `PARSERSTATE`), then

      1. (Expr_ok: (LOCAL) C |- expr_k : exprIL_k)*

      2. (Let (( typ_k ; ctk_k )) be $annot(exprIL_k))*

      3. If ((Type_wf: $bound_tids((LOCAL), C) |- ((SetT typ_k) as typ) holds))*, then

        1. (Select_case_ok: (LOCAL) C typ_k* |- selectcase : selectcaseIL)*

        2. Result in (SelectE exprIL_k* selectcaseIL* (( ((StateT) as typ) ; (DYN) )))

      3. Else

        1. Phantom#827

    2. Else

      1. Phantom#828

  1. Else

    1. Phantom#829

2. Else

  1. Phantom#830

;; ../../../../spec/4b-typing-relation.watsup:81.1-83.23
relation Arg_ok: p, C, arg

1. If (arg matches pattern `ExprA%`), then

  1. Let (ExprA expr) be arg

  2. Expr_ok: p C |- expr : exprIL

  3. Let (( typ ; _ctk )) be $annot(exprIL)

  4. Result in (ExprA exprIL), typ

1. Else If (arg matches pattern `NameA%%`), then

  1. Let (NameA id expr?) be arg

  2. If (expr? matches pattern (_)), then

    1. Let ?(expr) be expr?

    2. Expr_ok: p C |- expr : exprIL

    3. Let (( typ ; _ctk )) be $annot(exprIL)

    4. Result in (NameA id ?(exprIL)), typ

  2. Else If (expr? matches pattern ()), then

    1. Result in (NameA id ?()), ((AnyT) as typ)

1. Else If (arg matches pattern `AnyA`), then

  1. Result in (AnyA), ((AnyT) as typ)

;; ../../../../spec/4b-typing-relation.watsup:86.1-88.23
relation Lval_ok: p, C, exprIL

1. If (exprIL matches pattern `NameE%%`), then

  1. Let (NameE name _annotIL) be exprIL

  2. Let styp? be $find_styp(p, C, name)

  3. If (styp? matches pattern (_)), then

    1. Let ?((typ dir _ctk _val?)) be styp?

    2. If ((dir = (OUT)) \/ (dir = (INOUT))), then

      1. If $is_assignable(typ), then

        1. The relation holds

      1. Else

        1. Phantom#835

    2. Else

      1. Phantom#836

  3. Else

    1. Phantom#837

1. Else If (exprIL matches pattern `ArrAccE%%%`), then

  1. Let (ArrAccE exprIL_b exprIL_i _annotIL) be exprIL

  2. If (Lval_ok: p C |- exprIL_b holds), then

    1. The relation holds

  2. Else

    1. Phantom#834

1. Else If (exprIL matches pattern `BitAccE%%%%`), then

  1. Let (BitAccE exprIL_b exprIL_l exprIL_h _annotIL) be exprIL

  2. If (Lval_ok: p C |- exprIL_b holds), then

    1. The relation holds

  2. Else

    1. Phantom#833

1. Else If (exprIL matches pattern `ExprAccE%%%`), then

  1. Let (ExprAccE exprIL_b member _annotIL) be exprIL

  2. If (Lval_ok: p C |- exprIL_b holds), then

    1. The relation holds

  2. Else

    1. Phantom#831

1. Else

  1. Phantom#832

;; ../../../../spec/4b-typing-relation.watsup:93.18-93.31
syntax blkctxt = 
   | `INIT`()
   | `NOINIT`()

;; ../../../../spec/4b-typing-relation.watsup:94.1-96.29
relation Block_ok: cursor, C, f, blkctxt, (BlockB stmt*)

1. If (cursor matches pattern `LOCAL`), then

  1. If (blkctxt matches pattern `INIT`), then

    1. Stmts_ok: (LOCAL) C f |- stmt* : C' f' stmtIL*

    2. Result in C', f', (BlockB stmtIL*)

  1. Else If (blkctxt matches pattern `NOINIT`), then

    1. Let C' be $enter(C)

    2. Stmts_ok: (LOCAL) C' f |- stmt* : C'' f' stmtIL*

    3. Let C''' be $exit(C'')

    4. Result in C''', f', (BlockB stmtIL*)

1. Else

  1. Phantom#838

;; ../../../../spec/4b-typing-relation.watsup:97.1-99.26
relation Stmt_ok: p', C, f, stmt

1. If (stmt matches pattern `EmptyS`), then

  1. Result in C, f, (EmptyS)

1. Else If (stmt matches pattern `AssignS%%`), then

  1. Let (AssignS expr_l expr_r) be stmt

  2. Expr_ok: p' C |- expr_l : exprIL_l

  3. Let (( typ_l ; ctk )) be $annot(exprIL_l)

  4. If (ctk matches pattern `DYN`), then

    1. If (Lval_ok: p' C |- exprIL_l holds), then

      1. Expr_ok: p' C |- expr_r : exprIL_r

      2. Let (( typ_r ; _ctk )) be $annot(exprIL_r)

      3. Let exprIL_r' be $coerce_assign(exprIL_r, typ_l)

      4. Result in C, f, (AssignS exprIL_l exprIL_r')

    1. Else

      1. Phantom#853

  4. Else

    1. Phantom#854

1. Else If (stmt matches pattern `IfS%%%`), then

  1. Let (IfS expr_c stmt_t stmt_f) be stmt

  2. Expr_ok: p' C |- expr_c : exprIL_c

  3. Let (( typ ; _ctk )) be $annot(exprIL_c)

  4. If (typ = ((BoolT) as typ)), then

    1. Stmt_ok: p' C f |- stmt_t : C_t f_t stmtIL_t

    2. Stmt_ok: p' C f |- stmt_f : C_f f_f stmtIL_f

    3. Let f' be $join_flow(f_t, f_f)

    4. Result in C, f', (IfS exprIL_c stmtIL_t stmtIL_f)

  4. Else

    1. Phantom#852

1. Else If (stmt matches pattern `ExitS`), then

  1. Result in C, f, (ExitS)

1. Else If (stmt matches pattern `CallFuncS%%%`), then

  1. Let (CallFuncS name targ* arg*) be stmt

  2. If ((name = (CURRENT "verify")) => (((p' = (BLOCK)) /\ (C.BLOCK.KIND = (PARSER))) \/ ((p' = (LOCAL)) /\ (C.LOCAL.KIND = (PARSERSTATE))))), then

    1. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

    2. Let tid_fresh* be $concat_<tid>(tid_fresh_a**)

    3. FuncType_ok: p' C |- name targIL* arg* : ft tid_fresh_inserted* id_deft*

    4. Let tid_fresh'* be $concat_<tid>([tid_fresh* ++ tid_fresh_inserted*])

    5. Call_ok: p' C tid_fresh'* |- ft targIL* arg* id_deft* : typ targIL'* argIL'*

    6. Result in C, f, (CallFuncS name targIL'* argIL'*)

  2. Else

    1. Phantom#851

1. Else If (stmt matches pattern `CallMethodS%%%%`), then

  1. Let (CallMethodS expr_b member targ* arg*) be stmt

  2. (Arg_ok: p' C |- arg : argIL typ_arg)*

  3. (Type_ok: p' C |- targ : targIL tid_fresh_a*)*

  4. Let tid_fresh* be $concat_<tid>(tid_fresh_a**)

  5. MethodType_ok: p' C |- expr_b member targIL* arg* : ft exprIL_b tid_fresh_inserted* id_deft*

  6. Let tid_fresh'* be $concat_<tid>([tid_fresh* ++ tid_fresh_inserted*])

  7. Call_ok: p' C tid_fresh'* |- ft targIL* arg* id_deft* : typ targIL'* argIL'*

  8. Result in C, f, (CallMethodS exprIL_b member targIL'* argIL'*)

1. Else If (stmt matches pattern `CallInstS%%%`), then

  1. Let (CallInstS name targ* arg*) be stmt

  2. ConsType_ok: p' C |- name [] [] : ct tid* id*

  3. If (tid* matches pattern []), then

    1. If (id* matches pattern []), then

      1. Inst_ok: p' C [] |- ct [] [] [] : typ targIL* argIL*

      2. If (targIL* matches pattern []), then

        1. If (argIL* matches pattern []), then

          1. Let typ' be $canon_typ(typ)

          2. If ($is_parsert(typ') \/ $is_controlt(typ')), then

            1. Let id be $id_of_name(name)

            2. Let C' be $add_styp(p', C, id, (typ (NO) (CTK) ?()))

            3. Stmt_ok: p' C' f |- (CallMethodS (NameE (CURRENT id)) "apply" targ* arg*) : context f' stmtIL

            4. If (context = C'), then

              1. Let stmtIL' be stmtIL

              2. If (stmtIL' matches pattern `CallMethodS%%%%`), then

                1. Let (CallMethodS exprIL text targIL'* argIL'*) be stmtIL'

                2. If (exprIL matches pattern `NameE%%`), then

                  1. Let (NameE name' _annotIL) be exprIL

                  2. If (name' = (CURRENT id)), then

                    1. If (text = "apply"), then

                      1. Result in C, f, (CallInstS typ name targIL'* argIL'*)

                    1. Else

                      1. Phantom#841

                  2. Else

                    1. Phantom#842

                2. Else

                  1. Phantom#843

              2. Else

                1. Phantom#844

            4. Else

              1. Phantom#845

          2. Else

            1. Phantom#846

        1. Else

          1. Phantom#847

      2. Else

        1. Phantom#848

    1. Else

      1. Phantom#849

  3. Else

    1. Phantom#850

1. Else If (stmt matches pattern `TransS%`), then

  1. Let (TransS expr) be stmt

  2. Expr_ok: p' C |- expr : exprIL

  3. Let (( typ ; _ctk )) be $annot(exprIL)

  4. If (typ = ((StateT) as typ)), then

    1. Result in C, f, (TransS exprIL)

  4. Else

    1. Phantom#840

1. Else If (stmt matches pattern `DeclS%`), then

  1. Let (DeclS decl) be stmt

  2. Decl_ok: p' C |- decl : C' declIL

  3. Result in C', f, (DeclS declIL)

1. Else

  1. Phantom#839

2. If (p' matches pattern `LOCAL`), then

  1. If (stmt matches pattern `SwitchS%%`), then

    1. Let (SwitchS expr switchcase*) be stmt

    2. If (C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`), then

      1. Expr_ok: (LOCAL) C |- expr : exprIL

      2. Let (( typ ; _ctk )) be $annot(exprIL)

      3. If (typ has type synthtyp), then

        1. Let synthtyp be (typ as synthtyp)

        2. If (synthtyp matches pattern `TableEnumT%%`), then

          1. Let (TableEnumT id _member*) be synthtyp

          2. Let id_t be $strip_prefix($strip_suffix(id, ")"), "action_list(")

          3. Switch_tbl_cases_ok: (LOCAL) C f id_t |- switchcase* : f' switchcaseIL* switchlabel*

          4. If $distinct_<switchlabel>(switchlabel*), then

            1. Result in C, f', (SwitchS exprIL switchcaseIL*)

          4. Else

            1. Phantom#857

        2. Else

          1. Phantom#858

      3. Else

        1. Phantom#859

      4. Let typ' be $canon_typ(typ)

      5. If (((($is_errt(typ') \/ $is_fintt(typ')) \/ $is_fbitt(typ')) \/ $is_enumt(typ')) \/ $is_senumt(typ')), then

        1. Switch_gen_cases_ok: (LOCAL) C f typ |- switchcase* : f' switchcaseIL* switchlabel*

        2. If $distinct_<switchlabel>(switchlabel*), then

          1. Result in C, f', (SwitchS exprIL switchcaseIL*)

        2. Else

          1. Phantom#860

      5. Else

        1. Phantom#861

    2. Else

      1. Phantom#862

  1. Else If (stmt matches pattern `BlockS%`), then

    1. Let (BlockS block) be stmt

    2. Block_ok: (LOCAL) C f (NOINIT) |- block : C' f' blockIL

    3. Result in C', f', (BlockS blockIL)

  1. Else If (stmt matches pattern `RetS%`), then

    1. Let (RetS expr?) be stmt

    2. If (expr? matches pattern (_)), then

      1. Let ?(expr) be expr?

      2. Expr_ok: (LOCAL) C |- expr : exprIL

      3. Let typ_r be $get_typ_ret_lkind(C.LOCAL.KIND)

      4. Let exprIL' be $coerce_assign(exprIL, typ_r)

      5. Result in C, (RET), (RetS ?(exprIL'))

    2. Else

      1. Phantom#855

  1. Else

    1. Phantom#856

  2. If (stmt = (RetS ?())), then

    1. If (((VoidT) as typ) = $get_typ_ret_lkind(C.LOCAL.KIND)), then

      1. Result in C, (RET), (RetS ?())

    1. Else

      1. Phantom#863

  2. Else

    1. Phantom#864

2. Else

  1. Phantom#865

;; ../../../../spec/4b-typing-relation.watsup:100.1-102.26
relation Stmts_ok: p, C, f, stmt*

1. If (stmt* matches pattern []), then

  1. Result in C, f, []

1. Else If (stmt* matches pattern _ :: _), then

  1. Let stmt_h :: stmt_t* be stmt*

  2. Stmt_ok: p C f |- stmt_h : C' f' stmtIL_h

  3. Stmts_ok: p C' f' |- stmt_t* : C'' f'' stmtIL_t*

  4. Result in C'', f'', stmtIL_h :: stmtIL_t*

;; ../../../../spec/4b-typing-relation.watsup:107.1-109.23
relation Param_ok: p, C, (id dir type expr?)

1. If (expr? matches pattern (_)), then

  1. Let ?(expr) be expr?

  2. Type_ok: p C |- type : typ_p tid_fresh*

  3. Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh* }))

  4. If (Type_wf: tidset |- typ_p holds), then

    1. Expr_ok: p C |- expr : exprIL_e

    2. Let (( typ_e ; ctk )) be $annot(exprIL_e)

    3. If (ctk matches pattern `LCTK`), then

      1. If (Sub_impl: typ_e << typ_p holds), then

        1. Eval_static: p C |- exprIL_e ~> val

        2. Result in (id dir typ_p ?(val)), tid_fresh*

      1. Else

        1. Phantom#867

    3. Else

      1. Phantom#868

  4. Else

    1. Phantom#869

1. Else If (expr? matches pattern ()), then

  1. Type_ok: p C |- type : typ_p tid_fresh*

  2. Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh* }))

  3. If (Type_wf: tidset |- typ_p holds), then

    1. Result in (id dir typ_p ?()), tid_fresh*

  3. Else

    1. Phantom#866

;; ../../../../spec/4b-typing-relation.watsup:110.1-112.23
relation CParam_ok: p, C, (id dir type expr?)

1. If (expr? matches pattern (_)), then

  1. Let ?(expr) be expr?

  2. Type_ok: p C |- type : typ_p tid_fresh*

  3. Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh* }))

  4. If (Type_wf: tidset |- typ_p holds), then

    1. Expr_ok: p C |- expr : exprIL_e

    2. Let (( typ_e ; ctk )) be $annot(exprIL_e)

    3. If (ctk matches pattern `LCTK`), then

      1. If (Sub_impl: typ_e << typ_p holds), then

        1. Eval_static: p C |- exprIL_e ~> val

        2. Result in (id dir typ_p ?(val)), tid_fresh*

      1. Else

        1. Phantom#871

    3. Else

      1. Phantom#872

  4. Else

    1. Phantom#873

1. Else If (expr? matches pattern ()), then

  1. Type_ok: p C |- type : typ_p tid_fresh*

  2. Let tidset be $union_set<tid>($bound_tids(p, C), ({ tid_fresh* }))

  3. If (Type_wf: tidset |- typ_p holds), then

    1. Result in (id dir typ_p ?()), tid_fresh*

  3. Else

    1. Phantom#870

;; ../../../../spec/4b-typing-relation.watsup:116.1-118.23
relation Decl_ok: p', C'''', decl''

1. If (decl'' matches pattern `ConstD%%%`), then

  1. Let (ConstD id type expr) be decl''

  2. Type_ok: p' C'''' |- type : typ_c tid*

  3. If (tid* matches pattern []), then

    1. If (Type_wf: $bound_tids(p', C'''') |- typ_c holds), then

      1. Expr_ok: p' C'''' |- expr : exprIL

      2. Let (( _typ ; ctk )) be $annot(exprIL)

      3. If (ctk matches pattern `LCTK`), then

        1. Let exprIL' be $coerce_assign(exprIL, typ_c)

        2. Eval_static: p' C'''' |- exprIL' ~> val

        3. Let C' be $add_styp(p', C'''', id, (typ_c (NO) (LCTK) ?(val)))

        4. Result in C', (ConstD id typ_c val)

      3. Else

        1. Phantom#896

    1. Else

      1. Phantom#897

  3. Else

    1. Phantom#898

1. Else If (decl'' matches pattern `VarD%%%`), then

  1. Let (VarD id type expr?) be decl''

  2. If (expr? matches pattern ()), then

    1. Type_ok: p' C'''' |- type : typ tid*

    2. If (tid* matches pattern []), then

      1. If (Type_wf: $bound_tids(p', C'''') |- typ holds), then

        1. If $is_assignable(typ), then

          1. Let C' be $add_styp(p', C'''', id, (typ (INOUT) (DYN) ?()))

          2. Result in C', (VarD id typ ?())

        1. Else

          1. Phantom#893

      1. Else

        1. Phantom#894

    2. Else

      1. Phantom#895

  2. Else If (expr? matches pattern (_)), then

    1. Let ?(expr) be expr?

    2. Type_ok: p' C'''' |- type : typ tid*

    3. If (tid* matches pattern []), then

      1. If (Type_wf: $bound_tids(p', C'''') |- typ holds), then

        1. If $is_assignable(typ), then

          1. Expr_ok: p' C'''' |- expr : exprIL

          2. Let exprIL' be $coerce_assign(exprIL, typ)

          3. Let C' be $add_styp(p', C'''', id, (typ (INOUT) (DYN) ?()))

          4. Result in C', (VarD id typ ?(exprIL'))

        1. Else

          1. Phantom#890

      1. Else

        1. Phantom#891

    3. Else

      1. Phantom#892

1. Else If (decl'' matches pattern `InstD%%%%%`), then

  1. Let (InstD id name_inst targ* arg* decl''*) be decl''

  2. If (|decl''*| > 0), then

    1. (Type_ok: p' C'''' |- targ : targIL tid_fresh_a*)*

    2. Let tid_fresh* be $concat_<tid>(tid_fresh_a**)

    3. ConsType_ok: p' C'''' |- name_inst targIL* arg* : ct tid_fresh_inserted* id_deft*

    4. Inst_ok: p' C'''' tid_fresh* ++ tid_fresh_inserted* |- ct targIL* arg* id_deft* : typ targIL'* argIL'*

    5. Let typ''' be typ

    6. If (typ''' has type abstyp), then

      1. Let abstyp be (typ''' as abstyp)

      2. If (abstyp matches pattern `SpecT%%`), then

        1. Let (SpecT (PolyD (tparam*, tparam_hidden*) -> typ'') typ_a*) be abstyp

        2. If (typ'' has type objtyp), then

          1. Let objtyp be (typ'' as objtyp)

          2. If (objtyp matches pattern `ExternT%%`), then

            1. Let (ExternT id_ext fdenv_ext) be objtyp

            2. Let C' be $add_styp((LOCAL), C'''', "this", (typ (NO) (CTK) ?()))

            3. Inst_init_decls_ok: C' $empty_frame $empty_fdenv |- decl''* : frame_abs fdenv_abs declIL*

            4. Let ({ (fid_abs -> fd_abs)* }) be fdenv_abs

            5. Let tparam'* be tparam* ++ tparam_hidden*

            6. Let theta be ({ (tparam' -> typ_a)* })

            7. Let fdenv_ext' be $update_fdenv_extern(fdenv_ext, theta, fid_abs*, fd_abs*)

            8. Let ({ (fid_ext -> fd_ext)* }) be fdenv_ext'

            9. Let funcdef* be fd_ext*

            10. If ((funcdef has type polyfuncdef))*, then

              1. (Let (PolyFD _(tparam*, tparam*) -> ft) be (funcdef as polyfuncdef))*

              2. If (~$is_externabstractmethodt(ft))*, then

                1. Let typ' be ((SpecT (PolyD (tparam*, tparam_hidden*) -> ((ExternT id_ext fdenv_ext') as typ)) typ_a*) as typ)

                2. Let C'' be $add_styp(p', C'''', id, (typ' (NO) (CTK) ?()))

                3. Result in C'', (InstD id typ name_inst targIL'* argIL'* declIL*)

              2. Else

                1. Phantom#882

            10. Else

              1. Phantom#883

          2. Else

            1. Phantom#884

        2. Else

          1. Phantom#885

      2. Else

        1. Phantom#886

    6. Else

      1. Phantom#887

  2. Else

    1. Phantom#888

  3. Let (InstD id name_inst targ* arg* decl*) be decl''

  4. If (decl* matches pattern []), then

    1. (Type_ok: p' C'''' |- targ : targIL tid_fresh_a*)*

    2. Let tid_fresh* be $concat_<tid>(tid_fresh_a**)

    3. ConsType_ok: p' C'''' |- name_inst targIL* arg* : ct tid_fresh_inserted* id_deft*

    4. Inst_ok: p' C'''' tid_fresh* ++ tid_fresh_inserted* |- ct targIL* arg* id_deft* : typ targIL'* argIL'*

    5. Let C' be $add_styp(p', C'''', id, (typ (NO) (CTK) ?()))

    6. Result in C', (InstD id typ name_inst targIL'* argIL'* [])

  4. Else

    1. Phantom#889

1. Else If (decl'' matches pattern `ActionD%%%`), then

  1. Let (ActionD id param* block) be decl''

  2. If ((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (CONTROL)))), then

    1. Let fid be $to_fid(id, param*)

    2. Let C_1 be $set_localkind(C'''', (ACTION))

    3. (Param_ok: (LOCAL) C_1 |- param : paramIL tid*)*

    4. If ((tid* matches pattern []))*, then

      1. Let C_2 be $add_params((LOCAL), C_1, (paramIL* as paramtyp*))

      2. Block_ok: (LOCAL) C_2 (CONT) (INIT) |- block : _context _flow blockIL

      3. Let fd be ((MonoFD (ActionT (paramIL* as paramtyp*))) as funcdef)

      4. If (FuncDef_wf: $bound_tids(p', C'''') |- fd holds), then

        1. Let C_4 be $add_funcdef_non_overload(p', C'''', fid, fd)

        2. Result in C_4, (ActionD id paramIL* blockIL)

      4. Else

        1. Phantom#879

    4. Else

      1. Phantom#880

  2. Else

    1. Phantom#881

1. Else If (decl'' matches pattern `ValueSetD%%%`), then

  1. Let (ValueSetD id type expr) be decl''

  2. If ((p' = (GLOBAL)) \/ ((p' = (BLOCK)) /\ (C''''.BLOCK.KIND = (PARSER)))), then

    1. Type_ok: p' C'''' |- type : typ_s tid*

    2. If (tid* matches pattern []), then

      1. If (Type_wf: $bound_tids(p', C'''') |- ((SetT typ_s) as typ) holds), then

        1. Expr_ok: p' C'''' |- expr : exprIL

        2. Let (( typ ; ctk )) be $annot(exprIL)

        3. If ((ctk = (CTK)) \/ (ctk = (LCTK))), then

          1. Let C' be $add_styp(p', C'''', id, (((SetT typ_s) as typ) (NO) (CTK) ?()))

          2. Result in C', (ValueSetD id typ exprIL)

        3. Else

          1. Phantom#874

      1. Else

        1. Phantom#875

    2. Else

      1. Phantom#876

  2. Else

    1. Phantom#877

1. Else

  1. Phantom#878

2. If (p' matches pattern `GLOBAL`), then

  1. If (decl'' matches pattern `ErrD%`), then

    1. Let (ErrD member*) be decl''

    2. If $distinct_<member>(member*), then

      1. (Let id_e be $concat_text(["error.", member]))*

      2. (Let val_e be (ErrV member))*

      3. (Let styp_e be (((ErrT) as typ) (NO) (LCTK) ?(val_e)))*

      4. Let C' be $add_styps((GLOBAL), C'''', id_e*, styp_e*)

      5. Result in C', (ErrD member*)

    2. Else

      1. Phantom#952

  1. Else If (decl'' matches pattern `MatchKindD%`), then

    1. Let (MatchKindD member*) be decl''

    2. If $distinct_<member>(member*), then

      1. (Let id_m be member)*

      2. (Let val_m be (MatchKindV member))*

      3. (Let styp_m be (((MatchKindT) as typ) (NO) (LCTK) ?(val_m)))*

      4. Let C' be $add_styps((GLOBAL), C'''', id_m*, styp_m*)

      5. Result in C', (MatchKindD member*)

    2. Else

      1. Phantom#951

  1. Else If (decl'' matches pattern `StructD%%%`), then

    1. Let (StructD id tparam* (member_f, type_f)*) be decl''

    2. Let C' be $add_tparams((BLOCK), C'''', tparam*)

    3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*)*

    4. Let tparam_hidden* be $concat_<tid>(tid_fresh_f**)

    5. Let typ_s be ((StructT id (member_f, typ_f)*) as typ)

    6. Let td be ((PolyD (tparam*, tparam_hidden*) -> typ_s) as typdef)

    7. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

      1. Let C'' be $add_typdef((GLOBAL), C'''', id, td)

      2. Result in C'', (StructD id tparam* tparam_hidden* (member_f, typ_f)*)

    7. Else

      1. Phantom#950

  1. Else If (decl'' matches pattern `HeaderD%%%`), then

    1. Let (HeaderD id tparam* (member_f, type_f)*) be decl''

    2. Let C' be $add_tparams((BLOCK), C'''', tparam*)

    3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*)*

    4. Let tparam_hidden* be $concat_<tid>(tid_fresh_f**)

    5. Let typ_s be ((HeaderT id (member_f, typ_f)*) as typ)

    6. Let td be ((PolyD (tparam*, tparam_hidden*) -> typ_s) as typdef)

    7. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

      1. Let C'' be $add_typdef((GLOBAL), C'''', id, td)

      2. Result in C'', (HeaderD id tparam* tparam_hidden* (member_f, typ_f)*)

    7. Else

      1. Phantom#949

  1. Else If (decl'' matches pattern `UnionD%%%`), then

    1. Let (UnionD id tparam* (member_f, type_f)*) be decl''

    2. Let C' be $add_tparams((BLOCK), C'''', tparam*)

    3. (Type_ok: (BLOCK) C' |- type_f : typ_f tid_fresh_f*)*

    4. Let tparam_hidden* be $concat_<tid>(tid_fresh_f**)

    5. Let typ_s be ((UnionT id (member_f, typ_f)*) as typ)

    6. Let td be ((PolyD (tparam*, tparam_hidden*) -> typ_s) as typdef)

    7. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

      1. Let C'' be $add_typdef((GLOBAL), C'''', id, td)

      2. Result in C'', (UnionD id tparam* tparam_hidden* (member_f, typ_f)*)

    7. Else

      1. Phantom#948

  1. Else If (decl'' matches pattern `EnumD%%`), then

    1. Let (EnumD id member*) be decl''

    2. If $distinct_<member>(member*), then

      1. (Let id_e be $concat_text([id, ".", member]))*

      2. (Let val_e be (EnumFieldV id member))*

      3. Let typ_e be ((EnumT id member*) as typ)

      4. (Let styp_e be (typ_e (NO) (LCTK) ?(val_e)))*

      5. Let C' be $add_styps((GLOBAL), C'''', id_e*, styp_e*)

      6. Let td be ((MonoD typ_e) as typdef)

      7. Let tidset be $bound_tids((GLOBAL), C'''')

      8. If (TypeDef_wf: tidset |- td holds), then

        1. Let C'' be $add_typdef((GLOBAL), C', id, td)

        2. Result in C'', (EnumD id member*)

      8. Else

        1. Phantom#946

    2. Else

      1. Phantom#947

  1. Else If (decl'' matches pattern `SEnumD%%%`), then

    1. Let (SEnumD id type (member, expr)*) be decl''

    2. If $distinct_<member>(member*), then

      1. Type_ok: (GLOBAL) C'''' |- type : typ tid*

      2. If (tid* matches pattern []), then

        1. If (Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds), then

          1. SEnum_fields_ok: C'''' id typ [] |- (member, expr)* : C_1 (member', val_s)*

          2. If ((member' = member))*, then

            1. (Let id_s be $concat_text([id, ".", member]))*

            2. Let typ_s be ((SEnumT id typ (member, val_s)*) as typ)

            3. (Let styp_s be (typ_s (NO) (LCTK) ?(val_s)))*

            4. Let C_2 be $add_styps((GLOBAL), C_1, id_s*, styp_s*)

            5. Let td be ((MonoD typ_s) as typdef)

            6. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

              1. Let C_3 be $add_typdef((GLOBAL), C_2, id, td)

              2. Result in C_3, (SEnumD id typ (member, val_s)*)

            6. Else

              1. Phantom#941

          2. Else

            1. Phantom#942

        1. Else

          1. Phantom#943

      2. Else

        1. Phantom#944

    2. Else

      1. Phantom#945

  1. Else If (decl'' matches pattern `NewTypeD%%`), then

    1. Let (NewTypeD id typedef) be decl''

    2. If (typedef matches pattern `TypeD%`), then

      1. Let (TypeD type) be typedef

      2. Type_ok: (GLOBAL) C'''' |- type : typ tid*

      3. If (tid* matches pattern []), then

        1. If (Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds), then

          1. Let typ_n be ((NewT id typ) as typ)

          2. Let td be ((MonoD typ_n) as typdef)

          3. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

            1. Let C' be $add_typdef((GLOBAL), C'''', id, td)

            2. Result in C', (NewTypeD id (TypeD typ))

          3. Else

            1. Phantom#938

        1. Else

          1. Phantom#939

      3. Else

        1. Phantom#940

    2. Else If (typedef matches pattern `DeclD%`), then

      1. Let (DeclD decl'') be typedef

      2. Decl_ok: (GLOBAL) C'''' |- decl'' : C' declIL

      3. Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typdef>(C'.GLOBAL.TDENV), $dom_map<tid, typdef>(C''''.GLOBAL.TDENV))

      4. If (tid* matches pattern [ _/1 ]), then

        1. Let [tid_n] be tid*

        2. Let typdef? be $find_typdef((GLOBAL), C', (CURRENT tid_n))

        3. If (typdef? matches pattern (_)), then

          1. Let ?(typdef) be typdef?

          2. If (typdef has type monotypdef), then

            1. Let (MonoD typ_n) be (typdef as monotypdef)

            2. Let td be ((MonoD ((NewT id typ_n) as typ)) as typdef)

            3. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

              1. Let C'' be $add_typdef((GLOBAL), C'''', id, td)

              2. Result in C'', (NewTypeD id (DeclD declIL))

            3. Else

              1. Phantom#935

          2. Else If (typdef has type polytypdef), then

            1. Let ptd be (typdef as polytypdef)

            2. Let td be ((MonoD ((NewT id ((SpecT ptd []) as typ)) as typ)) as typdef)

            3. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

              1. Let C'' be $add_typdef((GLOBAL), C'''', id, td)

              2. Result in C'', (NewTypeD id (DeclD declIL))

            3. Else

              1. Phantom#934

        3. Else

          1. Phantom#936

      4. Else

        1. Phantom#937

  1. Else If (decl'' matches pattern `TypeDefD%%`), then

    1. Let (TypeDefD id typedef) be decl''

    2. If (typedef matches pattern `TypeD%`), then

      1. Let (TypeD type) be typedef

      2. Type_ok: (GLOBAL) C'''' |- type : typ tid*

      3. If (tid* matches pattern []), then

        1. If (Type_wf: $bound_tids((GLOBAL), C'''') |- typ holds), then

          1. Let typ_d be ((DefT typ) as typ)

          2. Let td be ((MonoD typ_d) as typdef)

          3. Let tidset be $bound_tids((GLOBAL), C'''')

          4. If (TypeDef_wf: tidset |- td holds), then

            1. Let C' be $add_typdef((GLOBAL), C'''', id, td)

            2. Result in C', (TypeDefD id (TypeD typ))

          4. Else

            1. Phantom#931

        1. Else

          1. Phantom#932

      3. Else

        1. Phantom#933

    2. Else If (typedef matches pattern `DeclD%`), then

      1. Let (DeclD decl'') be typedef

      2. Decl_ok: (GLOBAL) C'''' |- decl'' : C' declIL

      3. Let ({ tid* }) be $diff_set<tid>($dom_map<tid, typdef>(C'.GLOBAL.TDENV), $dom_map<tid, typdef>(C''''.GLOBAL.TDENV))

      4. If (tid* matches pattern [ _/1 ]), then

        1. Let [tid_d] be tid*

        2. Let typdef? be $find_typdef((GLOBAL), C', (CURRENT tid_d))

        3. If (typdef? matches pattern (_)), then

          1. Let ?(typdef) be typdef?

          2. If (typdef has type monotypdef), then

            1. Let (MonoD typ_d) be (typdef as monotypdef)

            2. Let td be ((MonoD ((DefT typ_d) as typ)) as typdef)

            3. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

              1. Let C'' be $add_typdef((GLOBAL), C'''', id, td)

              2. Result in C'', (TypeDefD id (DeclD declIL))

            3. Else

              1. Phantom#928

          2. Else If (typdef has type polytypdef), then

            1. Let ptd be (typdef as polytypdef)

            2. Let td be ((MonoD ((DefT ((SpecT ptd []) as typ)) as typ)) as typdef)

            3. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

              1. Let C'' be $add_typdef((GLOBAL), C'''', id, td)

              2. Result in C'', (TypeDefD id (DeclD declIL))

            3. Else

              1. Phantom#927

        3. Else

          1. Phantom#929

      4. Else

        1. Phantom#930

  1. Else If (decl'' matches pattern `FuncD%%%%%`), then

    1. Let (FuncD id type_r tparam* param* block) be decl''

    2. Let fid be $to_fid(id, param*)

    3. Let C_1 be $add_typdefs((LOCAL), C'''', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    4. Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*

    5. If (tid* matches pattern []), then

      1. Let C_2 be $set_localkind(C_1, (FUNC typ_r))

      2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

      3. Let tparam_hidden* be $concat_<tid>(tid_fresh_p**)

      4. Let C_3 be $add_params((LOCAL), C_2, (paramIL* as paramtyp*))

      5. Block_ok: (LOCAL) C_3 (CONT) (INIT) |- block : C_4 f blockIL

      6. If ((f = (RET)) \/ ((f = (CONT)) /\ (typ_r = ((VoidT) as typ)))), then

        1. Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (FuncT (paramIL* as paramtyp*) typ_r)) as funcdef)

        2. If (FuncDef_wf: $bound_tids((GLOBAL), C'''') |- fd holds), then

          1. Let C_5 be $add_funcdef((GLOBAL), C'''', fid, fd)

          2. Result in C_5, (FuncD id typ_r tparam* tparam_hidden* paramIL* blockIL)

        2. Else

          1. Phantom#924

      6. Else

        1. Phantom#925

    5. Else

      1. Phantom#926

  1. Else If (decl'' matches pattern `ExternFuncD%%%%`), then

    1. Let (ExternFuncD id type_r tparam* param*) be decl''

    2. Let fid be $to_fid(id, param*)

    3. Let C_1 be $add_typdefs((LOCAL), C'''', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    4. Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*

    5. If (tid* matches pattern []), then

      1. Let C_2 be $set_localkind(C_1, (EXTERNFUNC))

      2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

      3. Let tparam_hidden* be $concat_<tid>(tid_fresh_p**)

      4. Let C_3 be $add_params((LOCAL), C_2, (paramIL* as paramtyp*))

      5. Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (ExternFuncT (paramIL* as paramtyp*) typ_r)) as funcdef)

      6. If (FuncDef_wf: $bound_tids((GLOBAL), C'''') |- fd holds), then

        1. Let C_4 be $add_funcdef((GLOBAL), C'''', fid, fd)

        2. Result in C_4, (ExternFuncD id typ_r tparam* tparam_hidden* paramIL*)

      6. Else

        1. Phantom#922

    5. Else

      1. Phantom#923

  1. Else If (decl'' matches pattern `ExternObjectD%%%`), then

    1. Let (ExternObjectD id tparam* method*) be decl''

    2. Let (method_c*, method_m*) be $split_methods(method*)

    3. Let C_1 be $set_blockkind(C'''', (EXTERN))

    4. Let C_2 be $add_typdefs((BLOCK), C_1, tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    5. Methods_ok: C_2 id |- method_m* : C_3 methodIL_m*

    6. Let td be ((PolyD (tparam*, []) -> ((ExternT id C_3.BLOCK.FDENV) as typ)) as typdef)

    7. Let C_4 be $add_typdef((GLOBAL), C'''', id, td)

    8. Let C_5 be $set_blockkind(C_4, (EXTERN))

    9. Let C_6 be $add_typdefs((BLOCK), C_5, tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    10. Methods_ok: C_6 id |- method_c* : C_7 methodIL_c*

    11. Let C_8 be C_4[GLOBAL.CDENV = C_7.GLOBAL.CDENV]

    12. Result in C_8, (ExternObjectD id tparam* methodIL_c* ++ methodIL_m*)

  1. Else If (decl'' matches pattern `ParserTypeD%%%`), then

    1. Let (ParserTypeD id tparam* param*) be decl''

    2. Let C_1 be $set_blockkind(C'''', (PARSER))

    3. Let C_2 be $add_typdefs((BLOCK), C_1, tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    4. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

    5. (Let (id_p dir_p typ_p val_p?) be paramIL)*

    6. Let tparam_hidden* be $concat_<tid>(tid_fresh_p**)

    7. Let td be ((PolyD (tparam*, tparam_hidden*) -> ((ParserT (id_p dir_p typ_p val_p?)*) as typ)) as typdef)

    8. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

      1. Let C_3 be $add_typdef((GLOBAL), C'''', id, td)

      2. Result in C_3, (ParserTypeD id tparam* tparam_hidden* paramIL*)

    8. Else

      1. Phantom#921

  1. Else If (decl'' matches pattern `ParserD%%%%%`), then

    1. Let (ParserD id param* cparam* decl''* parserstate*) be decl''

    2. Let cid be $to_fid(id, cparam*)

    3. Let C_1 be $set_blockkind(C'''', (PARSER))

    4. (Param_ok: (LOCAL) C_1 |- cparam : cparamIL tid*)*

    5. If ((tid* matches pattern []))*, then

      1. Let C_2 be $add_params((BLOCK), C_1, (cparamIL* as paramtyp*))

      2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid*')*

      3. If ((tid*' matches pattern []))*, then

        1. Let funcdef_apply be ((MonoFD (ParserApplyMethodT (paramIL* as paramtyp*))) as funcdef)

        2. If (FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds), then

          1. Let C_3 be $add_params((BLOCK), C_2, (paramIL* as paramtyp*))

          2. Decls_ok: (BLOCK) C_3 |- decl''* : C_4 declIL*

          3. (Let (statelabel block) be parserstate)*

          4. If $distinct_<statelabel>(statelabel*), then

            1. If "start" is in statelabel*, then

              1. If ~"accept" is in statelabel*, then

                1. If ~"reject " is in statelabel*, then

                  1. Let statelabel'* be "accept" :: "reject" :: statelabel*

                  2. Let C_5 be $set_localkind(C_4, (PARSERSTATE))

                  3. Let styp* be $repeat_<styp>((((StateT) as typ) (NO) (DYN) ?()), |statelabel'*|)

                  4. Let C_6 be $add_styps((BLOCK), C_5, statelabel'*, styp*)

                  5. (ParserState_ok: C_6 |- parserstate : parserstateIL)*

                  6. Let ptd be (PolyD ([], []) -> ((ParserT (paramIL* as paramtyp*)) as typ))

                  7. Let typ be ((SpecT ptd []) as typ)

                  8. Let cd be (ConsD ([], []) -> (ConsT (cparamIL* as paramtyp*) typ))

                  9. If (ConsDef_wf: $bound_tids((GLOBAL), C'''') |- cd holds), then

                    1. Let C_8 be $add_consdef((GLOBAL), C'''', cid, cd)

                    2. Result in C_8, (ParserD id paramIL* cparamIL* declIL* parserstateIL*)

                  9. Else

                    1. Phantom#913

                1. Else

                  1. Phantom#914

              1. Else

                1. Phantom#915

            1. Else

              1. Phantom#916

          4. Else

            1. Phantom#917

        2. Else

          1. Phantom#918

      3. Else

        1. Phantom#919

    5. Else

      1. Phantom#920

  1. Else If (decl'' matches pattern `ControlTypeD%%%`), then

    1. Let (ControlTypeD id tparam* param*) be decl''

    2. Let C' be $add_typdefs((BLOCK), C'''', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    3. Let C'' be $set_blockkind(C'''', (CONTROL))

    4. (Param_ok: (LOCAL) C' |- param : paramIL tid_fresh_p*)*

    5. (Let (id_p dir_p typ_p val_p?) be paramIL)*

    6. Let tparam_hidden* be $concat_<tid>(tid_fresh_p**)

    7. Let td be ((PolyD (tparam*, tparam_hidden*) -> ((ControlT (id_p dir_p typ_p val_p?)*) as typ)) as typdef)

    8. If (TypeDef_wf: $bound_tids((GLOBAL), C'''') |- td holds), then

      1. Let C''' be $add_typdef((GLOBAL), C'''', id, td)

      2. Result in C''', (ControlTypeD id tparam* tparam_hidden* paramIL*)

    8. Else

      1. Phantom#912

  1. Else If (decl'' matches pattern `ControlD%%%%%`), then

    1. Let (ControlD id param* cparam* decl''* block) be decl''

    2. Let cid be $to_fid(id, cparam*)

    3. Let C_1 be $set_blockkind(C'''', (CONTROL))

    4. (Param_ok: (LOCAL) C_1 |- cparam : cparamIL tid*)*

    5. If ((tid* matches pattern []))*, then

      1. Let C_2 be $add_params((BLOCK), C_1, (cparamIL* as paramtyp*))

      2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid*')*

      3. If ((tid*' matches pattern []))*, then

        1. Let funcdef_apply be ((MonoFD (ControlApplyMethodT (paramIL* as paramtyp*))) as funcdef)

        2. If (FuncDef_wf: $bound_tids((GLOBAL), C'''') |- funcdef_apply holds), then

          1. Let C_3 be $add_params((BLOCK), C_2, (paramIL* as paramtyp*))

          2. Decls_ok: (BLOCK) C_3 |- decl''* : C_4 declIL*

          3. Let C_5 be $set_localkind(C_4, (CONTROLAPPLYMETHOD))

          4. Block_ok: (LOCAL) C_5 (CONT) (INIT) |- block : C_6 f blockIL

          5. Let ptd be (PolyD ([], []) -> ((ControlT (paramIL* as paramtyp*)) as typ))

          6. Let typ be ((SpecT ptd []) as typ)

          7. Let cd be (ConsD ([], []) -> (ConsT (cparamIL* as paramtyp*) typ))

          8. If (ConsDef_wf: $bound_tids((GLOBAL), C'''') |- cd holds), then

            1. Let C_7 be $add_consdef((GLOBAL), C'''', cid, cd)

            2. Result in C_7, (ControlD id paramIL* cparamIL* declIL* blockIL)

          8. Else

            1. Phantom#908

        2. Else

          1. Phantom#909

      3. Else

        1. Phantom#910

    5. Else

      1. Phantom#911

  1. Else If (decl'' matches pattern `PackageTypeD%%%`), then

    1. Let (PackageTypeD id tparam* cparam*) be decl''

    2. Let cid be $to_fid(id, cparam*)

    3. Let C_1 be $add_typdefs((BLOCK), C'''', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    4. Let C_2 be $set_blockkind(C_1, (PACKAGE))

    5. (CParam_ok: (BLOCK) C_2 |- cparam : cparamIL tid_fresh_c*)*

    6. Let tparam_hidden* be $concat_<tid>(tid_fresh_c**)

    7. (Let (_idIL _dirIL typ_c _val?) be cparamIL)*

    8. Let ptd be (PolyD (tparam*, tparam_hidden*) -> ((PackageT typ_c*) as typ))

    9. If (TypeDef_wf: $bound_tids((BLOCK), C_2) |- (ptd as typdef) holds), then

      1. Let tparam'* be tparam* ++ tparam_hidden*

      2. Let typ be ((SpecT ptd ((VarT tparam') as typ)*) as typ)

      3. Let cd be (ConsD (tparam*, tparam_hidden*) -> (ConsT (cparamIL* as paramtyp*) typ))

      4. If (ConsDef_wf: $bound_tids((BLOCK), C_2) |- cd holds), then

        1. Let C_3 be $add_typdef((GLOBAL), C'''', id, (ptd as typdef))

        2. Let C_4 be $add_consdef((GLOBAL), C_3, cid, cd)

        3. Result in C_4, (PackageTypeD id tparam* tparam_hidden* cparamIL*)

      4. Else

        1. Phantom#905

    9. Else

      1. Phantom#906

  1. Else

    1. Phantom#907

2. Else If (p' matches pattern `BLOCK`), then

  1. If (decl'' matches pattern `TableD%%`), then

    1. Let (TableD id tbl) be decl''

    2. If (C''''.BLOCK.KIND matches pattern `CONTROL`), then

      1. If (|$keys_of_table(tbl)| <= 1), then

        1. If (|$actions_of_table(tbl)| = 1), then

          1. Let C_1 be $set_localkind(C'''', (TABLEAPPLYMETHOD))

          2. Table_props_ok: (LOCAL) C_1 $empty_tblctx |- tbl : tblctx' tblIL

          3. Table_type_decl_ok: (BLOCK) C_1 tblctx' |- id : C_2 typ_tbl

          4. Let typ be ((TableT id typ_tbl) as typ)

          5. If (Type_wf: $bound_tids((BLOCK), C_2) |- typ holds), then

            1. Let C_3 be $add_styp((BLOCK), C_2, id, (typ (NO) (DYN) ?()))

            2. Result in C_3, (TableD id typ tblIL)

          5. Else

            1. Phantom#899

        1. Else

          1. Phantom#900

      1. Else

        1. Phantom#901

    2. Else

      1. Phantom#902

  1. Else

    1. Phantom#903

2. Else

  1. Phantom#904

;; ../../../../spec/4b-typing-relation.watsup:119.1-121.23
relation Decls_ok: p, C, decl*

1. If (decl* matches pattern []), then

  1. Result in C, []

1. Else If (decl* matches pattern _ :: _), then

  1. Let decl_h :: decl_t* be decl*

  2. Decl_ok: p C |- decl_h : C' declIL_h

  3. Decls_ok: p C' |- decl_t* : C'' declIL_t*

  4. Result in C'', declIL_h :: declIL_t*

;; ../../../../spec/4b-typing-relation.watsup:125.1-127.17
relation Prog_ok: decl*

1. Let C be $empty_context

2. Decls_ok: (GLOBAL) C |- decl* : C' declIL*

3. Result in C', declIL*

;; ../../../../spec/4b-typing-relation.watsup:131.18-131.29
syntax actctxt = 
   | `ACT`()
   | `NOACT`()

;; ../../../../spec/4b-typing-relation.watsup:132.1-134.29
relation Call_convention_ok: p, C, actctxt, (id dir typ_p' val?), (exprIL, typ_a')

1. If (dir matches pattern `IN`), then

  1. Let exprIL' be $coerce_assign(exprIL, typ_p')

  2. Result in exprIL'

1. Else If (dir matches pattern `OUT`), then

  1. If (Type_alpha: typ_a' ~~ typ_p' holds), then

    1. If (Lval_ok: p C |- exprIL holds), then

      1. Result in exprIL

    1. Else

      1. Phantom#956

  1. Else

    1. Phantom#957

1. Else If (dir matches pattern `INOUT`), then

  1. If (Type_alpha: typ_a' ~~ typ_p' holds), then

    1. If (Lval_ok: p C |- exprIL holds), then

      1. Result in exprIL

    1. Else

      1. Phantom#953

  1. Else

    1. Phantom#954

1. Else

  1. Phantom#955

2. If (actctxt matches pattern `ACT`), then

  1. If (dir matches pattern `NO`), then

    1. Let exprIL' be $coerce_assign(exprIL, typ_p')

    2. Result in exprIL'

  1. Else

    1. Phantom#961

2. Else If (actctxt matches pattern `NOACT`), then

  1. If (dir matches pattern `NO`), then

    1. Let (( _typ ; ctk )) be $annot(exprIL)

    2. If ((ctk = (LCTK)) \/ (ctk = (CTK))), then

      1. If (Type_alpha: typ_a' ~~ typ_p' holds), then

        1. Result in exprIL

      1. Else

        1. Phantom#958

    2. Else

      1. Phantom#959

  1. Else

    1. Phantom#960

;; ../../../../spec/4b-typing-relation.watsup:135.1-137.29
relation Call_convention_arg_ok: p, C, actctxt, pt', (argIL, typ')

1. If (argIL matches pattern `ExprA%`), then

  1. Let (ExprA exprIL) be argIL

  2. Call_convention_ok: p C actctxt |- pt' ~~ (exprIL, typ') : exprIL'

  3. Result in (ExprA exprIL')

1. Else If (argIL matches pattern `NameA%%`), then

  1. Let (NameA id exprIL?) be argIL

  2. If (exprIL? matches pattern (_)), then

    1. Let ?(exprIL) be exprIL?

    2. Call_convention_ok: p C actctxt |- pt' ~~ (exprIL, typ') : exprIL'

    3. Result in (NameA id ?(exprIL'))

  2. Else

    1. Phantom#962

1. Else

  1. Phantom#963

2. Let (_id dir _typ _val?) be pt'

3. If (dir matches pattern `OUT`), then

  1. If (argIL matches pattern `NameA%%`), then

    1. Let (NameA id exprIL?) be argIL

    2. If (exprIL? matches pattern ()), then

      1. Result in (NameA id ?())

    2. Else

      1. Phantom#965

  1. Else If (argIL matches pattern `AnyA`), then

    1. Result in (AnyA)

  1. Else

    1. Phantom#964

3. Else

  1. Phantom#966

;; ../../../../spec/4b-typing-relation.watsup:143.1-145.23
relation Call_site_ok: cursor, C, functyp

1. If (cursor matches pattern `BLOCK`), then

  1. If (functyp matches pattern `ExternFuncT%%`), then

    1. Let (ExternFuncT _paramtyp* _typ) be functyp

    2. If ((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL))), then

      1. The relation holds

    2. Else

      1. Phantom#986

  1. Else If (functyp matches pattern `BuiltinMethodT%%`), then

    1. Let (BuiltinMethodT _paramtyp* _typ) be functyp

    2. If ((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL))), then

      1. The relation holds

    2. Else

      1. Phantom#985

  1. Else If (functyp matches pattern `ExternMethodT%%`), then

    1. Let (ExternMethodT _paramtyp* _typ) be functyp

    2. If ((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL))), then

      1. The relation holds

    2. Else

      1. Phantom#984

  1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

    1. Let (ExternAbstractMethodT _paramtyp* _typ) be functyp

    2. If ((C.BLOCK.KIND = (PARSER)) \/ (C.BLOCK.KIND = (CONTROL))), then

      1. The relation holds

    2. Else

      1. Phantom#982

  1. Else

    1. Phantom#983

1. Else If (cursor matches pattern `LOCAL`), then

  1. If (functyp matches pattern `ActionT%`), then

    1. Let (ActionT _paramtyp*) be functyp

    2. If (((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))), then

      1. The relation holds

    2. Else

      1. Phantom#980

  1. Else If (functyp matches pattern `FuncT%%`), then

    1. Let (FuncT _paramtyp* _typ) be functyp

    2. Let lkind be C.LOCAL.KIND

    3. If (lkind matches pattern `FUNC%`), then

      1. Let (FUNC typ) be lkind

      2. The relation holds

    3. Else

      1. Phantom#978

    4. If ((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))), then

      1. The relation holds

    4. Else

      1. Phantom#979

  1. Else If (functyp matches pattern `ExternFuncT%%`), then

    1. Let (ExternFuncT _paramtyp* _typ) be functyp

    2. Let lkind be C.LOCAL.KIND

    3. If (lkind matches pattern `EXTERNABSTRACTMETHOD%`), then

      1. Let (EXTERNABSTRACTMETHOD typ) be lkind

      2. The relation holds

    3. Else

      1. Phantom#976

    4. If ((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))), then

      1. The relation holds

    4. Else

      1. Phantom#977

  1. Else If (functyp matches pattern `BuiltinMethodT%%`), then

    1. Let (BuiltinMethodT _paramtyp* _typ) be functyp

    2. Let lkind be C.LOCAL.KIND

    3. If (lkind matches pattern `FUNC%`), then

      1. Let (FUNC typ) be lkind

      2. The relation holds

    3. Else If (lkind matches pattern `EXTERNABSTRACTMETHOD%`), then

      1. Let (EXTERNABSTRACTMETHOD typ) be lkind

      2. The relation holds

    3. Else

      1. Phantom#974

    4. If ((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))), then

      1. The relation holds

    4. Else

      1. Phantom#975

  1. Else If (functyp matches pattern `ExternMethodT%%`), then

    1. Let (ExternMethodT _paramtyp* _typ) be functyp

    2. Let lkind be C.LOCAL.KIND

    3. If (lkind matches pattern `EXTERNABSTRACTMETHOD%`), then

      1. Let (EXTERNABSTRACTMETHOD typ) be lkind

      2. The relation holds

    3. Else

      1. Phantom#972

    4. If ((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))), then

      1. The relation holds

    4. Else

      1. Phantom#973

  1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

    1. Let (ExternAbstractMethodT _paramtyp* _typ) be functyp

    2. Let lkind be C.LOCAL.KIND

    3. If (lkind matches pattern `EXTERNABSTRACTMETHOD%`), then

      1. Let (EXTERNABSTRACTMETHOD typ) be lkind

      2. The relation holds

    3. Else

      1. Phantom#970

    4. If ((((C.LOCAL.KIND = (ACTION)) \/ (C.LOCAL.KIND = (PARSERSTATE))) \/ (C.LOCAL.KIND = (CONTROLAPPLYMETHOD))) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))), then

      1. The relation holds

    4. Else

      1. Phantom#971

  1. Else If (functyp matches pattern `ParserApplyMethodT%`), then

    1. Let (ParserApplyMethodT _paramtyp*) be functyp

    2. If (C.LOCAL.KIND matches pattern `PARSERSTATE`), then

      1. The relation holds

    2. Else

      1. Phantom#969

  1. Else If (functyp matches pattern `ControlApplyMethodT%`), then

    1. Let (ControlApplyMethodT _paramtyp*) be functyp

    2. If (C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`), then

      1. The relation holds

    2. Else

      1. Phantom#968

  1. Else If (functyp matches pattern `TableApplyMethodT%`), then

    1. Let (TableApplyMethodT _typ) be functyp

    2. If ((C.LOCAL.KIND = (CONTROLAPPLYMETHOD)) \/ (C.LOCAL.KIND = (TABLEAPPLYMETHOD))), then

      1. The relation holds

    2. Else

      1. Phantom#967

1. Else

  1. Phantom#981

;; ../../../../spec/4b-typing-relation.watsup:146.1-148.35
relation Call_ok: p, C, tid*', functyp, targIL*', arg*', id*'

1. Let targIL* be targIL*'

2. Let arg* be arg*'

3. Let id_deft* be id*'

4. If (tid*' matches pattern []), then

  1. If (functyp matches pattern `ActionT%`), then

    1. Let (ActionT pt*) be functyp

    2. Let pt'* be $filter_default_args(pt*, id_deft*)

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If (|pt'*| = |argIL*|), then

      1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

      2. If (FuncType_wf: $bound_tids(p, C) |- (ActionT pt*) holds), then

        1. If (Call_site_ok: p C |- (ActionT pt*) :CALLSITE_OK holds), then

          1. If (~$is_table_apply_in_action_arg(argIL))*, then

            1. (Call_convention_arg_ok: p C (ACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in ((VoidT) as typ), [], argIL*

          1. Else

            1. Phantom#991

        1. Else

          1. Phantom#992

      2. Else

        1. Phantom#993

    4. Else

      1. Phantom#994

  1. Else If (functyp matches pattern `ExternFuncT%%`), then

    1. Let (ExternFuncT pt* typ_r) be functyp

    2. Let pt'* be $filter_default_args(pt*, id_deft*)

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If (|pt'*| = |argIL*|), then

      1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

      2. If (FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt* typ_r) holds), then

        1. If (Call_site_ok: p C |- (ExternFuncT pt* typ_r) :CALLSITE_OK holds), then

          1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

          2. Result in typ_r, targIL*, argIL''*

        1. Else

          1. Phantom#987

      2. Else

        1. Phantom#988

    4. Else

      1. Phantom#989

  1. Else

    1. Phantom#990

4. Else

  1. Phantom#995

5. Let tid_fresh* be tid*'

6. If (functyp matches pattern `ExternFuncT%%`), then

  1. Let (ExternFuncT pt* typ_r) be functyp

  2. Let pt'* be $filter_default_args(pt*, id_deft*)

  3. (Arg_ok: p C |- arg : argIL typ_a)*

  4. If (|pt'*| = |argIL*|), then

    1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

    2. Let theta be $infer_targs(tid_fresh*, pt''*, typ_a*)

    3. (Let typ? be $find_map<tid, typ>(theta, tid_fresh))*

    4. If ((typ? matches pattern (_)))*, then

      1. (Let ?(targIL') be typ?)*

      2. Let targIL''* be targIL* ++ targIL'*

      3. Let functyp' be $subst_functyp(theta, (ExternFuncT pt''* typ_r))

      4. If (functyp' matches pattern `ExternFuncT%%`), then

        1. Let (ExternFuncT pt'''* typ_r') be functyp'

        2. If (FuncType_wf: $bound_tids(p, C) |- (ExternFuncT pt'''* typ_r') holds), then

          1. If (Call_site_ok: p C |- (ExternFuncT pt'''* typ_r') :CALLSITE_OK holds), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r', targIL''*, argIL''*

          1. Else

            1. Phantom#1012

        2. Else

          1. Phantom#1013

      4. Else

        1. Phantom#1014

    4. Else

      1. Phantom#1015

  4. Else

    1. Phantom#1016

6. Else If (functyp matches pattern `FuncT%%`), then

  1. Let (FuncT pt* typ_r) be functyp

  2. Let pt'* be $filter_default_args(pt*, id_deft*)

  3. (Arg_ok: p C |- arg : argIL typ_a)*

  4. If (|pt'*| = |argIL*|), then

    1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

    2. Let theta be $infer_targs(tid_fresh*, pt''*, typ_a*)

    3. (Let typ? be $find_map<tid, typ>(theta, tid_fresh))*

    4. If ((typ? matches pattern (_)))*, then

      1. (Let ?(targIL') be typ?)*

      2. Let targIL''* be targIL* ++ targIL'*

      3. Let functyp' be $subst_functyp(theta, (FuncT pt''* typ_r))

      4. If (functyp' matches pattern `FuncT%%`), then

        1. Let (FuncT pt'''* typ_r') be functyp'

        2. If (FuncType_wf: $bound_tids(p, C) |- (FuncT pt'''* typ_r') holds), then

          1. If (Call_site_ok: p C |- (FuncT pt'''* typ_r') :CALLSITE_OK holds), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r', targIL''*, argIL''*

          1. Else

            1. Phantom#1007

        2. Else

          1. Phantom#1008

      4. Else

        1. Phantom#1009

    4. Else

      1. Phantom#1010

  4. Else

    1. Phantom#1011

6. Else If (functyp matches pattern `ExternMethodT%%`), then

  1. Let (ExternMethodT pt* typ_r) be functyp

  2. Let pt'* be $filter_default_args(pt*, id_deft*)

  3. (Arg_ok: p C |- arg : argIL typ_a)*

  4. If (|pt'*| = |argIL*|), then

    1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

    2. Let theta be $infer_targs(tid_fresh*, pt''*, typ_a*)

    3. (Let typ? be $find_map<tid, typ>(theta, tid_fresh))*

    4. If ((typ? matches pattern (_)))*, then

      1. (Let ?(targIL') be typ?)*

      2. Let targIL''* be targIL* ++ targIL'*

      3. Let functyp' be $subst_functyp(theta, (ExternMethodT pt''* typ_r))

      4. If (functyp' matches pattern `ExternMethodT%%`), then

        1. Let (ExternMethodT pt'''* typ_r') be functyp'

        2. If (FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt'''* typ_r') holds), then

          1. If (Call_site_ok: p C |- (ExternMethodT pt'''* typ_r') :CALLSITE_OK holds), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r', targIL''*, argIL''*

          1. Else

            1. Phantom#1002

        2. Else

          1. Phantom#1003

      4. Else

        1. Phantom#1004

    4. Else

      1. Phantom#1005

  4. Else

    1. Phantom#1006

6. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

  1. Let (ExternAbstractMethodT pt* typ_r) be functyp

  2. Let pt'* be $filter_default_args(pt*, id_deft*)

  3. (Arg_ok: p C |- arg : argIL typ_a)*

  4. If (|pt'*| = |argIL*|), then

    1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

    2. Let theta be $infer_targs(tid_fresh*, pt''*, typ_a*)

    3. (Let typ? be $find_map<tid, typ>(theta, tid_fresh))*

    4. If ((typ? matches pattern (_)))*, then

      1. (Let ?(targIL') be typ?)*

      2. Let targIL''* be targIL* ++ targIL'*

      3. Let functyp' be $subst_functyp(theta, (ExternAbstractMethodT pt''* typ_r))

      4. If (functyp' matches pattern `ExternAbstractMethodT%%`), then

        1. Let (ExternAbstractMethodT pt'''* typ_r') be functyp'

        2. If (FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt'''* typ_r') holds), then

          1. If (Call_site_ok: p C |- (ExternAbstractMethodT pt'''* typ_r') :CALLSITE_OK holds), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r', targIL''*, argIL''*

          1. Else

            1. Phantom#996

        2. Else

          1. Phantom#997

      4. Else

        1. Phantom#998

    4. Else

      1. Phantom#999

  4. Else

    1. Phantom#1000

6. Else

  1. Phantom#1001

7. If (tid*' matches pattern []), then

  1. If (functyp matches pattern `FuncT%%`), then

    1. Let (FuncT pt* typ_r) be functyp

    2. Let pt'* be $filter_default_args(pt*, id_deft*)

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If (|pt'*| = |argIL*|), then

      1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

      2. If (FuncType_wf: $bound_tids(p, C) |- (FuncT pt* typ_r) holds), then

        1. If (Call_site_ok: p C |- (FuncT pt* typ_r) :CALLSITE_OK holds), then

          1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

          2. Result in typ_r, targIL*, argIL''*

        1. Else

          1. Phantom#1041

      2. Else

        1. Phantom#1042

    4. Else

      1. Phantom#1043

  1. Else If (functyp matches pattern `BuiltinMethodT%%`), then

    1. Let (BuiltinMethodT pt* typ_r) be functyp

    2. If (targIL*' matches pattern []), then

      1. Let pt'* be $filter_default_args(pt*, id_deft*)

      2. (Arg_ok: p C |- arg : argIL typ_a)*

      3. If (|pt'*| = |argIL*|), then

        1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

        2. If (FuncType_wf: $bound_tids(p, C) |- (BuiltinMethodT pt* typ_r) holds), then

          1. If (Call_site_ok: p C |- (BuiltinMethodT pt* typ_r) :CALLSITE_OK holds), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_r, [], argIL''*

          1. Else

            1. Phantom#1037

        2. Else

          1. Phantom#1038

      3. Else

        1. Phantom#1039

    2. Else

      1. Phantom#1040

  1. Else If (functyp matches pattern `ExternMethodT%%`), then

    1. Let (ExternMethodT pt* typ_r) be functyp

    2. Let pt'* be $filter_default_args(pt*, id_deft*)

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If (|pt'*| = |argIL*|), then

      1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

      2. If (FuncType_wf: $bound_tids(p, C) |- (ExternMethodT pt* typ_r) holds), then

        1. If (Call_site_ok: p C |- (ExternMethodT pt* typ_r) :CALLSITE_OK holds), then

          1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

          2. Result in typ_r, targIL*, argIL''*

        1. Else

          1. Phantom#1034

      2. Else

        1. Phantom#1035

    4. Else

      1. Phantom#1036

  1. Else If (functyp matches pattern `ExternAbstractMethodT%%`), then

    1. Let (ExternAbstractMethodT pt* typ_r) be functyp

    2. Let pt'* be $filter_default_args(pt*, id_deft*)

    3. (Arg_ok: p C |- arg : argIL typ_a)*

    4. If (|pt'*| = |argIL*|), then

      1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

      2. If (FuncType_wf: $bound_tids(p, C) |- (ExternAbstractMethodT pt* typ_r) holds), then

        1. If (Call_site_ok: p C |- (ExternAbstractMethodT pt* typ_r) :CALLSITE_OK holds), then

          1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

          2. Result in typ_r, targIL*, argIL''*

        1. Else

          1. Phantom#1031

      2. Else

        1. Phantom#1032

    4. Else

      1. Phantom#1033

  1. Else If (functyp matches pattern `ParserApplyMethodT%`), then

    1. Let (ParserApplyMethodT pt*) be functyp

    2. If (targIL*' matches pattern []), then

      1. Let pt'* be $filter_default_args(pt*, id_deft*)

      2. (Arg_ok: p C |- arg : argIL typ_a)*

      3. If (|pt'*| = |argIL*|), then

        1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

        2. If (FuncType_wf: $bound_tids(p, C) |- (ParserApplyMethodT pt*) holds), then

          1. If (Call_site_ok: p C |- (ParserApplyMethodT pt*) :CALLSITE_OK holds), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in ((VoidT) as typ), [], argIL''*

          1. Else

            1. Phantom#1027

        2. Else

          1. Phantom#1028

      3. Else

        1. Phantom#1029

    2. Else

      1. Phantom#1030

  1. Else If (functyp matches pattern `ControlApplyMethodT%`), then

    1. Let (ControlApplyMethodT pt*) be functyp

    2. If (targIL*' matches pattern []), then

      1. Let pt'* be $filter_default_args(pt*, id_deft*)

      2. (Arg_ok: p C |- arg : argIL typ_a)*

      3. If (|pt'*| = |argIL*|), then

        1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

        2. If (FuncType_wf: $bound_tids(p, C) |- (ControlApplyMethodT pt*) holds), then

          1. If (Call_site_ok: p C |- (ControlApplyMethodT pt*) :CALLSITE_OK holds), then

            1. (Call_convention_arg_ok: p C (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in ((VoidT) as typ), [], argIL''*

          1. Else

            1. Phantom#1023

        2. Else

          1. Phantom#1024

      3. Else

        1. Phantom#1025

    2. Else

      1. Phantom#1026

  1. Else If (functyp matches pattern `TableApplyMethodT%`), then

    1. Let (TableApplyMethodT typ_r) be functyp

    2. If (targIL*' matches pattern []), then

      1. If (arg*' matches pattern []), then

        1. If (id*' matches pattern []), then

          1. If (FuncType_wf: $bound_tids(p, C) |- (TableApplyMethodT typ_r) holds), then

            1. If (Call_site_ok: p C |- (TableApplyMethodT typ_r) :CALLSITE_OK holds), then

              1. Result in typ_r, [], []

            1. Else

              1. Phantom#1017

          1. Else

            1. Phantom#1018

        1. Else

          1. Phantom#1019

      1. Else

        1. Phantom#1020

    2. Else

      1. Phantom#1021

  1. Else

    1. Phantom#1022

7. Else

  1. Phantom#1044

;; ../../../../spec/4b-typing-relation.watsup:153.1-155.29
relation FuncType_ok: p, C, name, targIL*, arg*

1. Let (fid, funcdef, id*)? be $find_funcdef(p, C, name, arg*)

2. If ((fid, funcdef, id*)? matches pattern (_)), then

  1. Let ?((fid, fd, id_deft*)) be (fid, funcdef, id*)?

  2. Let (ft, tid_fresh*) be $specialize_funcdef(fd, targIL*)

  3. Result in ft, tid_fresh*, id_deft*

2. Else

  1. Phantom#1045

;; ../../../../spec/4b-typing-relation.watsup:156.1-158.32
relation MethodType_ok: p, C, expr_b, member', targIL*', arg*'

1. If (targIL*' matches pattern []), then

  1. If (arg*' matches pattern []), then

    1. Expr_ok: p C |- expr_b : exprIL_b

    2. If member' is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"], then

      1. Result in (BuiltinMethodT [] ((IntT) as typ)), exprIL_b, [], []

    2. Else

      1. Phantom#1046

  1. Else

    1. Phantom#1047

1. Else

  1. Phantom#1048

2. Let arg* be arg*'

3. If (targIL*' matches pattern []), then

  1. If member' is in ["push_front", "pop_front"], then

    1. Expr_ok: p C |- expr_b : exprIL_b

    2. Let (( typ_b ; _ctk )) be $annot(exprIL_b)

    3. Let typ be $canon_typ(typ_b)

    4. If (typ has type datatyp), then

      1. Let datatyp be (typ as datatyp)

      2. If (datatyp matches pattern `StackT%%`), then

        1. Let (StackT typ_b_in int_b) be datatyp

        2. Let pt be ("count" (NO) ((IntT) as typ) ?())

        3. Result in (BuiltinMethodT [pt] ((IntT) as typ)), exprIL_b, [], []

      2. Else

        1. Phantom#1049

    4. Else

      1. Phantom#1050

  1. Else

    1. Phantom#1051

  2. If member' is in ["setValid", "setInvalid"], then

    1. Expr_ok: p C |- expr_b : exprIL_b

    2. Let (( typ_b ; _ctk )) be $annot(exprIL_b)

    3. Let typ be $canon_typ(typ_b)

    4. If (typ has type datatyp), then

      1. Let datatyp be (typ as datatyp)

      2. If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT id_b (member_b, typ_b_in)*) be datatyp

        2. Result in (BuiltinMethodT [] ((VoidT) as typ)), exprIL_b, [], []

      2. Else

        1. Phantom#1052

    4. Else

      1. Phantom#1053

  2. Else

    1. Phantom#1054

3. Else

  1. Phantom#1055

4. If (member' = "isValid"), then

  1. If (targIL*' matches pattern []), then

    1. Expr_ok: p C |- expr_b : exprIL_b

    2. Let (( typ_b ; _ctk )) be $annot(exprIL_b)

    3. Let typ be $canon_typ(typ_b)

    4. If (typ has type datatyp), then

      1. Let datatyp be (typ as datatyp)

      2. If (datatyp matches pattern `HeaderT%%`), then

        1. Let (HeaderT id_b (member', typ_b_in)*) be datatyp

        2. Result in (BuiltinMethodT [] ((BoolT) as typ)), exprIL_b, [], []

      2. Else If (datatyp matches pattern `UnionT%%`), then

        1. Let (UnionT id_b (member', typ_b_in)*) be datatyp

        2. Result in (BuiltinMethodT [] ((BoolT) as typ)), exprIL_b, [], []

      2. Else

        1. Phantom#1056

    4. Else

      1. Phantom#1057

  1. Else

    1. Phantom#1058

4. Else

  1. Phantom#1059

5. Let targIL* be targIL*'

6. Expr_ok: p C |- expr_b : exprIL_b

7. Let (( typ_b ; _ctk )) be $annot(exprIL_b)

8. Let typ be $canon_typ(typ_b)

9. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT id_b fmap_b) be objtyp

    2. Let (fid, funcdef, id*)? be $find_func<funcdef>(member', $to_fkey(arg*), fmap_b)

    3. If ((fid, funcdef, id*)? matches pattern (_)), then

      1. Let ?((fid, fd, id_deft*)) be (fid, funcdef, id*)?

      2. Let (ft, tid_fresh*) be $specialize_funcdef(fd, targIL*)

      3. Result in ft, exprIL_b, tid_fresh*, id_deft*

    3. Else

      1. Phantom#1060

  2. Else

    1. Phantom#1061

9. Else

  1. Phantom#1062

10. If (member' = "apply"), then

  1. If (targIL*' matches pattern []), then

    1. If (typ has type objtyp), then

      1. Let objtyp be (typ as objtyp)

      2. If (objtyp matches pattern `ParserT%`), then

        1. Let (ParserT pt*) be objtyp

        2. Let ft be (ParserApplyMethodT pt*)

        3. Let fd be ((MonoFD ft) as funcdef)

        4. (Let (id_p _dir _typ val_deft?) be pt)*

        5. (Let b_deft be (val_deft? =/= ?()))*

        6. Let fid be ("apply" (id_p, b_deft)*)

        7. Let (fid, funcdef, id*)? be $find_func<funcdef>("apply", $to_fkey(arg*), ({ [(fid -> fd)] }))

        8. If ((fid, funcdef, id*)? matches pattern (_)), then

          1. Let ?((fid', funcdef, id_deft*)) be (fid, funcdef, id*)?

          2. If (fid' = fid), then

            1. If (funcdef = ((MonoFD ft) as funcdef)), then

              1. Result in ft, exprIL_b, [], id_deft*

            1. Else

              1. Phantom#1067

          2. Else

            1. Phantom#1068

        8. Else

          1. Phantom#1069

      2. Else If (objtyp matches pattern `ControlT%`), then

        1. Let (ControlT pt*) be objtyp

        2. Let ft be (ControlApplyMethodT pt*)

        3. Let fd be ((MonoFD ft) as funcdef)

        4. (Let (id_p _dir _typ val_deft?) be pt)*

        5. (Let b_deft be (val_deft? =/= ?()))*

        6. Let fid be ("apply" (id_p, b_deft)*)

        7. Let (fid, funcdef, id*)? be $find_func<funcdef>("apply", $to_fkey(arg*), ({ [(fid -> fd)] }))

        8. If ((fid, funcdef, id*)? matches pattern (_)), then

          1. Let ?((fid', funcdef, id_deft*)) be (fid, funcdef, id*)?

          2. If (fid' = fid), then

            1. If (funcdef = ((MonoFD ft) as funcdef)), then

              1. Result in ft, exprIL_b, [], id_deft*

            1. Else

              1. Phantom#1063

          2. Else

            1. Phantom#1064

        8. Else

          1. Phantom#1065

      2. Else

        1. Phantom#1066

    1. Else

      1. Phantom#1070

    2. If (arg*' matches pattern []), then

      1. If (typ has type objtyp), then

        1. Let objtyp be (typ as objtyp)

        2. If (objtyp matches pattern `TableT%%`), then

          1. Let (TableT id typ_t) be objtyp

          2. Let functyp be (TableApplyMethodT typ_t)

          3. Result in functyp, exprIL_b, [], []

        2. Else

          1. Phantom#1071

      1. Else

        1. Phantom#1072

    2. Else

      1. Phantom#1073

  1. Else

    1. Phantom#1074

10. Else

  1. Phantom#1075

;; ../../../../spec/4b-typing-relation.watsup:163.1-165.29
relation ConsType_ok: p, C, name, targIL*, arg*

1. Let (cid, consdef, id*)? be $find_consdef((GLOBAL), C, name, arg*)

2. If ((cid, consdef, id*)? matches pattern (_)), then

  1. Let ?((cid, cd, id_deft*)) be (cid, consdef, id*)?

  2. Let (ct, tid_fresh*) be $specialize_consdef(cd, targIL*)

  3. Result in ct, tid_fresh*, id_deft*

2. Else

  1. Phantom#1076

;; ../../../../spec/4b-typing-relation.watsup:171.1-173.23
relation Inst_site_ok: cursor, C, (ConsT pt* typ_i)

1. If (cursor matches pattern `GLOBAL`), then

  1. Let typ_i' be $canon_typ(typ_i)

  2. If ($is_externt(typ_i') \/ $is_packaget(typ_i')), then

    1. The relation holds

  2. Else

    1. Phantom#1084

1. Else If (cursor matches pattern `BLOCK`), then

  1. Let typ_i' be $canon_typ(typ_i)

  2. If (C.BLOCK.KIND matches pattern `PACKAGE`), then

    1. If ((($is_externt(typ_i') \/ $is_parsert(typ_i')) \/ $is_controlt(typ_i')) \/ $is_packaget(typ_i')), then

      1. The relation holds

    1. Else

      1. Phantom#1083

  2. Else If (C.BLOCK.KIND matches pattern `PARSER`), then

    1. If ($is_externt(typ_i') \/ $is_parsert(typ_i')), then

      1. The relation holds

    1. Else

      1. Phantom#1082

  2. Else If (C.BLOCK.KIND matches pattern `CONTROL`), then

    1. If (($is_externt(typ_i') \/ $is_controlt(typ_i')) \/ $is_tablet(typ_i')), then

      1. The relation holds

    1. Else

      1. Phantom#1080

  2. Else

    1. Phantom#1081

1. Else If (cursor matches pattern `LOCAL`), then

  1. Let typ_i' be $canon_typ(typ_i)

  2. If (C.LOCAL.KIND matches pattern `PARSERSTATE`), then

    1. If ($is_externt(typ_i') \/ $is_parsert(typ_i')), then

      1. The relation holds

    1. Else

      1. Phantom#1079

  2. Else If (C.LOCAL.KIND matches pattern `CONTROLAPPLYMETHOD`), then

    1. If ($is_externt(typ_i') \/ $is_controlt(typ_i')), then

      1. The relation holds

    1. Else

      1. Phantom#1077

  2. Else

    1. Phantom#1078

;; ../../../../spec/4b-typing-relation.watsup:174.1-176.35
relation Inst_ok: cursor', C_0', tid*', ct, targIL*, arg*, id_deft*

1. If (cursor' matches pattern `GLOBAL`), then

  1. If (tid*' matches pattern []), then

    1. Let (ConsT pt* typ_i) be ct

    2. If $is_packaget($canon_typ(typ_i)), then

      1. Let C_1 be $set_blockkind(C_0', (PACKAGE))

      2. (Arg_ok: (BLOCK) C_1 |- arg : argIL typ_a)*

      3. Let pt'* be $filter_default_args(pt*, id_deft*)

      4. If (|pt'*| = |argIL*|), then

        1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

        2. If (ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt* typ_i) holds), then

          1. If (Inst_site_ok: (GLOBAL) C_0' |- (ConsT pt* typ_i) :INSTSITE_OK holds), then

            1. (Call_convention_arg_ok: (BLOCK) C_1 (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

            2. Result in typ_i, targIL*, argIL''*

          1. Else

            1. Phantom#1085

        2. Else

          1. Phantom#1086

      4. Else

        1. Phantom#1087

    2. Else

      1. Phantom#1088

  1. Else

    1. Phantom#1089

1. Else

  1. Phantom#1090

2. Let tid_fresh* be tid*'

3. If (cursor' matches pattern `GLOBAL`), then

  1. Let (ConsT pt* typ_i) be ct

  2. If $is_packaget($canon_typ(typ_i)), then

    1. If (|tid_fresh*| > 0), then

      1. Let C_1 be $set_blockkind(C_0', (PACKAGE))

      2. (Arg_ok: (BLOCK) C_1 |- arg : argIL typ_a)*

      3. Let pt'* be $filter_default_args(pt*, id_deft*)

      4. If (|pt'*| = |argIL*|), then

        1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

        2. Let theta be $infer_targs(tid_fresh*, pt''*, typ_a*)

        3. (Let typ? be $find_map<tid, typ>(theta, tid_fresh))*

        4. If ((typ? matches pattern (_)))*, then

          1. (Let ?(targIL') be typ?)*

          2. Let targIL''* be targIL* ++ targIL'*

          3. Let (ConsT pt'''* typ_i') be $subst_constyp(theta, (ConsT pt''* typ_i))

          4. If (ConsType_wf: $bound_tids((GLOBAL), C_0') |- (ConsT pt'''* typ_i') holds), then

            1. If (Inst_site_ok: (GLOBAL) C_0' |- (ConsT pt'''* typ_i') :INSTSITE_OK holds), then

              1. (Call_convention_arg_ok: (BLOCK) C_1 (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

              2. Result in typ_i', targIL''*, argIL''*

            1. Else

              1. Phantom#1091

          4. Else

            1. Phantom#1092

        4. Else

          1. Phantom#1093

      4. Else

        1. Phantom#1094

    1. Else

      1. Phantom#1095

  2. Else

    1. Phantom#1096

3. Else

  1. Phantom#1097

4. If (tid*' matches pattern []), then

  1. Let (ConsT pt* typ_i) be ct

  2. If ~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i))), then

    1. (Arg_ok: cursor' C_0' |- arg : argIL typ_a)*

    2. Let pt'* be $filter_default_args(pt*, id_deft*)

    3. If (|pt'*| = |argIL*|), then

      1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

      2. If (ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt* typ_i) holds), then

        1. If (Inst_site_ok: cursor' C_0' |- (ConsT pt* typ_i) :INSTSITE_OK holds), then

          1. (Call_convention_arg_ok: cursor' C_0' (NOACT) |- pt'' ~~ (argIL, typ_a) : argIL'')*

          2. Result in typ_i, targIL*, argIL''*

        1. Else

          1. Phantom#1098

      2. Else

        1. Phantom#1099

    3. Else

      1. Phantom#1100

  2. Else

    1. Phantom#1101

4. Else

  1. Phantom#1102

5. Let (ConsT pt* typ_i) be ct

6. If ~((cursor' = (GLOBAL)) /\ $is_packaget($canon_typ(typ_i))), then

  1. (Arg_ok: cursor' C_0' |- arg : argIL typ_a)*

  2. Let pt'* be $filter_default_args(pt*, id_deft*)

  3. If (|pt'*| = |argIL*|), then

    1. Let pt''* be $align_params_with_args(pt'*, (argIL, typ_a)*)

    2. Let theta be $infer_targs(tid_fresh*, pt''*, typ_a*)

    3. (Let typ? be $find_map<tid, typ>(theta, tid_fresh))*

    4. If ((typ? matches pattern (_)))*, then

      1. (Let ?(targIL') be typ?)*

      2. Let targIL''* be targIL* ++ targIL'*

      3. Let (ConsT pt'''* typ_i') be $subst_constyp(theta, (ConsT pt''* typ_i))

      4. If (ConsType_wf: $bound_tids(cursor', C_0') |- (ConsT pt'''* typ_i') holds), then

        1. If (Inst_site_ok: cursor' C_0' |- (ConsT pt'''* typ_i') :INSTSITE_OK holds), then

          1. (Call_convention_arg_ok: cursor' C_0' (NOACT) |- pt''' ~~ (argIL, typ_a) : argIL'')*

          2. Result in typ_i', targIL*, argIL''*

        1. Else

          1. Phantom#1103

      4. Else

        1. Phantom#1104

    4. Else

      1. Phantom#1105

  3. Else

    1. Phantom#1106

6. Else

  1. Phantom#1107

;; ../../../../spec/4d2-typing-subtyping.watsup:312.1-313.34
def $reduce_senum_unary(exprIL, $check_unary)

1. Let (( typ ; _ctk )) be $annot(exprIL)

2. If $check_unary(typ), then

  1. Return exprIL

2. Else

  1. Phantom#1108

3. Let (( typ ; ctk )) be $annot(exprIL)

4. If ~$check_unary(typ), then

  1. Let typ'' be typ

  2. If (typ'' has type datatyp), then

    1. Let datatyp be (typ'' as datatyp)

    2. If (datatyp matches pattern `SEnumT%%%`), then

      1. Let (SEnumT _id typ' _(member, val)*) be datatyp

      2. Let exprIL' be (CastE typ' exprIL (( typ' ; ctk )))

      3. Let exprIL'' be $reduce_senum_unary(exprIL', $check_unary)

      4. Return exprIL''

    2. Else

      1. Phantom#1109

  2. Else

    1. Phantom#1110

4. Else

  1. Phantom#1111

;; ../../../../spec/4d2-typing-subtyping.watsup:327.1-328.41
def $reduce_senums_binary(exprIL_a, exprIL_b, $check_binary)

1. Let (( typ_a ; _ctk )) be $annot(exprIL_a)

2. Let (( typ_b ; _ctk' )) be $annot(exprIL_b)

3. If $check_binary(typ_a, typ_b), then

  1. Return (exprIL_a, exprIL_b)

3. Else

  1. Phantom#1112

4. Let (( typ_a ; ctk_a )) be $annot(exprIL_a)

5. Let (( typ_b ; _ctk )) be $annot(exprIL_b)

6. If ~$check_binary(typ_a, typ_b), then

  1. Let typ be typ_a

  2. If (typ has type datatyp), then

    1. Let datatyp be (typ as datatyp)

    2. If (datatyp matches pattern `SEnumT%%%`), then

      1. Let (SEnumT _id typ_a' _(member, val)*) be datatyp

      2. Let exprIL_a' be (CastE typ_a' exprIL_a (( typ_a' ; ctk_a )))

      3. Let (exprIL_a'', exprIL_b'') be $reduce_senums_binary(exprIL_a', exprIL_b, $check_binary)

      4. Return (exprIL_a'', exprIL_b'')

    2. Else

      1. Phantom#1113

  2. Else

    1. Phantom#1114

6. Else

  1. Phantom#1115

7. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

8. If ~$check_binary(typ_a, typ_b), then

  1. Let typ be typ_b

  2. If (typ has type datatyp), then

    1. Let datatyp be (typ as datatyp)

    2. If (datatyp matches pattern `SEnumT%%%`), then

      1. Let (SEnumT _id typ_b' _(member, val)*) be datatyp

      2. Let exprIL_b' be (CastE typ_b' exprIL_b (( typ_b' ; ctk_b )))

      3. Let (exprIL_a'', exprIL_b'') be $reduce_senums_binary(exprIL_a, exprIL_b', $check_binary)

      4. Return (exprIL_a'', exprIL_b'')

    2. Else

      1. Phantom#1116

  2. Else

    1. Phantom#1117

8. Else

  1. Phantom#1118

;; ../../../../spec/4d2-typing-subtyping.watsup:353.1-354.32
def $coerce_binary(exprIL_a, exprIL_b)

1. Let (( typ_a ; _ctk )) be $annot(exprIL_a)

2. Let (( typ_b ; _ctk' )) be $annot(exprIL_b)

3. If (Type_alpha: typ_a ~~ typ_b holds), then

  1. Return (exprIL_a, exprIL_b)

3. Else

  1. Phantom#1119

4. Let (( typ_a ; ctk_a )) be $annot(exprIL_a)

5. Let (( typ_b ; _ctk )) be $annot(exprIL_b)

6. If ~(Type_alpha: typ_a ~~ typ_b holds), then

  1. If (Sub_impl: typ_a << typ_b holds), then

    1. Let exprIL_a' be (CastE typ_b exprIL_a (( typ_b ; ctk_a )))

    2. Return (exprIL_a', exprIL_b)

  1. Else

    1. Phantom#1120

6. Else

  1. Phantom#1121

7. Let (( typ_b ; ctk_b )) be $annot(exprIL_b)

8. If ~(Type_alpha: typ_a ~~ typ_b holds), then

  1. If ~(Sub_impl: typ_a << typ_b holds), then

    1. If (Sub_impl: typ_b << typ_a holds), then

      1. Let exprIL_b' be (CastE typ_a exprIL_b (( typ_a ; ctk_b )))

      2. Return (exprIL_a, exprIL_b')

    1. Else

      1. Phantom#1122

  1. Else

    1. Phantom#1123

8. Else

  1. Phantom#1124

;; ../../../../spec/4d2-typing-subtyping.watsup:377.1-378.31
def $coerce_assign(exprIL, typ_t)

1. Let (( typ_f ; _ctk )) be $annot(exprIL)

2. If (Type_alpha: typ_f ~~ typ_t holds), then

  1. Return exprIL

2. Else

  1. Phantom#1125

3. Let (( typ_f ; ctk_f )) be $annot(exprIL)

4. If ~(Type_alpha: typ_f ~~ typ_t holds), then

  1. If (Sub_impl: typ_f << typ_t holds), then

    1. Return (CastE typ_t exprIL (( typ_t ; ctk_f )))

  1. Else

    1. Phantom#1126

4. Else

  1. Phantom#1127

;; ../../../../spec/4e-typing-expr.watsup:88.1-88.33
def $compatible_bnot(typ)

1. Return $compatible'_bnot($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:89.1-89.34
def $compatible'_bnot(typ)

1. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:103.1-103.33
def $compatible_lnot(typ)

1. Return $compatible'_lnot($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:104.1-104.34
def $compatible'_lnot(typ)

1. If (typ = ((BoolT) as typ)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:117.1-117.34
def $compatible_uplus(typ)

1. Return $compatible'_uplus($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:118.1-118.35
def $compatible'_uplus(typ)

1. If (typ = ((IntT) as typ)), then

  1. Return true

2. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:133.1-133.35
def $compatible_uminus(typ)

1. Return $compatible'_uminus($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:134.1-134.36
def $compatible'_uminus(typ)

1. If (typ = ((IntT) as typ)), then

  1. Return true

2. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:153.1-153.47
def $compatible_plusminusmult(typ_l, typ_r)

1. Return $compatible'_plusminusmult($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:154.1-154.48
def $compatible'_plusminusmult(typ'', typ''')

1. If (typ'' = ((IntT) as typ)), then

  1. If (typ''' = ((IntT) as typ)), then

    1. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:179.1-179.46
def $compatible_satplusminus(typ_l, typ_r)

1. Return $compatible'_satplusminus($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:180.1-180.47
def $compatible'_satplusminus(typ'', typ''')

1. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:204.1-204.40
def $compatible_divmod(typ_l, typ_r)

1. Return $compatible'_divmod($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:205.1-205.41
def $compatible'_divmod(typ'', typ''')

1. If (typ'' = ((IntT) as typ)), then

  1. If (typ''' = ((IntT) as typ)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:249.1-249.39
def $compatible_shift(typ_l, typ_r)

1. Return $compatible'_shift($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:250.1-250.40
def $compatible'_shift(typ'', typ''')

1. If (typ'' = ((IntT) as typ)), then

  1. If (typ''' = ((IntT) as typ)), then

    1. Return true

  2. If (typ''' has type numtyp), then

    1. Let numtyp be (typ''' as numtyp)

    2. If (numtyp matches pattern `FIntT%`), then

      1. Let (FIntT _width) be numtyp

      2. Return true

    2. Else If (numtyp matches pattern `FBitT%`), then

      1. Let (FBitT _width) be numtyp

      2. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. If (typ''' = ((IntT) as typ)), then

      1. Return true

    3. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT _width') be numtyp'

        2. Return true

      2. Else If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT _width') be numtyp'

        2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. If (typ''' = ((IntT) as typ)), then

      1. Return true

    3. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT _width') be numtyp'

        2. Return true

      2. Else If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT _width') be numtyp'

        2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:296.1-296.41
def $compatible_compare(typ_l, typ_r)

1. Return $compatible'_compare($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:297.1-297.42
def $compatible'_compare(typ'', typ''')

1. If (typ'' = ((IntT) as typ)), then

  1. If (typ''' = ((IntT) as typ)), then

    1. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:322.1-322.41
def $compatible_bitwise(typ_l, typ_r)

1. Return $compatible'_bitwise($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:323.1-323.42
def $compatible'_bitwise(typ'', typ''')

1. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:347.1-347.40
def $compatible_concat(typ_l, typ_r)

1. Return $compatible'_concat($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:348.1-348.41
def $compatible'_concat(typ'', typ''')

1. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT _width') be numtyp'

        2. Return true

      2. Else If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT _width') be numtyp'

        2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT _width') be numtyp'

        2. Return true

      2. Else If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT _width') be numtyp'

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:391.1-391.41
def $compatible_logical(typ_l, typ_r)

1. Return $compatible'_logical($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:392.1-392.42
def $compatible'_logical(typ'', typ''')

1. If (typ'' = ((BoolT) as typ)), then

  1. If (typ''' = ((BoolT) as typ)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:453.1-453.38
def $compatible_mask(typ_l, typ_r)

1. Return $compatible'_mask($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:454.1-454.39
def $compatible'_mask(typ'', typ''')

1. If (typ'' = ((IntT) as typ)), then

  1. If (typ''' = ((IntT) as typ)), then

    1. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:481.1-481.39
def $compatible_range(typ_l, typ_r)

1. Return $compatible'_range($canon_typ(typ_l), $canon_typ(typ_r))

;; ../../../../spec/4e-typing-expr.watsup:482.1-482.40
def $compatible'_range(typ'', typ''')

1. If (typ'' = ((IntT) as typ)), then

  1. If (typ''' = ((IntT) as typ)), then

    1. Return true

2. If (typ'' has type numtyp), then

  1. Let numtyp be (typ'' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FIntT%`), then

        1. Let (FIntT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. If (typ''' has type numtyp), then

      1. Let numtyp' be (typ''' as numtyp)

      2. If (numtyp' matches pattern `FBitT%`), then

        1. Let (FBitT nat) be numtyp'

        2. If (w = nat), then

          1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:508.1-510.26
relation Select_case_keyset_ok: cursor, C, typ_k, keyset

1. If (cursor matches pattern `LOCAL`), then

  1. If (keyset matches pattern `ExprK%`), then

    1. Let (ExprK expr) be keyset

    2. Expr_ok: (LOCAL) C |- expr : exprIL

    3. Let (( typ' ; _ctk )) be $annot(exprIL)

    4. If (typ' has type synthtyp), then

      1. Let synthtyp be (typ' as synthtyp)

      2. If (synthtyp matches pattern `SetT%`), then

        1. Let (SetT typ) be synthtyp

        2. If (Type_alpha: typ ~~ typ_k holds), then

          1. Result in (ExprK exprIL)

        2. Else If ~(Type_alpha: typ ~~ typ_k holds), then

          1. If (Sub_impl: typ << typ_k holds), then

            1. Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; (DYN) )))

            2. Result in (ExprK exprIL')

          1. Else

            1. Phantom#1128

      2. Else

        1. Phantom#1129

    4. Else

      1. Phantom#1130

    5. Let (( typ ; _ctk )) be $annot(exprIL)

    6. If (Sub_impl: typ << typ_k holds), then

      1. Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; (DYN) )))

      2. Result in (ExprK exprIL')

    6. Else

      1. Phantom#1131

  1. Else If (keyset matches pattern `DefaultK`), then

    1. Result in (DefaultK)

  1. Else If (keyset matches pattern `AnyK`), then

    1. Result in (AnyK)

1. Else

  1. Phantom#1132

;; ../../../../spec/4e-typing-expr.watsup:543.1-545.26
relation Select_case_keysets_ok: p, C, typ*', keyset*'

1. If (typ*' matches pattern [ _/1 ]), then

  1. Let [typ_k] be typ*'

  2. If (keyset*' matches pattern [ _/1 ]), then

    1. Let [keyset] be keyset*'

    2. Select_case_keyset_ok: p C typ_k |- keyset : keysetIL

    3. Result in [keysetIL]

  2. Else

    1. Phantom#1133

1. Else

  1. Phantom#1134

2. Let typ_k* be typ*'

3. If (keyset*' matches pattern [ _/1 ]), then

  1. Let [keyset] be keyset*'

  2. Select_case_keyset_ok: p C ((SeqT typ_k*) as typ) |- keyset : keysetIL

  3. Result in [keysetIL]

3. Else

  1. Phantom#1135

4. Let keyset* be keyset*'

5. If (|typ_k*| = |keyset*|), then

  1. (Select_case_keyset_ok: p C typ_k |- keyset : keysetIL)*

  2. Result in keysetIL*

5. Else

  1. Phantom#1136

;; ../../../../spec/4e-typing-expr.watsup:561.1-563.26
relation Select_case_ok: cursor, C, typ_k*, (keyset* statelabel)

1. If (cursor matches pattern `LOCAL`), then

  1. Select_case_keysets_ok: (LOCAL) C |- typ_k* keyset* : keysetIL*

  2. Let styp? be $find_styp((LOCAL), C, (CURRENT statelabel))

  3. If (styp? matches pattern (_)), then

    1. Let ?((typ dir'' ctk'' val?)) be styp?

    2. If (typ = ((StateT) as typ)), then

      1. If (val? matches pattern ()), then

        1. Result in (keysetIL* statelabel)

      1. Else

        1. Phantom#1137

    2. Else

      1. Phantom#1138

  3. Else

    1. Phantom#1139

1. Else

  1. Phantom#1140

;; ../../../../spec/4e-typing-expr.watsup:585.1-585.39
def $compatible_arrayindex(typ)

1. Return $compatible'_arrayindex($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:586.1-586.40
def $compatible'_arrayindex(typ)

1. If (typ = ((IntT) as typ)), then

  1. Return true

2. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:642.1-642.42
def $compatible_bitstringbase(typ)

1. Return $compatible'_bitstringbase($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:643.1-643.43
def $compatible'_bitstringbase(typ)

1. If (typ = ((IntT) as typ)), then

  1. Return true

2. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. Return (w > 0)

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:652.1-652.43
def $compatible_bitstringindex(typ)

1. Return $compatible'_bitstringindex($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:653.1-653.44
def $compatible'_bitstringindex(typ)

1. If (typ = ((IntT) as typ)), then

  1. Return true

2. If (typ has type numtyp), then

  1. Let numtyp be (typ as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT _width) be numtyp

    2. Return true

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT _width) be numtyp

    2. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:662.1-662.52
def $is_valid_bitstring_slice(typ, n_l, n_h)

1. Return ((n_l <= n_h) /\ $is_valid_bitstring_slice'($canon_typ(typ), n_l, n_h))

;; ../../../../spec/4e-typing-expr.watsup:663.1-663.53
def $is_valid_bitstring_slice'(typ', _nat'', _nat''')

1. If (typ' = ((IntT) as typ)), then

  1. Return true

2. If (typ' has type numtyp), then

  1. Let numtyp be (typ' as numtyp)

  2. If (numtyp matches pattern `FIntT%`), then

    1. Let (FIntT w) be numtyp

    2. Let w_slice be ((_nat''' - _nat'') + 1)

    3. Return ((_nat''' <= w) /\ (w_slice <= w))

  2. Else If (numtyp matches pattern `FBitT%`), then

    1. Let (FBitT w) be numtyp

    2. Let w_slice be ((_nat''' - _nat'') + 1)

    3. Return ((_nat''' <= w) /\ (w_slice <= w))

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:855.1-855.44
def $not_abstract_extern_object(typ)

1. Return $not_abstract_extern_object'($canon_typ(typ))

;; ../../../../spec/4e-typing-expr.watsup:856.1-856.45
def $not_abstract_extern_object'(typ)

1. If ~$is_externt(typ), then

  1. Return true

2. If (typ has type objtyp), then

  1. Let objtyp be (typ as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT _id fmap) be objtyp

    2. Let ({ fid* }) be $dom_map<fid, funcdef>(fmap)

    3. (Let funcdef? be $find_map<fid, funcdef>(fmap, fid))*

    4. If ((funcdef? matches pattern (_)))*, then

      1. (Let ?(fd) be funcdef?)*

      2. If ($not_abstract_extern_object''(fd))*, then

        1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec/4e-typing-expr.watsup:857.1-857.50
def $not_abstract_extern_object''(funcdef')

1. If (funcdef' has type polyfuncdef), then

  1. Let (PolyFD (_tparam*, _tparam*') -> functyp) be (funcdef' as polyfuncdef)

  2. If (functyp matches pattern `ExternAbstractMethodT%%`), then

    1. Let (ExternAbstractMethodT _paramtyp* _typ) be functyp

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec/4f-typing-stmt.watsup:45.1-47.29
relation Switch_tbl_label_ok: p, C, id_t, b_last', switchlabel

1. If (switchlabel matches pattern `ExprL%`), then

  1. Let (ExprL expr) be switchlabel

  2. If (expr matches pattern `NameE%`), then

    1. Let (NameE name) be expr

    2. If (name matches pattern `CURRENT%`), then

      1. Let (CURRENT id_a) be name

      2. Let id_e be $concat_text(["action_list(", id_t, ")"])

      3. Let id be $concat_text([id_e, ".", id_a])

      4. If (?((TableEnumFieldV id_e id_a)) = $find_val(p, C, (CURRENT id))), then

        1. Let styp? be $find_styp(p, C, (CURRENT id))

        2. If (styp? matches pattern (_)), then

          1. Let ?((typ_e _dir ctk_e _val?)) be styp?

          2. Result in (ExprL (NameE (CURRENT id_a) (( typ_e ; ctk_e ))))

        2. Else

          1. Phantom#1141

      4. Else

        1. Phantom#1142

    2. Else

      1. Phantom#1143

  2. Else

    1. Phantom#1144

1. Else

  1. Phantom#1145

2. If (b_last' = true), then

  1. If (switchlabel matches pattern `DefaultL`), then

    1. Result in (DefaultL)

  1. Else

    1. Phantom#1146

2. Else

  1. Phantom#1147

;; ../../../../spec/4f-typing-stmt.watsup:60.1-62.32
relation Switch_tbl_case_ok: p, C, f, id_t, b_last, switchcase

1. If (switchcase matches pattern `MatchC%%`), then

  1. Let (MatchC switchlabel block) be switchcase

  2. Switch_tbl_label_ok: p C id_t b_last |- switchlabel : switchlabelIL

  3. Block_ok: p C f (NOINIT) |- block : C' f' blockIL

  4. Result in f', (MatchC switchlabelIL blockIL), switchlabel

1. Else If (switchcase matches pattern `FallC%`), then

  1. Let (FallC switchlabel) be switchcase

  2. Switch_tbl_label_ok: p C id_t b_last |- switchlabel : switchlabelIL

  3. Result in f, (FallC switchlabelIL), switchlabel

;; ../../../../spec/4f-typing-stmt.watsup:74.1-76.29
relation Switch_tbl_cases_ok: p, C, f, id_t, switchcase*

1. If (switchcase* matches pattern []), then

  1. Result in f, [], []

1. Else If (switchcase* matches pattern _ :: _), then

  1. Let switchcase_h :: switchcase_t* be switchcase*

  2. Let b_last be (switchcase_t* = [])

  3. Switch_tbl_case_ok: p C f id_t b_last |- switchcase_h : f' switchcaseIL_h switchlabel_h

  4. Switch_tbl_cases_ok: p C f' id_t |- switchcase_t* : f'' switchcaseIL_t* switchlabel_t*

  5. Result in f'', switchcaseIL_h :: switchcaseIL_t*, switchlabel_h :: switchlabel_t*

;; ../../../../spec/4f-typing-stmt.watsup:98.1-100.29
relation Switch_gen_label_ok: p, C, typ_s, b_last', switchlabel

1. If (switchlabel matches pattern `ExprL%`), then

  1. Let (ExprL expr) be switchlabel

  2. Expr_ok: p C |- expr : exprIL

  3. Let (( _typ ; ctk )) be $annot(exprIL)

  4. If (ctk matches pattern `LCTK`), then

    1. Let exprIL' be $coerce_assign(exprIL, typ_s)

    2. Result in (ExprL exprIL')

  4. Else

    1. Phantom#1148

1. Else

  1. Phantom#1149

2. If (b_last' = true), then

  1. If (switchlabel matches pattern `DefaultL`), then

    1. Result in (DefaultL)

  1. Else

    1. Phantom#1150

2. Else

  1. Phantom#1151

;; ../../../../spec/4f-typing-stmt.watsup:112.1-114.32
relation Switch_gen_case_ok: p, C, f, typ_s, b_last, switchcase

1. If (switchcase matches pattern `MatchC%%`), then

  1. Let (MatchC switchlabel block) be switchcase

  2. Switch_gen_label_ok: p C typ_s b_last |- switchlabel : switchlabelIL

  3. Block_ok: p C f (NOINIT) |- block : C' f' blockIL

  4. Result in f', (MatchC switchlabelIL blockIL), switchlabel

1. Else If (switchcase matches pattern `FallC%`), then

  1. Let (FallC switchlabel) be switchcase

  2. Switch_gen_label_ok: p C typ_s b_last |- switchlabel : switchlabelIL

  3. Result in f, (FallC switchlabelIL), switchlabel

;; ../../../../spec/4f-typing-stmt.watsup:126.1-128.29
relation Switch_gen_cases_ok: p, C, f, typ_s, switchcase*

1. If (switchcase* matches pattern []), then

  1. Result in f, [], []

1. Else If (switchcase* matches pattern _ :: _), then

  1. Let switchcase_h :: switchcase_t* be switchcase*

  2. Let b_last be (switchcase_t* = [])

  3. Switch_gen_case_ok: p C f typ_s b_last |- switchcase_h : f' switchcaseIL_h switchlabel_h

  4. Switch_gen_cases_ok: p C f' typ_s |- switchcase_t* : f'' switchcaseIL_t* switchlabel_t*

  5. Result in f'', switchcaseIL_h :: switchcaseIL_t*, switchlabel_h :: switchlabel_t*

;; ../../../../spec/4g-typing-decl.watsup:88.1-90.29
relation Inst_init_decl_ok: p, C'', frame, fdenv, decl''

1. If (decl'' matches pattern `InstD%%%%%`), then

  1. Let (InstD id' name targ* arg* decl*) be decl''

  2. Decl_ok: p C'' |- (InstD id' name targ* arg* decl*) : C' declIL

  3. Let styp? be $find_styp(p, C', (CURRENT id'))

  4. If (styp? matches pattern (_)), then

    1. Let ?(styp') be styp?

    2. Let frame' be $update_map<id, styp>(frame, id', styp')

    3. Result in frame', fdenv, declIL

  4. Else

    1. Phantom#1156

1. Else If (decl'' matches pattern `FuncD%%%%%`), then

  1. Let (FuncD id type_r tparam* param* block) be decl''

  2. Let fid be $to_fid(id, param*)

  3. Let C_1 be $set_blockkind(C'', (EXTERN))

  4. Let C_2 be C_1[BLOCK.FRAME = frame]

  5. Let C_3 be $add_tparams((LOCAL), C_2, tparam*)

  6. Type_ok: (LOCAL) C_3 |- type_r : typ_r tid*

  7. If (tid* matches pattern []), then

    1. Let C_4 be $set_localkind(C_3, (EXTERNABSTRACTMETHOD typ_r))

    2. (Param_ok: (LOCAL) C_4 |- param : paramIL tid_fresh_p*)*

    3. Let tparam_hidden* be $concat_<tid>(tid_fresh_p**)

    4. Let C_5 be $add_params((LOCAL), C_4, (paramIL* as paramtyp*))

    5. Let C_6 be $add_tparams((LOCAL), C_5, tparam_hidden*)

    6. Block_ok: (LOCAL) C_6 (CONT) (INIT) |- block : C_7 f blockIL

    7. If ((f = (RET)) \/ (typ_r = ((VoidT) as typ))), then

      1. Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT (paramIL* as paramtyp*) typ_r)) as funcdef)

      2. If (FuncDef_wf: $bound_tids(p, C'') |- fd holds), then

        1. Let fdenv' be $update_map<fid, funcdef>(fdenv, fid, fd)

        2. Result in frame, fdenv', (FuncD id typ_r tparam* tparam_hidden* paramIL* blockIL)

      2. Else

        1. Phantom#1152

    7. Else

      1. Phantom#1153

  7. Else

    1. Phantom#1154

1. Else

  1. Phantom#1155

;; ../../../../spec/4g-typing-decl.watsup:128.1-130.26
relation Inst_init_decls_ok: C, frame, fdenv, decl*

1. If (decl* matches pattern []), then

  1. Result in frame, fdenv, []

1. Else If (decl* matches pattern _ :: _), then

  1. Let decl_h :: decl_t* be decl*

  2. Inst_init_decl_ok: (GLOBAL) C frame fdenv |- decl_h : frame' fdenv' declIL_h

  3. Inst_init_decls_ok: C frame' fdenv' |- decl_t* : frame'' fdenv'' declIL_t*

  4. Result in frame'', fdenv'', declIL_h :: declIL_t*

;; ../../../../spec/4g-typing-decl.watsup:141.1-142.109
def $update_fdenv_extern(fdenv_ext, theta, fid*, funcdef*)

1. If (fid* matches pattern []), then

  1. If (funcdef* matches pattern []), then

    1. Return fdenv_ext

  1. Else

    1. Phantom#1162

1. Else If (fid* matches pattern _ :: _), then

  1. Let fid_h :: fid_t* be fid*

  2. If (funcdef* matches pattern _ :: _), then

    1. Let fd_h :: fd_t* be funcdef*

    2. Let funcdef? be $find_map<fid, funcdef>(fdenv_ext, fid_h)

    3. If (funcdef? matches pattern (_)), then

      1. Let ?(funcdef) be funcdef?

      2. If (funcdef has type polyfuncdef), then

        1. Let (PolyFD (tparam*, tparam_hidden*) -> functyp) be (funcdef as polyfuncdef)

        2. If (functyp matches pattern `ExternAbstractMethodT%%`), then

          1. Let (ExternAbstractMethodT pt* typ_r) be functyp

          2. Let fd_ext be ((PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT pt* typ_r)) as funcdef)

          3. Let fd_ext' be $subst_funcdef(theta, fd_ext)

          4. If (FuncDef_alpha: fd_ext' ~~ fd_h holds), then

            1. Let fdenv_ext' be $update_map<fid, funcdef>(fdenv_ext, fid_h, fd_ext')

            2. Return $update_fdenv_extern(fdenv_ext', theta, fid_t*, fd_t*)

          4. Else

            1. Phantom#1157

        2. Else

          1. Phantom#1158

      2. Else

        1. Phantom#1159

    3. Else

      1. Phantom#1160

  2. Else

    1. Phantom#1161

;; ../../../../spec/4g-typing-decl.watsup:291.1-293.32
relation SEnum_field_ok: C, id_s, typ_s, (member_s, val_s)*, member, expr

1. Expr_ok: (BLOCK) C |- expr : exprIL

2. Let (( _typ ; ctk )) be $annot(exprIL)

3. If (ctk matches pattern `LCTK`), then

  1. Let exprIL' be $coerce_assign(exprIL, typ_s)

  2. Eval_static: (BLOCK) C |- exprIL' ~> val_e

  3. Let val be (SEnumFieldV id_s member val_e)

  4. Let member_s'* be member_s* ++ [member]

  5. Let val_s'* be val_s* ++ [val]

  6. Let typ_f be ((SEnumT id_s typ_s (member_s', val_s')*) as typ)

  7. Let C' be $add_styp((BLOCK), C, member, (typ_f (NO) (LCTK) ?(val)))

  8. Result in C', (member_s', val_s')*

3. Else

  1. Phantom#1163

;; ../../../../spec/4g-typing-decl.watsup:311.1-313.29
relation SEnum_fields_ok: C, id, typ, (member, val)*, (member, expr)*

1. If ((member, expr)* matches pattern []), then

  1. Result in C, (member, val)*

1. Else If ((member, expr)* matches pattern _ :: _), then

  1. Let (member_h, expr_h) :: (member_t, expr_t)* be (member, expr)*

  2. SEnum_field_ok: C id typ (member, val)* |- member_h expr_h : C' (member', val')*

  3. SEnum_fields_ok: C' id typ (member', val')* |- (member_t, expr_t)* : C'' (member'', val'')*

  4. Result in C'', (member'', val'')*

;; ../../../../spec/4g-typing-decl.watsup:500.1-500.49
def $split_methods(method*)

1. If (method* matches pattern []), then

  1. Return ([], [])

1. Else If (method* matches pattern _ :: _), then

  1. Let method_h :: method_t* be method*

  2. Let method be method_h

  3. If (method matches pattern `ExternConsM%%`), then

    1. Let (ExternConsM _id _cparam*) be method

    2. Let (method_c*, method_m*) be $split_methods(method_t*)

    3. Return (method_h :: method_c*, method_m*)

  3. Else If (method matches pattern `ExternM%%%%`), then

    1. Let (ExternM _id _type _tparam* _param*) be method

    2. Let (method_c*, method_m*) be $split_methods(method_t*)

    3. Return (method_c*, method_h :: method_m*)

  3. Else If (method matches pattern `ExternAbstractM%%%%`), then

    1. Let (ExternAbstractM _id _type _tparam* _param*) be method

    2. Let (method_c*, method_m*) be $split_methods(method_t*)

    3. Return (method_c*, method_h :: method_m*)

  3. Else

    1. Phantom#1164

;; ../../../../spec/4g-typing-decl.watsup:514.1-516.23
relation Method_ok: C'', id_e, method

1. If (method matches pattern `ExternConsM%%`), then

  1. Let (ExternConsM id cparam*) be method

  2. If (id_e = id), then

    1. Let cid be $to_fid(id_e, cparam*)

    2. (CParam_ok: (BLOCK) C'' |- cparam : cparamIL tid_fresh_c*)*

    3. (Let (id_c dir_c typ_c val_c?) be cparamIL)*

    4. Let tparam_hidden* be $concat_<tid>(tid_fresh_c**)

    5. Let typdef? be $find_typdef((GLOBAL), C'', (CURRENT id_e))

    6. If (typdef? matches pattern (_)), then

      1. Let ?(typdef) be typdef?

      2. If (typdef has type polytypdef), then

        1. Let (PolyD (tparam_e*, tparam*) -> typ_e) be (typdef as polytypdef)

        2. If (tparam* matches pattern []), then

          1. Let typ be ((SpecT (PolyD (tparam_e*, []) -> typ_e) ((VarT tparam_e) as typ)*) as typ)

          2. Let cd be (ConsD (tparam_e*, tparam_hidden*) -> (ConsT (id_c dir_c typ_c val_c?)* typ))

          3. If (ConsDef_wf: $bound_tids((BLOCK), C'') |- cd holds), then

            1. Let C' be $add_consdef((GLOBAL), C'', cid, cd)

            2. Result in C', (ExternConsM id_e tparam_hidden* cparamIL*)

          3. Else

            1. Phantom#1171

        2. Else

          1. Phantom#1172

      2. Else

        1. Phantom#1173

    6. Else

      1. Phantom#1174

  2. Else

    1. Phantom#1175

1. Else If (method matches pattern `ExternAbstractM%%%%`), then

  1. Let (ExternAbstractM id type_r tparam* param*) be method

  2. If (id_e =/= id), then

    1. Let fid be $to_fid(id, param*)

    2. Let C_1 be $add_typdefs((LOCAL), C'', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    3. Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*

    4. If (tid* matches pattern []), then

      1. Let C_2 be $set_localkind(C_1, (EXTERNABSTRACTMETHOD typ_r))

      2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

      3. Let tparam_hidden* be $concat_<tid>(tid_fresh_p**)

      4. Let C_3 be $add_params((LOCAL), C_2, (paramIL* as paramtyp*))

      5. Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (ExternAbstractMethodT (paramIL* as paramtyp*) typ_r)) as funcdef)

      6. If (FuncDef_wf: $bound_tids((BLOCK), C'') |- fd holds), then

        1. Let C_4 be $add_funcdef((BLOCK), C'', fid, fd)

        2. Result in C_4, (ExternAbstractM id typ_r tparam* tparam_hidden* paramIL*)

      6. Else

        1. Phantom#1168

    4. Else

      1. Phantom#1169

  2. Else

    1. Phantom#1170

1. Else If (method matches pattern `ExternM%%%%`), then

  1. Let (ExternM id type_r tparam* param*) be method

  2. If (id_e =/= id), then

    1. Let fid be $to_fid(id, param*)

    2. Let C_1 be $add_typdefs((LOCAL), C'', tparam*, ((MonoD ((VarT tparam) as typ)) as typdef)*)

    3. Type_ok: (LOCAL) C_1 |- type_r : typ_r tid*

    4. If (tid* matches pattern []), then

      1. Let C_2 be $set_localkind(C_1, (EXTERNMETHOD))

      2. (Param_ok: (LOCAL) C_2 |- param : paramIL tid_fresh_p*)*

      3. (Let (id_p dir_p typ_p val_p?) be paramIL)*

      4. Let tparam_hidden* be $concat_<tid>(tid_fresh_p**)

      5. Let C_3 be $add_params((LOCAL), C_2, (paramIL* as paramtyp*))

      6. Let fd be ((PolyFD (tparam*, tparam_hidden*) -> (ExternMethodT (paramIL* as paramtyp*) typ_r)) as funcdef)

      7. If (FuncDef_wf: $bound_tids((BLOCK), C'') |- fd holds), then

        1. Let C_4 be $add_funcdef((BLOCK), C'', fid, fd)

        2. Result in C_4, (ExternM id typ_r tparam* tparam_hidden* paramIL*)

      7. Else

        1. Phantom#1165

    4. Else

      1. Phantom#1166

  2. Else

    1. Phantom#1167

;; ../../../../spec/4g-typing-decl.watsup:580.1-582.23
relation Methods_ok: C, id_e, method*

1. If (method* matches pattern []), then

  1. Result in C, []

1. Else If (method* matches pattern _ :: _), then

  1. Let method_h :: method_t* be method*

  2. Method_ok: C id_e |- method_h : C' methodIL_h

  3. Methods_ok: C' id_e |- method_t* : C'' methodIL_t*

  4. Result in C'', methodIL_h :: methodIL_t*

;; ../../../../spec/4g-typing-decl.watsup:652.1-654.20
relation ParserState_ok: C, (statelabel block)

1. Block_ok: (LOCAL) C (CONT) (INIT) |- block : C' flow blockIL

2. If (flow matches pattern `CONT`), then

  1. Result in (statelabel blockIL)

2. Else

  1. Phantom#1176

;; ../../../../spec/4g-typing-decl.watsup:713.1-715.26
relation Table_key_ok: p, C, tblctx, (expr matchkind)

1. Expr_ok: p C |- expr : exprIL

2. Let (( typ ; _ctk )) be $annot(exprIL)

3. If (Type_wf: $bound_tids(p, C) |- ((SetT typ) as typ) holds), then

  1. If (?((MatchKindV matchkind)) = $find_val(p, C, (CURRENT matchkind))), then

    1. If $check_table_key(matchkind, typ), then

      1. Let tblctx' be $update_mode(matchkind, typ, tblctx)

      2. Let tblctx'' be $add_key((typ, matchkind), tblctx')

      3. Result in tblctx'', (exprIL matchkind)

    1. Else

      1. Phantom#1177

  1. Else

    1. Phantom#1178

3. Else

  1. Phantom#1179

;; ../../../../spec/4g-typing-decl.watsup:717.1-717.44
def $check_table_key(matchkind, typ)

1. If (matchkind = "exact"), then

  1. Let typ' be $canon_typ(typ)

  2. If $is_errt(typ'), then

    1. Return true

  3. If $is_boolt(typ'), then

    1. Return true

  4. If $is_intt(typ'), then

    1. Return true

  5. If $is_fintt(typ'), then

    1. Return true

  6. If $is_fbitt(typ'), then

    1. Return true

  7. If $is_vbitt(typ'), then

    1. Return true

  8. If $is_enumt(typ'), then

    1. Return true

  9. Let typ'' be $canon_typ(typ)

  10. If (typ'' has type datatyp), then

    1. Let datatyp be (typ'' as datatyp)

    2. If (datatyp matches pattern `SEnumT%%%`), then

      1. Let (SEnumT _id typ' _(member, val)*) be datatyp

      2. Return $check_table_key(matchkind, typ')

    2. Else If (datatyp matches pattern `NewT%%`), then

      1. Let (NewT _id typ') be datatyp

      2. Return $check_table_key(matchkind, typ')

1. Else If (matchkind = "optional"), then

  1. Let typ' be $canon_typ(typ)

  2. If $is_errt(typ'), then

    1. Return true

  3. If $is_boolt(typ'), then

    1. Return true

  4. If $is_intt(typ'), then

    1. Return true

  5. If $is_fintt(typ'), then

    1. Return true

  6. If $is_fbitt(typ'), then

    1. Return true

  7. If $is_vbitt(typ'), then

    1. Return true

  8. If $is_enumt(typ'), then

    1. Return true

  9. Let typ'' be $canon_typ(typ)

  10. If (typ'' has type datatyp), then

    1. Let datatyp be (typ'' as datatyp)

    2. If (datatyp matches pattern `SEnumT%%%`), then

      1. Let (SEnumT _id typ' _(member, val)*) be datatyp

      2. Return $check_table_key(matchkind, typ')

    2. Else If (datatyp matches pattern `NewT%%`), then

      1. Let (NewT _id typ') be datatyp

      2. Return $check_table_key(matchkind, typ')

1. Else If (matchkind = "lpm"), then

  1. Let typ' be $canon_typ(typ)

  2. If $is_intt(typ'), then

    1. Return true

  3. If $is_fintt(typ'), then

    1. Return true

  4. If $is_fbitt(typ'), then

    1. Return true

  5. Let typ'' be $canon_typ(typ)

  6. If (typ'' has type datatyp), then

    1. Let datatyp be (typ'' as datatyp)

    2. If (datatyp matches pattern `SEnumT%%%`), then

      1. Let (SEnumT _id typ' _(member, val)*) be datatyp

      2. Return $check_table_key(matchkind, typ')

    2. Else If (datatyp matches pattern `NewT%%`), then

      1. Let (NewT _id typ') be datatyp

      2. Return $check_table_key(matchkind, typ')

1. Else If (matchkind = "ternary"), then

  1. Let typ' be $canon_typ(typ)

  2. If $is_intt(typ'), then

    1. Return true

  3. If $is_fintt(typ'), then

    1. Return true

  4. If $is_fbitt(typ'), then

    1. Return true

  5. Let typ'' be $canon_typ(typ)

  6. If (typ'' has type datatyp), then

    1. Let datatyp be (typ'' as datatyp)

    2. If (datatyp matches pattern `SEnumT%%%`), then

      1. Let (SEnumT _id typ' _(member, val)*) be datatyp

      2. Return $check_table_key(matchkind, typ')

    2. Else If (datatyp matches pattern `NewT%%`), then

      1. Let (NewT _id typ') be datatyp

      2. Return $check_table_key(matchkind, typ')

1. Else If (matchkind = "range"), then

  1. Let typ' be $canon_typ(typ)

  2. If $is_intt(typ'), then

    1. Return true

  3. If $is_fintt(typ'), then

    1. Return true

  4. If $is_fbitt(typ'), then

    1. Return true

  5. Let typ'' be $canon_typ(typ)

  6. If (typ'' has type datatyp), then

    1. Let datatyp be (typ'' as datatyp)

    2. If (datatyp matches pattern `SEnumT%%%`), then

      1. Let (SEnumT _id typ' _(member, val)*) be datatyp

      2. Return $check_table_key(matchkind, typ')

    2. Else If (datatyp matches pattern `NewT%%`), then

      1. Let (NewT _id typ') be datatyp

      2. Return $check_table_key(matchkind, typ')

2. Otherwise

  1. Return false

;; ../../../../spec/4g-typing-decl.watsup:767.1-769.26
relation Table_keys_ok: p, C, tblctx, tblkey*

1. If (tblkey* matches pattern []), then

  1. Result in tblctx, []

1. Else If (tblkey* matches pattern _ :: _), then

  1. Let tblkey_h :: tblkey_t* be tblkey*

  2. Table_key_ok: p C tblctx |- tblkey_h : tblctx' tblkeyIL_h

  3. Table_keys_ok: p C tblctx' |- tblkey_t* : tblctx'' tblkeyIL_t*

  4. Result in tblctx'', tblkeyIL_h :: tblkeyIL_t*

;; ../../../../spec/4g-typing-decl.watsup:783.1-785.26
relation Call_action_partial_ok: p, C, pt*, (argIL, typ_a)*

1. Let (paramIL_d*, paramIL_c*) be $split_directionless_params((pt* as paramIL*))

2. If (|paramIL_d*| = |argIL*|), then

  1. (Call_convention_arg_ok: p C (ACT) |- (paramIL_d as paramtyp) ~~ (argIL, typ_a) : argIL')*

  2. Result in paramIL_d*, paramIL_c*, argIL'*

2. Else

  1. Phantom#1180

;; ../../../../spec/4g-typing-decl.watsup:787.1-788.46
def $split_directionless_params(paramIL*)

1. If (paramIL* matches pattern []), then

  1. Return ([], [])

1. Else If (paramIL* matches pattern _ :: _), then

  1. Let paramIL_h :: paramIL_t* be paramIL*

  2. Let (_idIL dir _typeIL _val?) be paramIL_h

  3. If (dir matches pattern `NO`), then

    1. Let (paramIL_d*, paramIL_c*) be $split_directionless_params(paramIL_t*)

    2. Return (paramIL_d*, paramIL_h :: paramIL_c*)

  3. Else If ~(dir matches pattern `NO`), then

    1. Let (paramIL_d*, paramIL_c*) be $split_directionless_params(paramIL_t*)

    2. Return (paramIL_h :: paramIL_d*, paramIL_c*)

;; ../../../../spec/4g-typing-decl.watsup:807.1-809.26
relation Table_action_ok: p, C, tblctx, (name arg*)

1. (Arg_ok: p C |- arg : argIL typ_a)*

2. Let funcdef? be $find_funcdef_by_name(p, C, name)

3. If (funcdef? matches pattern (_)), then

  1. Let ?(funcdef) be funcdef?

  2. If (funcdef has type monofuncdef), then

    1. Let (MonoFD functyp) be (funcdef as monofuncdef)

    2. If (functyp matches pattern `ActionT%`), then

      1. Let (ActionT pt*) be functyp

      2. Call_action_partial_ok: p C |- pt* (argIL, typ_a)* : paramIL_d* paramIL_c* argIL'*

      3. Let tblctx' be $add_action((name, pt*, argIL*), tblctx)

      4. Result in tblctx', (name argIL'* paramIL_d* paramIL_c*)

    2. Else

      1. Phantom#1181

  2. Else

    1. Phantom#1182

3. Else

  1. Phantom#1183

;; ../../../../spec/4g-typing-decl.watsup:821.1-823.26
relation Table_actions_ok: p, C, tblctx, tblaction*

1. If (tblaction* matches pattern []), then

  1. Result in tblctx, []

1. Else If (tblaction* matches pattern _ :: _), then

  1. Let tblaction_h :: tblaction_t* be tblaction*

  2. Table_action_ok: p C tblctx |- tblaction_h : tblctx' tblactionIL_h

  3. Table_actions_ok: p C tblctx' |- tblaction_t* : tblctx'' tblactionIL_t*

  4. Let tblactionIL* be tblactionIL_h :: tblactionIL_t*

  5. (Let (name argIL* paramIL_d* paramIL_c*) be tblactionIL)*

  6. If $distinct_<name>(name*), then

    1. Result in tblctx'', tblactionIL_h :: tblactionIL_t*

  6. Else

    1. Phantom#1184

;; ../../../../spec/4g-typing-decl.watsup:841.1-843.29
relation Table_entry_keyset_ok: p, C, tblctx, (typ_k, text'), keyset

1. If (text' = "lpm"), then

  1. If (keyset matches pattern `ExprK%`), then

    1. Let (ExprK expr) be keyset

    2. If (expr matches pattern `MaskE%%`), then

      1. Let (MaskE expr_b expr_m) be expr

      2. Expr_ok: p C |- (MaskE expr_b expr_m) : exprIL

      3. Let (( typ' ; _ctk )) be $annot(exprIL)

      4. If (typ' has type synthtyp), then

        1. Let synthtyp be (typ' as synthtyp)

        2. If (synthtyp matches pattern `SetT%`), then

          1. Let (SetT typ) be synthtyp

          2. Let exprIL' be exprIL

          3. If (exprIL' matches pattern `MaskE%%%`), then

            1. Let (MaskE exprIL_b exprIL_m _annotIL) be exprIL'

            2. Let mode be tblctx.MODE

            3. If (mode matches pattern `NOPRILPM%`), then

              1. Let (NOPRILPM n_w) be mode

              2. Eval_static: p C |- exprIL_m ~> val_m

              3. Let i_m be $get_num(val_m)

              4. Let tblstate_e be $get_lpm_prefix((FBitV n_w $to_bitstr((n_w as int), i_m)))

              5. If (Sub_impl: typ << typ_k holds), then

                1. Result in tblstate_e, (ExprK exprIL)

              5. Else

                1. Phantom#1202

            3. Else

              1. Phantom#1203

          3. Else

            1. Phantom#1204

        2. Else

          1. Phantom#1205

      4. Else

        1. Phantom#1206

    2. Else

      1. Phantom#1207

    3. If ~($is_maske(expr) \/ $is_rangee(expr)), then

      1. Expr_ok: p C |- expr : exprIL

      2. Let (( typ ; ctk )) be $annot(exprIL)

      3. Let mode be tblctx.MODE

      4. If (mode matches pattern `NOPRILPM%`), then

        1. Let (NOPRILPM n_w) be mode

        2. If (Sub_impl: typ << typ_k holds), then

          1. Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk )))

          2. Result in (LPM n_w), (ExprK exprIL')

        2. Else

          1. Phantom#1208

      4. Else

        1. Phantom#1209

    3. Else

      1. Phantom#1210

  1. Else If (keyset matches pattern `DefaultK`), then

    1. Let mode be tblctx.MODE

    2. If (mode matches pattern `NOPRILPM%`), then

      1. Let (NOPRILPM n_w) be mode

      2. Result in (LPM n_w), (DefaultK)

    2. Else

      1. Phantom#1201

  1. Else If (keyset matches pattern `AnyK`), then

    1. Let mode be tblctx.MODE

    2. If (mode matches pattern `NOPRILPM%`), then

      1. Let (NOPRILPM _nat) be mode

      2. Result in (LPM 0), (AnyK)

    2. Else

      1. Phantom#1200

1. Else If (text' = "ternary"), then

  1. If (keyset matches pattern `ExprK%`), then

    1. Let (ExprK expr) be keyset

    2. If (expr matches pattern `MaskE%%`), then

      1. Let (MaskE expr_b expr_m) be expr

      2. Expr_ok: p C |- (MaskE expr_b expr_m) : exprIL

      3. Let (( typ' ; _ctk )) be $annot(exprIL)

      4. If (typ' has type synthtyp), then

        1. Let synthtyp be (typ' as synthtyp)

        2. If (synthtyp matches pattern `SetT%`), then

          1. Let (SetT typ) be synthtyp

          2. If (Sub_impl: typ << typ_k holds), then

            1. Result in (NOLPM), (ExprK exprIL)

          2. Else

            1. Phantom#1193

        2. Else

          1. Phantom#1194

      4. Else

        1. Phantom#1195

    2. Else

      1. Phantom#1196

    3. If ~($is_maske(expr) \/ $is_rangee(expr)), then

      1. Expr_ok: p C |- expr : exprIL

      2. Let (( typ ; ctk )) be $annot(exprIL)

      3. If (Sub_impl: typ << typ_k holds), then

        1. Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk )))

        2. Result in (NOLPM), (ExprK exprIL')

      3. Else

        1. Phantom#1197

    3. Else

      1. Phantom#1198

  1. Else

    1. Phantom#1199

1. Else If (text' = "range"), then

  1. If (keyset matches pattern `ExprK%`), then

    1. Let (ExprK expr) be keyset

    2. If (expr matches pattern `RangeE%%`), then

      1. Let (RangeE expr_l expr_r) be expr

      2. Expr_ok: p C |- (RangeE expr_l expr_r) : exprIL

      3. Let (( typ' ; _ctk )) be $annot(exprIL)

      4. If (typ' has type synthtyp), then

        1. Let synthtyp be (typ' as synthtyp)

        2. If (synthtyp matches pattern `SetT%`), then

          1. Let (SetT typ) be synthtyp

          2. If (Sub_impl: typ << typ_k holds), then

            1. Result in (NOLPM), (ExprK exprIL)

          2. Else

            1. Phantom#1185

        2. Else

          1. Phantom#1186

      4. Else

        1. Phantom#1187

    2. Else

      1. Phantom#1188

    3. If ~($is_maske(expr) \/ $is_rangee(expr)), then

      1. Expr_ok: p C |- expr : exprIL

      2. Let (( typ ; ctk )) be $annot(exprIL)

      3. If (Sub_impl: typ << typ_k holds), then

        1. Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk )))

        2. Result in (NOLPM), (ExprK exprIL')

      3. Else

        1. Phantom#1189

    3. Else

      1. Phantom#1190

  1. Else

    1. Phantom#1191

1. Else

  1. Phantom#1192

2. If (keyset matches pattern `ExprK%`), then

  1. Let (ExprK expr) be keyset

  2. If (((text' =/= "lpm") /\ (text' =/= "ternary")) /\ (text' =/= "range")), then

    1. If ~($is_maske(expr) \/ $is_rangee(expr)), then

      1. Expr_ok: p C |- expr : exprIL

      2. Let (( typ ; ctk )) be $annot(exprIL)

      3. If (Sub_impl: typ << typ_k holds), then

        1. Let exprIL' be (CastE ((SetT typ_k) as typeIL) exprIL (( ((SetT typ_k) as typ) ; ctk )))

        2. Result in (NOLPM), (ExprK exprIL')

      3. Else

        1. Phantom#1213

    1. Else

      1. Phantom#1214

  2. Else

    1. Phantom#1215

2. Else If (keyset matches pattern `DefaultK`), then

  1. If (text' =/= "exact"), then

    1. Result in (NOLPM), (DefaultK)

  1. Else

    1. Phantom#1212

2. Else If (keyset matches pattern `AnyK`), then

  1. If (text' =/= "exact"), then

    1. Result in (NOLPM), (AnyK)

  1. Else

    1. Phantom#1211

;; ../../../../spec/4g-typing-decl.watsup:935.1-937.32
relation Table_entry_keysets_state_ok: p, C, tblctx, tblstate', key*, keyset*

1. If (key* matches pattern []), then

  1. If (keyset* matches pattern []), then

    1. Result in tblstate', []

  1. Else

    1. Phantom#1217

1. Else If (key* matches pattern _ :: _), then

  1. Let key_h :: key_t* be key*

  2. If (keyset* matches pattern _ :: _), then

    1. Let keyset_h :: keyset_t* be keyset*

    2. Table_entry_keyset_ok: p C tblctx |- key_h keyset_h : tblstate_1 keysetIL_h

    3. Let tblstate_2 be $update_state(tblstate', tblstate_1)

    4. Table_entry_keysets_state_ok: p C tblctx tblstate_2 |- key_t* keyset_t* : tblstate_3 keysetIL_t*

    5. Result in tblstate_3, keysetIL_h :: keysetIL_t*

  2. Else

    1. Phantom#1216

;; ../../../../spec/4g-typing-decl.watsup:949.1-951.26
relation Table_entry_keysets_ok: p, C, tblctx, keyset*'

1. If (keyset*' = [(DefaultK)]), then

  1. Let mode be tblctx.MODE

  2. If (mode matches pattern `NOPRILPM%`), then

    1. Let (NOPRILPM nat) be mode

    2. Result in (LPM nat), [(DefaultK)]

  2. Else

    1. Phantom#1218

  3. If (((tblctx.MODE = (NOPRI)) \/ (tblctx.MODE = (PRI))) \/ (tblctx.MODE = (PRILPM))), then

    1. Result in (NOLPM), [(DefaultK)]

  3. Else

    1. Phantom#1219

1. Else

  1. Phantom#1220

2. If (keyset*' = [(AnyK)]), then

  1. Let mode be tblctx.MODE

  2. If (mode matches pattern `NOPRILPM%`), then

    1. Let (NOPRILPM nat) be mode

    2. Result in (LPM 0), [(AnyK)]

  2. Else

    1. Phantom#1221

  3. If (((tblctx.MODE = (NOPRI)) \/ (tblctx.MODE = (PRI))) \/ (tblctx.MODE = (PRILPM))), then

    1. Result in (NOLPM), [(AnyK)]

  3. Else

    1. Phantom#1222

2. Else

  1. Phantom#1223

3. Let keyset* be keyset*'

4. If (|tblctx.KEYS| = |keyset*|), then

  1. Table_entry_keysets_state_ok: p C tblctx (NOLPM) |- tblctx.KEYS keyset* : tblstate keysetIL*

  2. Result in tblstate, keysetIL*

4. Else

  1. Phantom#1224

;; ../../../../spec/4g-typing-decl.watsup:975.1-977.29
relation Call_default_action_ok: p, C, pt*, (argIL, typ)*, argIL_a*

1. If (|pt*| = |argIL*|), then

  1. Let argIL_d* be $filter_directionless_args(pt*, argIL*)

  2. If ((argIL_a = argIL_d))*, then

    1. (Call_convention_arg_ok: p C (ACT) |- pt ~~ (argIL, typ) : argIL')*

    2. Result in argIL'*

  2. Else

    1. Phantom#1225

1. Else

  1. Phantom#1226

;; ../../../../spec/4g-typing-decl.watsup:979.1-979.59
def $filter_directionless_args(paramtyp*, argIL*)

1. If (paramtyp* matches pattern []), then

  1. If (argIL* matches pattern []), then

    1. Return []

  1. Else

    1. Phantom#1229

1. Else If (paramtyp* matches pattern _ :: _), then

  1. Let pt_h :: pt_t* be paramtyp*

  2. If (argIL* matches pattern _ :: _), then

    1. Let argIL_h :: argIL_t* be argIL*

    2. Let (id dir typ val?) be pt_h

    3. If (dir matches pattern `NO`), then

      1. Return $filter_directionless_args(pt_t*, argIL_t*)

    3. Else

      1. Phantom#1227

    4. Otherwise

      1. Return argIL_h :: $filter_directionless_args(pt_t*, argIL_t*)

  2. Else

    1. Phantom#1228

;; ../../../../spec/4g-typing-decl.watsup:997.1-999.26
relation Table_entry_action_ok: p, C, tblctx, (name arg*)

1. Let (paramtyp*, argIL*)? be $find_action(tblctx, name)

2. If ((paramtyp*, argIL*)? matches pattern (_)), then

  1. Let ?((pt*, argIL_a*)) be (paramtyp*, argIL*)?

  2. (Arg_ok: p C |- arg : argIL typ_arg)*

  3. Call_default_action_ok: p C |- pt* (argIL, typ_arg)* argIL_a* : argIL'*

  4. Let tblactionIL be (name argIL'* (pt* as paramIL*) [])

  5. Result in tblactionIL

2. Else

  1. Phantom#1230

;; ../../../../spec/4g-typing-decl.watsup:1012.1-1014.29
relation Table_entry_priority_ok: cursor, C, tblctx, tblstate, expr?

1. If (cursor matches pattern `LOCAL`), then

  1. If (expr? matches pattern ()), then

    1. If (tblctx.MODE matches pattern `NOPRI`), then

      1. Result in tblctx, ?()

    1. Else

      1. Phantom#1236

    2. If ((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM))), then

      1. If (tblctx.PRIORITIES.VALUES = []), then

        1. If tblctx.PRIORITIES.LARGEST_WINS, then

          1. Let i_size be tblctx.ENTRIES.SIZE

          2. Let i_delta be tblctx.PRIORITIES.DELTA

          3. Let i be (((i_size - (1 as int)) * i_delta) + (1 as int))

          4. If (i >= (0 as int)), then

            1. Let tblctx' be $add_priority(i, tblctx)

            2. Result in tblctx', ?((IntV i))

          4. Else

            1. Phantom#1239

        1. Else If ~tblctx.PRIORITIES.LARGEST_WINS, then

          1. Let tblctx' be $add_priority((1 as int), tblctx)

          2. Result in tblctx', ?((IntV (1 as int)))

      1. Else If (tblctx.PRIORITIES.VALUES =/= []), then

        1. Let i_delta be tblctx.PRIORITIES.DELTA

        2. Let i be $find_last_priority(tblctx)

        3. If tblctx.PRIORITIES.LARGEST_WINS, then

          1. Let i' be (i - i_delta)

          2. If (i' >= (0 as int)), then

            1. Let tblctx' be $add_priority(i', tblctx)

            2. Result in tblctx', ?((IntV i'))

          2. Else

            1. Phantom#1238

        3. Else If ~tblctx.PRIORITIES.LARGEST_WINS, then

          1. Let i' be (i + i_delta)

          2. If (i' >= (0 as int)), then

            1. Let tblctx' be $add_priority(i', tblctx)

            2. Result in tblctx', ?((IntV i'))

          2. Else

            1. Phantom#1237

    2. Else

      1. Phantom#1240

  1. Else If (expr? matches pattern (_)), then

    1. Let ?(expr) be expr?

    2. If ((tblctx.MODE = (PRI)) \/ (tblctx.MODE = (PRILPM))), then

      1. If ~tblctx.ENTRIES.CONST, then

        1. If (tblctx.PRIORITIES.VALUES = []), then

          1. Expr_ok: (LOCAL) C |- expr : exprIL

          2. Eval_static: (LOCAL) C |- exprIL ~> val

          3. Let i be $get_num(val)

          4. If (i >= (0 as int)), then

            1. Let tblctx' be tblctx[PRIORITIES.INIT = true]

            2. Let tblctx'' be $add_priority(i, tblctx')

            3. Result in tblctx'', ?((IntV i))

          4. Else

            1. Phantom#1233

        1. Else If (tblctx.PRIORITIES.VALUES =/= []), then

          1. If tblctx.PRIORITIES.INIT, then

            1. Expr_ok: (LOCAL) C |- expr : exprIL

            2. Eval_static: (LOCAL) C |- exprIL ~> val

            3. Let i be $get_num(val)

            4. If (i >= (0 as int)), then

              1. Let tblctx' be $add_priority(i, tblctx)

              2. Result in tblctx', ?((IntV i))

            4. Else

              1. Phantom#1231

          1. Else

            1. Phantom#1232

      1. Else

        1. Phantom#1234

    2. Else

      1. Phantom#1235

  2. If (tblstate matches pattern `LPM%`), then

    1. Let (LPM nat_prefix) be tblstate

    2. If (expr? matches pattern ()), then

      1. Let mode be tblctx.MODE

      2. If (mode matches pattern `NOPRILPM%`), then

        1. Let (NOPRILPM nat) be mode

        2. Result in tblctx, ?()

      2. Else

        1. Phantom#1241

    2. Else

      1. Phantom#1242

  2. Else

    1. Phantom#1243

1. Else

  1. Phantom#1244

;; ../../../../spec/4g-typing-decl.watsup:1105.1-1107.26
relation Table_entry_ok: p, C, tblctx, (bool keyset* tblaction expr?)

1. Table_entry_keysets_ok: p C tblctx |- keyset* : tblstate keysetIL*

2. Table_entry_action_ok: p C tblctx |- tblaction : tblactionIL

3. Table_entry_priority_ok: p C tblctx tblstate |- expr? : tblctx' val?

4. Result in tblctx', (bool keysetIL* tblactionIL val?)

;; ../../../../spec/4g-typing-decl.watsup:1118.1-1120.26
relation Table_entries_fold_ok: p, C, tblctx, tblentry*

1. If (tblentry* matches pattern []), then

  1. Result in tblctx, []

1. Else If (tblentry* matches pattern _ :: _), then

  1. Let tblentry_h :: tblentry_t* be tblentry*

  2. Table_entry_ok: p C tblctx |- tblentry_h : tblctx' tblentryIL_h

  3. Table_entries_fold_ok: p C tblctx' |- tblentry_t* : tblctx'' tblentryIL_t*

  4. Result in tblctx'', tblentryIL_h :: tblentryIL_t*

;; ../../../../spec/4g-typing-decl.watsup:1131.1-1133.26
relation Table_entries_ok: p, C, tblctx_0, (b tblentry*)

1. If ((|tblctx_0.KEYS| = 0) => (|tblentry*| = 0)), then

  1. Let tblctx_1 be tblctx_0[ENTRIES.SIZE = (|tblentry*| as int)]

  2. Let tblctx_2 be tblctx_1[ENTRIES.CONST = b]

  3. Table_entries_fold_ok: p C tblctx_2 |- tblentry* : tblctx_3 tblentryIL*

  4. Result in tblctx_3, (b tblentryIL*)

1. Else

  1. Phantom#1245

;; ../../../../spec/4g-typing-decl.watsup:1148.1-1150.26
relation Table_default_ok: p, C, tblctx, (bool (name arg*))

1. Let (paramtyp*, argIL*)? be $find_action(tblctx, name)

2. If ((paramtyp*, argIL*)? matches pattern (_)), then

  1. Let ?((pt*, argIL_a*)) be (paramtyp*, argIL*)?

  2. (Arg_ok: p C |- arg : argIL typ_a)*

  3. Call_default_action_ok: p C |- pt* (argIL, typ_a)* argIL_a* : argIL'*

  4. Let tblactionIL be (name argIL'* (pt* as paramIL*) [])

  5. Result in (bool tblactionIL)

2. Else

  1. Phantom#1246

;; ../../../../spec/4g-typing-decl.watsup:1166.1-1168.26
relation Table_custom_ok: p, C, tblctx, (b text' expr)

1. If (text' = "size"), then

  1. Expr_ok: p C |- expr : exprIL

  2. Let (( typ ; _ctk )) be $annot(exprIL)

  3. If (($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ)), then

    1. Result in tblctx, (b "size" exprIL)

  3. Else

    1. Phantom#1252

1. Else If (text' = "largest_priority_wins"), then

  1. Expr_ok: p C |- expr : exprIL

  2. Let (( typ ; _ctk )) be $annot(exprIL)

  3. If (typ = ((BoolT) as typ)), then

    1. Eval_static: p C |- exprIL ~> val

    2. If (val matches pattern `BoolV%`), then

      1. Let (BoolV b_lw) be val

      2. Let tblctx' be tblctx[PRIORITIES.LARGEST_WINS = b_lw]

      3. Result in tblctx', (b "largest_priority_wins" exprIL)

    2. Else

      1. Phantom#1250

  3. Else

    1. Phantom#1251

1. Else If (text' = "priority_delta"), then

  1. Expr_ok: p C |- expr : exprIL

  2. Let (( typ ; _ctk )) be $annot(exprIL)

  3. If (($is_intt(typ) \/ $is_fintt(typ)) \/ $is_fbitt(typ)), then

    1. Eval_static: p C |- exprIL ~> val

    2. Let i_delta be $get_num(val)

    3. If (i_delta > (0 as int)), then

      1. Let tblctx' be tblctx[PRIORITIES.DELTA = i_delta]

      2. Result in tblctx', (b "priority_delta" exprIL)

    3. Else

      1. Phantom#1247

  3. Else

    1. Phantom#1248

1. Else

  1. Phantom#1249

2. If (((text' =/= "size") /\ (text' =/= "largest_priority_wins")) /\ (text' =/= "priority_delta")), then

  1. Expr_ok: p C |- expr : exprIL

  2. Result in tblctx, (b text' exprIL)

2. Else

  1. Phantom#1253

;; ../../../../spec/4g-typing-decl.watsup:1203.1-1205.26
relation Table_prop_ok: p, C, tblctx, tblprop

1. If (tblprop matches pattern `KeyP%`), then

  1. Let (KeyP tblkeyprop) be tblprop

  2. Table_keys_ok: p C tblctx |- tblkeyprop : tblctx' tblkeypropIL

  3. Result in tblctx', (KeyP tblkeypropIL)

1. Else If (tblprop matches pattern `ActionP%`), then

  1. Let (ActionP tblactionprop) be tblprop

  2. Table_actions_ok: p C tblctx |- tblactionprop : tblctx' tblactionpropIL

  3. Result in tblctx', (ActionP tblactionpropIL)

1. Else If (tblprop matches pattern `EntryP%`), then

  1. Let (EntryP tblentryprop) be tblprop

  2. Table_entries_ok: p C tblctx |- tblentryprop : tblctx' tblentrypropIL

  3. Result in tblctx', (EntryP tblentrypropIL)

1. Else If (tblprop matches pattern `DefaultP%`), then

  1. Let (DefaultP tbldefaultprop) be tblprop

  2. Table_default_ok: p C tblctx |- tbldefaultprop : tbldefaultpropIL

  3. Result in tblctx, (DefaultP tbldefaultpropIL)

1. Else If (tblprop matches pattern `CustomP%`), then

  1. Let (CustomP tblcustomprop) be tblprop

  2. Table_custom_ok: p C tblctx |- tblcustomprop : tblctx' tblcustompropIL

  3. Result in tblctx', (CustomP tblcustompropIL)

;; ../../../../spec/4g-typing-decl.watsup:1228.1-1230.26
relation Table_props_ok: p, C, tblctx, tblprop*

1. If (tblprop* matches pattern []), then

  1. Result in tblctx, []

1. Else If (tblprop* matches pattern _ :: _), then

  1. Let tblprop_h :: tblprop_t* be tblprop*

  2. Table_prop_ok: p C tblctx |- tblprop_h : tblctx' tblpropIL_h

  3. Table_props_ok: p C tblctx' |- tblprop_t* : tblctx'' tblpropIL_t*

  4. Result in tblctx'', tblpropIL_h :: tblpropIL_t*

;; ../../../../spec/4g-typing-decl.watsup:1244.1-1246.26
relation Table_type_decl_ok: cursor, C, tblctx, id

1. If (cursor matches pattern `BLOCK`), then

  1. Let id_e be $concat_text(["action_list(", id, ")"])

  2. Let (name, pt*, argIL*)* be tblctx.ACTIONS

  3. (Let member be $string_of_name(name))*

  4. Let typ_e be ((TableEnumT id_e member*) as typ)

  5. (Let val_e be (TableEnumFieldV id_e member))*

  6. (Let id_f be $concat_text([id_e, ".", member]))*

  7. Let C' be $add_styps((BLOCK), C, id_f*, (typ_e (NO) (LCTK) ?(val_e))*)

  8. Let id_s be $concat_text(["apply_result(", id, ")"])

  9. Let typ_s be ((TableStructT id_s [("hit", ((BoolT) as typ)), ("miss", ((BoolT) as typ)), ("action_run", typ_e)]) as typ)

  10. Result in C', typ_s

1. Else

  1. Phantom#1254

;; ../../../../spec/4h-typing-call.watsup:149.1-150.77
def $filter_default_args(paramtyp*, id_deft*)

1. If (paramtyp* matches pattern []), then

  1. Return []

1. Else If (paramtyp* matches pattern _ :: _), then

  1. Let pt_h :: pt_t* be paramtyp*

  2. Let (id_p _dir _typ _val?) be pt_h

  3. If id_p is in id_deft*, then

    1. Return $filter_default_args(pt_t*, id_deft*)

  3. Else

    1. Phantom#1255

  4. Otherwise

    1. Return pt_h :: $filter_default_args(pt_t*, id_deft*)

;; ../../../../spec/4h-typing-call.watsup:161.15-161.32
syntax pmap = map<id, paramtyp>

;; ../../../../spec/4h-typing-call.watsup:163.1-164.80
def $align_params_with_args(pt*, (argIL, typ)*)

1. (Let (id _dir _typ _val?) be pt)*

2. Let pmap be ({ (id -> pt)* })

3. (Let pt' be $align_params_with_args'(pmap, pt, (argIL, typ)))*

4. Return pt'*

;; ../../../../spec/4h-typing-call.watsup:165.1-166.97
def $align_params_with_args'(pmap, pt, (argIL, _typ))

1. If (argIL matches pattern `ExprA%`), then

  1. Let (ExprA _exprIL) be argIL

  2. Return pt

1. Else If (argIL matches pattern `NameA%%`), then

  1. Let (NameA id _exprIL?) be argIL

  2. Let paramtyp? be $find_map<id, paramtyp>(pmap, id)

  3. If (paramtyp? matches pattern (_)), then

    1. Let ?(pt') be paramtyp?

    2. Return pt'

  3. Else

    1. Phantom#1256

1. Else If (argIL matches pattern `AnyA`), then

  1. Return pt

;; ../../../../spec/4h-typing-call.watsup:183.1-184.12
syntax typcstr = 
   | `KNOWN%`(typ)
   | `UNKNOWN`()

;; ../../../../spec/4h-typing-call.watsup:188.1-188.42
def $empty_cstr(tid*)

1. Return ({ (tid -> (UNKNOWN))* })

;; ../../../../spec/4h-typing-call.watsup:194.1-194.63
def $gen_cstr(cstr, typ'', typ_a''')

1. If (typ'' has type abstyp), then

  1. Let abstyp be (typ'' as abstyp)

  2. If (abstyp matches pattern `VarT%`), then

    1. Let (VarT tid) be abstyp

    2. If $in_set<tid>(tid, $dom_map<tid, typcstr>(cstr)), then

      1. Return $update_map<tid, typcstr>(cstr, tid, (KNOWN typ_a'''))

  2. Else If (abstyp matches pattern `SpecT%%`), then

    1. Let (SpecT ptd_p typ_p'*) be abstyp

    2. If (typ_a''' has type abstyp), then

      1. Let abstyp' be (typ_a''' as abstyp)

      2. If (abstyp' matches pattern `SpecT%%`), then

        1. Let (SpecT ptd_a typ_a'*) be abstyp'

        2. Let typ_p'' be $specialize_typdef((ptd_p as typdef), typ_p'*)

        3. Let typ_a'' be $specialize_typdef((ptd_a as typdef), typ_a'*)

        4. If ($is_nominal(typ_p'') /\ $is_nominal(typ_a'')), then

          1. Let cstr' be $gen_cstr(cstr, typ_p'', typ_a'')

          2. Return $gen_cstrs(cstr', typ_p'*, typ_a'*)

        4. Else If ~($is_nominal(typ_p'') /\ $is_nominal(typ_a'')), then

          1. Let cstr' be $gen_cstr(cstr, typ_p'', typ_a'')

          2. Return cstr'

1. Else If (typ'' has type aliastyp), then

  1. Let (DefT typ_p') be (typ'' as aliastyp)

  2. Return $gen_cstr(cstr, typ_p', typ_a''')

1. Else If (typ'' has type datatyp), then

  1. Let datatyp be (typ'' as datatyp)

  2. If (datatyp matches pattern `NewT%%`), then

    1. Let (NewT id typ_p') be datatyp

    2. If (typ_a''' has type datatyp), then

      1. Let datatyp' be (typ_a''' as datatyp)

      2. If (datatyp' matches pattern `NewT%%`), then

        1. Let (NewT id' typ_a') be datatyp'

        2. If (id = id'), then

          1. Return $gen_cstr(cstr, typ_p', typ_a')

  2. Else If (datatyp matches pattern `ListT%`), then

    1. Let (ListT typ'') be datatyp

    2. If (typ_a''' has type datatyp), then

      1. Let datatyp' be (typ_a''' as datatyp)

      2. If (datatyp' matches pattern `ListT%`), then

        1. Let (ListT typ_a''') be datatyp'

        2. Return $gen_cstr(cstr, typ'', typ_a''')

  2. Else If (datatyp matches pattern `TupleT%`), then

    1. Let (TupleT typ''*) be datatyp

    2. If (typ_a''' has type datatyp), then

      1. Let datatyp' be (typ_a''' as datatyp)

      2. If (datatyp' matches pattern `TupleT%`), then

        1. Let (TupleT typ_a'''*) be datatyp'

        2. Return $gen_cstrs(cstr, typ''*, typ_a'''*)

  2. Else If (datatyp matches pattern `StackT%%`), then

    1. Let (StackT typ_p' i_p) be datatyp

    2. If (typ_a''' has type datatyp), then

      1. Let datatyp' be (typ_a''' as datatyp)

      2. If (datatyp' matches pattern `StackT%%`), then

        1. Let (StackT typ_a' i_a) be datatyp'

        2. Return $gen_cstr(cstr, typ_p', typ_a')

  2. Else If (datatyp matches pattern `StructT%%`), then

    1. Let (StructT id (member_p, typ_p')*) be datatyp

    2. If (typ_a''' has type datatyp), then

      1. Let datatyp' be (typ_a''' as datatyp)

      2. If (datatyp' matches pattern `StructT%%`), then

        1. Let (StructT id' (member_a, typ_a')*) be datatyp'

        2. If (id = id'), then

          1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

  2. Else If (datatyp matches pattern `HeaderT%%`), then

    1. Let (HeaderT id (member_p, typ_p')*) be datatyp

    2. If (typ_a''' has type datatyp), then

      1. Let datatyp' be (typ_a''' as datatyp)

      2. If (datatyp' matches pattern `HeaderT%%`), then

        1. Let (HeaderT id' (member_a, typ_a')*) be datatyp'

        2. If (id = id'), then

          1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

  2. Else If (datatyp matches pattern `UnionT%%`), then

    1. Let (UnionT id (member_p, typ_p')*) be datatyp

    2. If (typ_a''' has type datatyp), then

      1. Let datatyp' be (typ_a''' as datatyp)

      2. If (datatyp' matches pattern `UnionT%%`), then

        1. Let (UnionT id' (member_a, typ_a')*) be datatyp'

        2. If (id = id'), then

          1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

1. Else If (typ'' has type objtyp), then

  1. Let objtyp be (typ'' as objtyp)

  2. If (objtyp matches pattern `ExternT%%`), then

    1. Let (ExternT id fdenv_p) be objtyp

    2. If (typ_a''' has type objtyp), then

      1. Let objtyp' be (typ_a''' as objtyp)

      2. If (objtyp' matches pattern `ExternT%%`), then

        1. Let (ExternT id' fdenv_a) be objtyp'

        2. If (id = id'), then

          1. Let ({ (fid_p -> fd_p)* }) be fdenv_p

          2. Let ({ (fid_a -> fd_a)* }) be fdenv_a

          3. If $eq_set<fid>(({ fid_p* }), ({ fid_a* })), then

            1. Return $gen_cstr_fd'(cstr, fid_p*, fdenv_p, fdenv_a)

  2. Else If (objtyp matches pattern `ParserT%`), then

    1. Let (ParserT pt_p*) be objtyp

    2. If (typ_a''' has type objtyp), then

      1. Let objtyp' be (typ_a''' as objtyp)

      2. If (objtyp' matches pattern `ParserT%`), then

        1. Let (ParserT pt_a*) be objtyp'

        2. (Let (_id dir typ_p' _val?) be pt_p)*

        3. (Let (_id' dir' typ_a' _val?') be pt_a)*

        4. If ((dir' = dir))*, then

          1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

  2. Else If (objtyp matches pattern `ControlT%`), then

    1. Let (ControlT pt_p*) be objtyp

    2. If (typ_a''' has type objtyp), then

      1. Let objtyp' be (typ_a''' as objtyp)

      2. If (objtyp' matches pattern `ControlT%`), then

        1. Let (ControlT pt_a*) be objtyp'

        2. (Let (_id dir typ_p' _val?) be pt_p)*

        3. (Let (_id' dir' typ_a' _val?') be pt_a)*

        4. If ((dir' = dir))*, then

          1. Return $gen_cstrs(cstr, typ_p'*, typ_a'*)

  2. Else If (objtyp matches pattern `PackageT%`), then

    1. Let (PackageT typ''*) be objtyp

    2. If (typ_a''' has type objtyp), then

      1. Let objtyp' be (typ_a''' as objtyp)

      2. If (objtyp' matches pattern `PackageT%`), then

        1. Let (PackageT typ_a'''*) be objtyp'

        2. Return $gen_cstrs(cstr, typ''*, typ_a'''*)

2. If (typ_a''' has type aliastyp), then

  1. Let (DefT typ_a') be (typ_a''' as aliastyp)

  2. Return $gen_cstr(cstr, typ'', typ_a')

3. Otherwise

  1. Return cstr

;; ../../../../spec/4h-typing-call.watsup:196.1-196.66
def $gen_cstrs(cstr, typ_p*, typ_a*)

1. If (|typ_p*| = |typ_a*|), then

  1. (Let cstr' be $gen_cstr(cstr, typ_p, typ_a))*

  2. Return $merge_cstrs(cstr, cstr'*)

1. Else

  1. Phantom#1257

;; ../../../../spec/4h-typing-call.watsup:198.1-198.74
def $gen_cstr_fd(cstr, fd_p, fd_a)

1. Let (_id _dir typ_p _val?)* be $get_params_funcdef(fd_p)

2. Let (_id' _dir' typ_a _val?')* be $get_params_funcdef(fd_a)

3. Let cstr' be $gen_cstrs(cstr, typ_p*, typ_a*)

4. Let cstr'' be $gen_cstr(cstr', $get_typ_ret_funcdef(fd_p), $get_typ_ret_funcdef(fd_a))

5. Return cstr''

;; ../../../../spec/4h-typing-call.watsup:200.1-200.77
def $gen_cstr_fd'(cstr, fid*, fdenv_p, fdenv_a)

1. If (fid* matches pattern []), then

  1. Return cstr

1. Else If (fid* matches pattern _ :: _), then

  1. Let fid_h :: fid_t* be fid*

  2. Let funcdef? be $find_map<fid, funcdef>(fdenv_p, fid_h)

  3. If (funcdef? matches pattern (_)), then

    1. Let ?(fd_p) be funcdef?

    2. Let funcdef?' be $find_map<fid, funcdef>(fdenv_a, fid_h)

    3. If (funcdef?' matches pattern (_)), then

      1. Let ?(fd_a) be funcdef?'

      2. Let cstr' be $gen_cstr_fd(cstr, fd_p, fd_a)

      3. Return $gen_cstr_fd'(cstr', fid_t*, fdenv_p, fdenv_a)

    3. Else

      1. Phantom#1258

  3. Else

    1. Phantom#1259

;; ../../../../spec/4h-typing-call.watsup:202.1-202.74
def $merge_cstr(cstr_o, cstr_n)

1. Let ({ tid_o* }) be $dom_map<tid, typcstr>(cstr_o)

2. If $eq_set<tid>($dom_map<tid, typcstr>(cstr_o), $dom_map<tid, typcstr>(cstr_n)), then

  1. Return $merge_cstr'(cstr_o, cstr_n, tid_o*, ({ [] }))

2. Else

  1. Phantom#1260

;; ../../../../spec/4h-typing-call.watsup:204.1-204.100
def $merge_cstr'(cstr_o, cstr_n, tid*, cstr)

1. If (tid* matches pattern []), then

  1. Return cstr

1. Else If (tid* matches pattern _ :: _), then

  1. Let tid_h :: tid_t* be tid*

  2. If ($find_map<tid, typcstr>(cstr_o, tid_h) = ?((UNKNOWN))), then

    1. If ($find_map<tid, typcstr>(cstr_n, tid_h) = ?((UNKNOWN))), then

      1. Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (UNKNOWN))

      2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

    1. Else

      1. Phantom#1261

    2. Let typcstr? be $find_map<tid, typcstr>(cstr_n, tid_h)

    3. If (typcstr? matches pattern (_)), then

      1. Let ?(typcstr) be typcstr?

      2. If (typcstr matches pattern `KNOWN%`), then

        1. Let (KNOWN typ_n) be typcstr

        2. Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_n))

        3. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

      2. Else

        1. Phantom#1262

    3. Else

      1. Phantom#1263

  2. Else

    1. Phantom#1264

  3. Let typcstr? be $find_map<tid, typcstr>(cstr_o, tid_h)

  4. If (typcstr? matches pattern (_)), then

    1. Let ?(typcstr) be typcstr?

    2. If (typcstr matches pattern `KNOWN%`), then

      1. Let (KNOWN typ_o) be typcstr

      2. If ($find_map<tid, typcstr>(cstr_n, tid_h) = ?((UNKNOWN))), then

        1. Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_o))

        2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

      2. Else

        1. Phantom#1265

      3. Let typcstr?' be $find_map<tid, typcstr>(cstr_n, tid_h)

      4. If (typcstr?' matches pattern (_)), then

        1. Let ?(typcstr') be typcstr?'

        2. If (typcstr' matches pattern `KNOWN%`), then

          1. Let (KNOWN typ_n) be typcstr'

          2. If (Sub_impl: typ_o << typ_n holds), then

            1. Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_n))

            2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

          2. Else If ~(Sub_impl: typ_o << typ_n holds), then

            1. If (Sub_impl: typ_n << typ_o holds), then

              1. Let cstr' be $update_map<tid, typcstr>(cstr, tid_h, (KNOWN typ_o))

              2. Return $merge_cstr'(cstr_o, cstr_n, tid_t*, cstr')

            1. Else

              1. Phantom#1266

        2. Else

          1. Phantom#1267

      4. Else

        1. Phantom#1268

    2. Else

      1. Phantom#1269

  4. Else

    1. Phantom#1270

;; ../../../../spec/4h-typing-call.watsup:206.1-206.76
def $merge_cstrs(cstr, map<tid, typcstr>*)

1. If (map<tid, typcstr>* matches pattern []), then

  1. Return cstr

1. Else If (map<tid, typcstr>* matches pattern _ :: _), then

  1. Let cstr_h :: cstr_t* be map<tid, typcstr>*

  2. Let cstr' be $merge_cstr(cstr, cstr_h)

  3. Let cstr'' be $merge_cstrs(cstr', cstr_t*)

  4. Return cstr''

;; ../../../../spec/4h-typing-call.watsup:208.1-208.54
def $resolve_cstrs(set<pair<tid, typcstr>>')

1. If (set<pair<tid, typcstr>>' = ({ [] })), then

  1. Return ({ [] })

1. Else

  1. Phantom#1271

2. Let ({ pair<tid, typcstr>* }) be set<pair<tid, typcstr>>'

3. If (pair<tid, typcstr>* matches pattern _ :: _), then

  1. Let (tid_h -> typcstr) :: (tid_t -> typcstr_t)* be pair<tid, typcstr>*

  2. If (typcstr matches pattern `KNOWN%`), then

    1. Let (KNOWN typ_h) be typcstr

    2. If (typ_h =/= ((AnyT) as typ)), then

      1. Let ({ (tid_t' -> typ_t')* }) be $resolve_cstrs(({ (tid_t -> typcstr_t)* }))

      2. Return $add_map<tid, typ>(({ (tid_t' -> typ_t')* }), tid_h, typ_h)

    2. Else

      1. Phantom#1272

  2. Else

    1. Phantom#1273

3. Else

  1. Phantom#1274

;; ../../../../spec/4h-typing-call.watsup:332.1-332.56
def $infer_targs(tid*, (id dir typ_p val?)*, typ_a*)

1. Let cstr be $empty_cstr(tid*)

2. Let cstr' be $gen_cstrs(cstr, typ_p*, typ_a*)

3. Return $resolve_cstrs(cstr')

;; ../../../../spec/4h-typing-call.watsup:438.1-439.43
def $is_table_apply_in_action_arg(argIL)

1. Return false
